<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Road To Excelsior">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="Road To Excelsior">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Robinson">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Road To Excelsior</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Road To Excelsior</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2019/05/08/2018-10-14-html-css-mindmap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Robinson">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Road To Excelsior">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/05/08/2018-10-14-html-css-mindmap/" class="post-title-link" itemprop="url">MindMap of html & css</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-05-08 15:53:10" itemprop="dateCreated datePublished" datetime="2019-05-08T15:53:10+08:00">2019-05-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-12-18 00:42:52" itemprop="dateModified" datetime="2020-12-18T00:42:52+08:00">2020-12-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><p>除了思维导图中需要了解的知识点，其中，需要注意的是CSS的结构和层叠，这个可在CSS权威指南第三章中找到，其主要包括特殊性，继承以及层叠。</p>
<p><strong>继承(Inheritance)**是从一个元素向其后代元素传递属性值所采用的机制；确定应当向一个元素应用哪些值时，用户代理不仅需要考虑继承，还要考虑声明的特殊性，另外需要考虑声明本身的来源。这个过程就叫着</strong>层叠(cascade)**。</p>
<h3 id="特殊性"><a href="#特殊性" class="headerlink" title="特殊性"></a>特殊性</h3><p>对于每条规则，用户代理会计算出选择器的特殊性，并将这些特殊性附加到规则中的各个声明。如果一个元素有两个或者多个冲突的属性声明，那么有最高特殊性的声明就会胜出。</p>
<p>详情可见书中该章节内容；</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承是CSS中最基本的内容之一；需要注意的是，有一些属性不能继承，这往往归因于一个简单的常识，例如属性boarder就不会继承。<br>一般地，大多数框模型属性（包括外边距，内边距，背景和边框）都不能继承。</p>
<p>同时，需要注意的是，继承的值没有特殊性，甚至连0特殊性都没有。</p>
<h3 id="层叠"><a href="#层叠" class="headerlink" title="层叠"></a>层叠</h3><p>CSS2.1的层叠规则如下：</p>
<ol>
<li>找出所有相关的规则，这些规则都包含与一个给定的元素匹配的选择器；</li>
<li>按<em>显示权重</em>对应用到该元素的所有声明进行排序。规则如下面所示；</li>
<li>按<em>特殊性</em>对应用到给定元素的所有声明排序。有较高特殊性的元素权重要大于较低特殊性的元素；</li>
<li>按出现顺序对应用到给定元素的所有声明排序。一个声明在样式表或文档中越后出现，它的权重远大。如果样式表中有导入的样式表，一般认为在导入样式表中的声明在前，主样式表中的所有声明在后。</li>
</ol>
<p>在声明权重方面需要考虑5级，权重有大至小的顺序依次为：</p>
<ol>
<li>读者的重要声明</li>
<li>创作人员的重要声明</li>
<li>创作人员的正常声明</li>
<li>读者的正常声明</li>
<li>用户代理的声明</li>
</ol>
<h2 id="总结和思考"><a href="#总结和思考" class="headerlink" title="总结和思考"></a>总结和思考</h2><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ol>
<li><a href="/assets/posts/html-css/HTML+CSS.itmz">html+css思维导图</a></li>
<li>《CSS权威指南(第三版)》</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2019/05/08/2018-10-18-CGLib/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Robinson">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Road To Excelsior">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/05/08/2018-10-18-CGLib/" class="post-title-link" itemprop="url">cglib</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-05-08 15:53:10" itemprop="dateCreated datePublished" datetime="2019-05-08T15:53:10+08:00">2019-05-08</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><blockquote>
<p>cglib - Byte Code Generation Library is high level API to generate and transform Java byte code. It is used by AOP, testing, data access frameworks to generate dynamic proxy objects and intercept field access.</p>
</blockquote>
<p>简单来说，cglib是一个Java 字节码生成器。其可以被用在AOP，测试，数据获取框架中去生成 <strong>动态代理对象</strong> 以及拦截获取字段。</p>
<h2 id="1-Toast"><a href="#1-Toast" class="headerlink" title="1. Toast"></a>1. Toast</h2><p>一如以前，从一个实际的例子出发，我们定义了一个简单的Cglib的demo，来观察其外在的表现。<br>首先定义了一个要代理的类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Object Dao update&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Dao object select&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后为其创建一个代理，通过实现MethodInterceptor接口，为其在方法调用前后记录一些东西：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DaoProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before method invoke&quot;</span>);</span><br><span class="line">        methodProxy.invokeSuper(o, objects);</span><br><span class="line">        System.out.println(<span class="string">&quot;After method invoke&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在写一个简单的测试类，来打印AOP拦截的输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DaoTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCglib</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DaoProxy daoProxy = <span class="keyword">new</span> DaoProxy();</span><br><span class="line"></span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setSuperclass(Dao.class);</span><br><span class="line">        enhancer.setCallback(daoProxy);</span><br><span class="line"></span><br><span class="line">        Dao dao = (Dao) enhancer.create();</span><br><span class="line">        dao.update();</span><br><span class="line">        dao.select();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其结果打印如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">before method invoke</span><br><span class="line">Object Dao update</span><br><span class="line">After method invoke</span><br><span class="line">before method invoke</span><br><span class="line">Dao object select</span><br><span class="line">After method invoke</span><br></pre></td></tr></table></figure>

<h2 id="2-初识"><a href="#2-初识" class="headerlink" title="2.初识"></a>2.初识</h2><p>现在，来观察方法拦截器接口的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * General-purpose &#123;<span class="doctag">@link</span> Enhancer&#125; callback which provides for &quot;around advice&quot;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Juozas Baliuka &lt;a href=&quot;mailto:baliuka@mwm.lt&quot;&gt;baliuka@mwm.lt&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> $Id: MethodInterceptor.java,v 1.8 2004/06/24 21:15:20 herbyderby Exp $</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MethodInterceptor</span></span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">Callback</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * All generated proxied methods call this method instead of the original method.</span></span><br><span class="line"><span class="comment">     * The original method may either be invoked by normal reflection using the Method object,</span></span><br><span class="line"><span class="comment">     * or by using the MethodProxy (faster).</span></span><br><span class="line"><span class="comment">     * 所有生成的代理方法会调用这个方法，而不是原始的方法。原始的方法可能会通过使用方法对象进行正常的反射操作；或者使用方法代理对象（这样更快些）。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> obj &quot;this&quot;, the enhanced object：增强的对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method intercepted Method：拦截的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args argument array; primitive types are wrapped：参数数组，原始类型需要被封装</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proxy used to invoke super (non-intercepted method); may be called</span></span><br><span class="line"><span class="comment">     * as many times as needed：被用来调用父（没有拦截的方法）；可能会被调用多次</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable any exception may be thrown; if so, super method will not be invoked</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> any value compatible with the signature of the proxied method. Method returning void will ignore this value.</span></span><br><span class="line"><span class="comment">     * 返回：任何与代理方法签名兼容的值。方法返回void则会忽略这个值。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> MethodProxy</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, java.lang.reflect.Method method, Object[] args,</span></span></span><br><span class="line"><span class="function"><span class="params">                               MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，Cglib还是提供了若干个其他的回调类型（见Callback的注释）。如：</p>
<ol>
<li>@see MethodInterceptor</li>
<li>@see NoOp</li>
<li>@see LazyLoader</li>
<li>@see Dispatcher</li>
<li>@see InvocationHandler</li>
<li>@see FixedValue</li>
</ol>
<p>在完成了对方法的拦截之后，Demo在测试中调用了Enhancer对象来完成代理类的创建。至于创建一个代理，至少需要一个 <strong>被代理类</strong>。在Demo中，新建了一个Enhancer对象，然后分别设置了代理类和回调。分别看一下各自的源代码及其注释：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Set the class which the generated class will extend. As a convenience,</span></span><br><span class="line"><span class="comment">     * if the supplied superclass is actually an interface, &lt;code&gt;setInterfaces&lt;/code&gt;</span></span><br><span class="line"><span class="comment">     * will be called with the appropriate argument instead.</span></span><br><span class="line"><span class="comment">     * A non-interface argument must not be declared as final, and must have an</span></span><br><span class="line"><span class="comment">     * accessible constructor.</span></span><br><span class="line"><span class="comment">     * 设置将被扩展的已产生类的类。为方便起见，如果提供的超类是一个借口，setInterfaces将会被调用。</span></span><br><span class="line"><span class="comment">     * 一个非接口参数（类）不能被声明为final，而且必须有可访问的构造器。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> superclass class to extend or interface to implement</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #setInterfaces(Class[])</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSuperclass</span><span class="params">(Class superclass)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (superclass != <span class="keyword">null</span> &amp;&amp; superclass.isInterface()) &#123;</span><br><span class="line">            setInterfaces(<span class="keyword">new</span> Class[]&#123; superclass &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (superclass != <span class="keyword">null</span> &amp;&amp; superclass.equals(Object.class)) &#123;</span><br><span class="line">            <span class="comment">// affects choice of ClassLoader</span></span><br><span class="line">            <span class="keyword">this</span>.superclass = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.superclass = superclass;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>如注释所示：这个方法设置将被扩展的已产生类的类。为方便起见，如果提供的超类是一个接口，setInterfaces将会被调用。一个非接口参数（类）不能被声明为final，而且必须有可访问的构造器。</p>
<p>在来看设置回调的方法setCallback, Callback可以理解成生成的代理类的方法被调用时（比如说调用person.sayHello()时），会执行的逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Set the array of callbacks to use.</span></span><br><span class="line"><span class="comment"> * Ignored if you use &#123;<span class="doctag">@link</span> #createClass&#125;.</span></span><br><span class="line"><span class="comment"> * You must use a &#123;<span class="doctag">@link</span> CallbackFilter&#125; to specify the index into this</span></span><br><span class="line"><span class="comment"> * array for each method in the proxied class.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> callbacks the callback array</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #setCallbackFilter</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #setCallback</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCallbacks</span><span class="params">(Callback[] callbacks)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (callbacks != <span class="keyword">null</span> &amp;&amp; callbacks.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Array cannot be empty&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.callbacks = callbacks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>翻译一下注释，即设置要使用的callbacks数组，必须使用一个CallbackFilter来指定进入数据的索引，为每一个代理类中的方法。</p>
<p>为了验证Filter功能，新建一个filter类，来进行方法的分门别类的过滤。首先，先新建一个拦截器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DaoAnotherProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;call time: &quot;</span> + System.currentTimeMillis());</span><br><span class="line">        <span class="comment">//method.invoke(obj, args);</span></span><br><span class="line">        proxy.invokeSuper(obj, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;end call time: &quot;</span> + System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我使用反射方式来进行调用时，出现了问题，但是不是我这次的重点，暂搁置。然后，创建了一个Callback的过滤器来对callback进行过滤：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodFilter</span> <span class="keyword">implements</span> <span class="title">CallbackFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UPDATE = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SELECT = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">accept</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">        String name = method.getName();</span><br><span class="line">        <span class="keyword">if</span>(name.equals(<span class="string">&quot;update&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> UPDATE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> SELECT;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时，修改enhancer实例，设置过滤器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DaoTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCglib</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DaoProxy daoProxy = <span class="keyword">new</span> DaoProxy();</span><br><span class="line">        DaoAnotherProxy daoAnotherProxy = <span class="keyword">new</span> DaoAnotherProxy();</span><br><span class="line">        MethodFilter methodFilter = <span class="keyword">new</span> MethodFilter();</span><br><span class="line"></span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setSuperclass(Dao.class);</span><br><span class="line">        enhancer.setCallbacks(<span class="keyword">new</span> Callback[]&#123;daoProxy, daoAnotherProxy&#125;);</span><br><span class="line">        enhancer.setCallbackFilter(methodFilter);</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">before method invoke</span><br><span class="line">Object Dao update</span><br><span class="line">After method invoke</span><br><span class="line">call time: 1539921398539</span><br><span class="line">Dao object select</span><br><span class="line">end call time: 1539921398539</span><br></pre></td></tr></table></figure>

<p>如结果所示，通过过滤器，实现了对同一个类中不同方法的不同拦截。</p>
<h2 id="3-cglib功能总结"><a href="#3-cglib功能总结" class="headerlink" title="3.cglib功能总结"></a>3.cglib功能总结</h2><p>因为我目前对Java 动态代理不是很熟悉，所以不好对比两种技术的差别在哪里。从目前的样例分析来看，cglib作为一种代码生成库，其可以通过Enhencer这个类来完成生成 <strong>动态的子类</strong>，以达到方法级别拦截的目的。</p>
<p>这个类是作为标准动态代理（其允许代理继承一个实体基类，也允许实现接口）的替代品从jdk1.3开始支持的。动态生成的子类重写了超类中non-final的方法，同时有钩子回调用户定义的拦截器实现。</p>
<p>其中关于MethodInterceptor回调功能为：</p>
<blockquote>
<p>The original and most general callback type is the {@link MethodInterceptor}, which<br> in AOP terms enables “around advice”–that is, you can invoke custom code both before<br> and after the invocation of the “super” method. In addition you can modify the<br> arguments before calling the super method, or not call it at all.</p>
</blockquote>
<p>同时为了支持同一个代理类中多个回调的功能，提供了CallbackFilter：</p>
<blockquote>
<p>Although <code>MethodInterceptor</code> is generic enough to meet any<br>interception need, it is often overkill. For simplicity and performance, additional<br>specialized callback types, such as {@link LazyLoader} are also available.<br>Often a single callback will be used per enhanced class, but you can control<br>which callback is used on a per-method basis with a {@link CallbackFilter}.</p>
</blockquote>
<p>同时，需要注意一下Enhencer的另外一个特性Factory: </p>
<blockquote>
<p>All enhanced objects implement the {@link Factory} interface, unless {@link #setUseFactory} is<br>used to explicitly disable this feature. The <code>Factory</code> interface provides an API<br>to change the callbacks of an existing object, as well as a faster and easier way to create<br>new instances of the same type.</p>
</blockquote>
<p>上面的意思是，除非显示的关掉这个Factory特性，否则这个借口提供了API去改变存在的对象的回调行为，同时也提供了一种更快，更简单创建实例的方式。</p>
<h2 id="4-总结和思考"><a href="#4-总结和思考" class="headerlink" title="4.总结和思考"></a>4.总结和思考</h2><p>CGLIB是一个强大的高性能的代码生成库。作为JDK动态代理的互补，它对于那些没有实现接口的类提供了代理方案。在底层，它使用ASM字节码操纵框架。本质上来说，CGLIB通过产生子类覆盖非final方法来进行代理。它比使用Java反射的JDK动态代理方法更快。CGLIB不能代理一个final类或者final方法。通常来说，你可以使用JDK动态代理方法来创建代理，对于没有接口的情况或者性能因素，CGLIB是一个很好的选择。</p>
<p>第一个问题：cglib代码生成库在Spring AOP的应用是怎么样的？分别应用在哪些点，以及其实如何完成这个过程的。</p>
<h2 id="5-参考文档"><a href="#5-参考文档" class="headerlink" title="5.参考文档"></a>5.参考文档</h2><ol>
<li>cglib source code;</li>
<li><a target="_blank" rel="noopener" href="http://ifeve.com/cglib-desc/">CGLIB动态代理介绍</a></li>
<li><a target="_blank" rel="noopener" href="https://dzone.com/articles/cglib-missing-manual">CGLib: The Missing Manual</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2019/05/08/2018-11-19-Spring-AOP-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Robinson">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Road To Excelsior">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/05/08/2018-11-19-Spring-AOP-2/" class="post-title-link" itemprop="url">Spring AOP(2) - 实例化</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-05-08 15:53:10" itemprop="dateCreated datePublished" datetime="2019-05-08T15:53:10+08:00">2019-05-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-12-18 00:44:41" itemprop="dateModified" datetime="2020-12-18T00:44:41+08:00">2020-12-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><p>承接一，在完成了对aop标签的bean的初始化之后，AbstractApplicationContext通过refresh()方法来中的finishBeanFactoryInitialization 来完成对beanFactory中的aop相关的RootBeanDefinition的实例化，其通过为不同的bean生成不同类型的代理（主要是JdkDynamicAopProxy或者ObjenesisCglibAopProxy代理)实现面向切面编程的目的。</p>
<h2 id="1-代理对象实例化"><a href="#1-代理对象实例化" class="headerlink" title="1. 代理对象实例化"></a>1. 代理对象实例化</h2><p>下图显示了通过断点调试的方法打印出了aop 代理对象实例化的过程：</p>
<p>![](/assets/posts/Spring aop instance/aop-instance.png)</p>
<p>通过分析如下，其主要包含了如下几个步骤：</p>
<ol>
<li>判断是否需要为bean生成代理；</li>
<li>创建AopProxy代理接口实现类；</li>
<li>通过接口实现类的getProxy方法来获取<bean>对应的代理；</li>
</ol>
<h3 id="1-1-判断是否为bean生成代理"><a href="#1-1-判断是否为bean生成代理" class="headerlink" title="1.1 判断是否为bean生成代理"></a>1.1 判断是否为bean生成代理</h3><p>在AbstractAutoProxyCreator中，wrapIfNecessary方法显示了什么时候为bean生成代理包装的过程，其主要通过拿到bean对应的Advisor数组，只要Advisor数组不为空，那么就会通过第17行的代码为<bean>创建代理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Wrap the given bean if necessary, i.e. if it is eligible for being proxied.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bean the raw bean instance</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanName the name of the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> cacheKey the cache key for metadata access</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a proxy wrapping the bean, or the raw bean instance as-is</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">wrapIfNecessary</span><span class="params">(Object bean, String beanName, Object cacheKey)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (StringUtils.hasLength(beanName) &amp;&amp; <span class="keyword">this</span>.targetSourcedBeans.contains(beanName)) &#123;</span><br><span class="line">		<span class="keyword">return</span> bean;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (Boolean.FALSE.equals(<span class="keyword">this</span>.advisedBeans.get(cacheKey))) &#123;</span><br><span class="line">		<span class="keyword">return</span> bean;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) &#123;</span><br><span class="line">		<span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">		<span class="keyword">return</span> bean;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Create proxy if we have advice.</span></span><br><span class="line">	Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, <span class="keyword">null</span>);</span><br><span class="line">	<span class="keyword">if</span> (specificInterceptors != DO_NOT_PROXY) &#123;</span><br><span class="line">		<span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.TRUE);</span><br><span class="line">		Object proxy = createProxy(</span><br><span class="line">				bean.getClass(), beanName, specificInterceptors, <span class="keyword">new</span> SingletonTargetSource(bean));</span><br><span class="line">		<span class="keyword">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line">		<span class="keyword">return</span> proxy;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">	<span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里面的AbstractAutoProxyCreator是如何引用在实例化bean中的呢？？在前面的ioc博客中显示，AbstractAutowireCapableBeanFactory作为功能最强大的bean factory，其在实例化bean的过程(initializeBean)中，调用了applyBeanPostProcessorsAfterInitialization()方法，在bean初始化之后进行了后处理。在这个方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">applyBeanPostProcessorsAfterInitialization</span><span class="params">(Object existingBean, String beanName)</span></span></span><br><span class="line"><span class="function">		<span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">	Object result = existingBean;</span><br><span class="line">	<span class="keyword">for</span> (BeanPostProcessor beanProcessor : getBeanPostProcessors()) &#123;</span><br><span class="line">		Object current = beanProcessor.postProcessAfterInitialization(result, beanName);</span><br><span class="line">		<span class="keyword">if</span> (current == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> result;</span><br><span class="line">		&#125;</span><br><span class="line">		result = current;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其调用了父虚拟类的getBeanPostProcessors的方法获得了BeanPostProcessor来完成了对bean的处理，这里AbstractAutoProxyCreator是BeanPostProcessor的一个实现(虚)类。也就是说，在bean factory中已经存在对应的BeanPostProcessor实例来完成对符合条件的bean进行代理对象的创建的。</p>
<p>其中关于AbstractAutoProxyCreator的类层次架构如下：<br>![](/assets/posts/Spring aop instance/AbstractAutoProxyCreator.png)</p>
<h3 id="1-2-创建AopProxy代理接口实现类"><a href="#1-2-创建AopProxy代理接口实现类" class="headerlink" title="1.2 创建AopProxy代理接口实现类"></a>1.2 创建AopProxy代理接口实现类</h3><p>在AbstractAutoProxyCreator中,createProxy方法用来为给定的bean创建AOP代理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create an AOP proxy for the given bean.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanClass the class of the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanName the name of the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> specificInterceptors the set of interceptors that is</span></span><br><span class="line"><span class="comment"> * specific to this bean (may be empty, but not null)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> targetSource the TargetSource for the proxy,</span></span><br><span class="line"><span class="comment"> * already pre-configured to access the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the AOP proxy for the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #buildAdvisors</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createProxy</span><span class="params">(Class&lt;?&gt; beanClass, <span class="meta">@Nullable</span> String beanName,</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="meta">@Nullable</span> Object[] specificInterceptors, TargetSource targetSource)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.beanFactory <span class="keyword">instanceof</span> ConfigurableListableBeanFactory) &#123;</span><br><span class="line">		AutoProxyUtils.exposeTargetClass((ConfigurableListableBeanFactory) <span class="keyword">this</span>.beanFactory, beanName, beanClass);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ProxyFactory proxyFactory = <span class="keyword">new</span> ProxyFactory();</span><br><span class="line">	proxyFactory.copyFrom(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!proxyFactory.isProxyTargetClass()) &#123;</span><br><span class="line">		<span class="keyword">if</span> (shouldProxyTargetClass(beanClass, beanName)) &#123;</span><br><span class="line">			proxyFactory.setProxyTargetClass(<span class="keyword">true</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			evaluateProxyInterfaces(beanClass, proxyFactory);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Advisor[] advisors = buildAdvisors(beanName, specificInterceptors);</span><br><span class="line">	proxyFactory.addAdvisors(advisors);</span><br><span class="line">	proxyFactory.setTargetSource(targetSource);</span><br><span class="line">	customizeProxyFactory(proxyFactory);</span><br><span class="line"></span><br><span class="line">	proxyFactory.setFrozen(<span class="keyword">this</span>.freezeProxy);</span><br><span class="line">	<span class="keyword">if</span> (advisorsPreFiltered()) &#123;</span><br><span class="line">		proxyFactory.setPreFiltered(<span class="keyword">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> proxyFactory.getProxy(getProxyClassLoader());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进入最后一行的工厂方法中，proxyFactory.getProxy()的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create a new proxy according to the settings in this factory.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Can be called repeatedly. Effect will vary if we&#x27;ve added</span></span><br><span class="line"><span class="comment"> * or removed interfaces. Can add and remove interceptors.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Uses the given class loader (if necessary for proxy creation).</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> classLoader the class loader to create the proxy with</span></span><br><span class="line"><span class="comment"> * (or &#123;<span class="doctag">@code</span> null&#125; for the low-level proxy facility&#x27;s default)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the proxy object</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(<span class="meta">@Nullable</span> ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> createAopProxy().getProxy(classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见，这个方法根据这个工厂的设定来创建一个新的代理。先看看，这个工厂类的继承层次：<br>![](/assets/posts/Spring aop instance/ProxyFactory.png)</p>
<p>进入方法可见，其调用ProxyCreatorSupport的方法来获取指定的AopProxy代理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Subclasses should call this to get a new AOP proxy. They should &lt;b&gt;not&lt;/b&gt;</span></span><br><span class="line"><span class="comment"> * create an AOP proxy with &#123;<span class="doctag">@code</span> this&#125; as an argument.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> AopProxy <span class="title">createAopProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!<span class="keyword">this</span>.active) &#123;</span><br><span class="line">		activate();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> getAopProxyFactory().createAopProxy(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>hold on。那么问题来了，哪里获取指定的proxy实例呢，答案在getAopProxyFactory方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> AopProxyFactory aopProxyFactory;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the AopProxyFactory that this ProxyConfig uses.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AopProxyFactory <span class="title">getAopProxyFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.aopProxyFactory;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>即，其通过AopProxyFactory的工厂实现类完成了对不同类型的bean选择不同的proxy的过程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultAopProxyFactory</span> <span class="keyword">implements</span> <span class="title">AopProxyFactory</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> AopProxy <span class="title">createAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class="line">			Class&lt;?&gt; targetClass = config.getTargetClass();</span><br><span class="line">			<span class="keyword">if</span> (targetClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">&quot;TargetSource cannot determine target class: &quot;</span> +</span><br><span class="line">						<span class="string">&quot;Either an interface or a target is required for proxy creation.&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> ObjenesisCglibAopProxy(config);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Determine whether the supplied &#123;<span class="doctag">@link</span> AdvisedSupport&#125; has only the</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@link</span> org.springframework.aop.SpringProxy&#125; interface specified</span></span><br><span class="line"><span class="comment">	 * (or no proxy interfaces specified at all).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">hasNoUserSuppliedProxyInterfaces</span><span class="params">(AdvisedSupport config)</span> </span>&#123;</span><br><span class="line">		Class&lt;?&gt;[] ifcs = config.getProxiedInterfaces();</span><br><span class="line">		<span class="keyword">return</span> (ifcs.length == <span class="number">0</span> || (ifcs.length == <span class="number">1</span> &amp;&amp; SpringProxy.class.isAssignableFrom(ifcs[<span class="number">0</span>])));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>平时我们说AOP原理三句话就能概括：</p>
<ol>
<li>对类生成代理使用CGLIB</li>
<li>对接口生成代理使用JDK原生的Proxy</li>
<li>可以通过配置文件指定对接口使用CGLIB生成代理</li>
</ol>
<p>其中，关于CGLIB的介绍，可见参考文档一，关于JDK PROXY可见参考文档二。</p>
<h3 id="1-3-通过getProxy方法来获取对应的代理"><a href="#1-3-通过getProxy方法来获取对应的代理" class="headerlink" title="1.3 通过getProxy方法来获取对应的代理"></a>1.3 通过getProxy方法来获取<bean>对应的代理</h3><p>关于AopProxy接口的定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.aop.framework;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.lang.Nullable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Delegate interface for a configured AOP proxy, allowing for the creation</span></span><br><span class="line"><span class="comment"> * of actual proxy objects.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Out-of-the-box implementations are available for JDK dynamic proxies</span></span><br><span class="line"><span class="comment"> * and for CGLIB proxies, as applied by &#123;<span class="doctag">@link</span> DefaultAopProxyFactory&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Rod Johnson</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Juergen Hoeller</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> DefaultAopProxyFactory</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AopProxy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Create a new proxy object.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Uses the AopProxy&#x27;s default class loader (if necessary for proxy creation):</span></span><br><span class="line"><span class="comment">	 * usually, the thread context class loader.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> the new proxy object (never &#123;<span class="doctag">@code</span> null&#125;)</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> Thread#getContextClassLoader()</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function">Object <span class="title">getProxy</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Create a new proxy object.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Uses the given class loader (if necessary for proxy creation).</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@code</span> null&#125; will simply be passed down and thus lead to the low-level</span></span><br><span class="line"><span class="comment">	 * proxy facility&#x27;s default, which is usually different from the default chosen</span></span><br><span class="line"><span class="comment">	 * by the AopProxy implementation&#x27;s &#123;<span class="doctag">@link</span> #getProxy()&#125; method.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> classLoader the class loader to create the proxy with</span></span><br><span class="line"><span class="comment">	 * (or &#123;<span class="doctag">@code</span> null&#125; for the low-level proxy facility&#x27;s default)</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> the new proxy object (never &#123;<span class="doctag">@code</span> null&#125;)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function">Object <span class="title">getProxy</span><span class="params">(<span class="meta">@Nullable</span> ClassLoader classLoader)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在我们的样例中，采用的是CglibAopProxy来获取代理，关于Cglib的相关介绍，可见参考文档一。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(<span class="meta">@Nullable</span> ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">		logger.debug(<span class="string">&quot;Creating CGLIB proxy: target source is &quot;</span> + <span class="keyword">this</span>.advised.getTargetSource());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		Class&lt;?&gt; rootClass = <span class="keyword">this</span>.advised.getTargetClass();</span><br><span class="line">		Assert.state(rootClass != <span class="keyword">null</span>, <span class="string">&quot;Target class must be available for creating a CGLIB proxy&quot;</span>);</span><br><span class="line"></span><br><span class="line">		Class&lt;?&gt; proxySuperClass = rootClass;</span><br><span class="line">		<span class="keyword">if</span> (ClassUtils.isCglibProxyClass(rootClass)) &#123;</span><br><span class="line">			proxySuperClass = rootClass.getSuperclass();</span><br><span class="line">			Class&lt;?&gt;[] additionalInterfaces = rootClass.getInterfaces();</span><br><span class="line">			<span class="keyword">for</span> (Class&lt;?&gt; additionalInterface : additionalInterfaces) &#123;</span><br><span class="line">				<span class="keyword">this</span>.advised.addInterface(additionalInterface);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Validate the class, writing log messages as necessary.</span></span><br><span class="line">		validateClassIfNecessary(proxySuperClass, classLoader);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Configure CGLIB Enhancer...</span></span><br><span class="line">		Enhancer enhancer = createEnhancer();</span><br><span class="line">		<span class="keyword">if</span> (classLoader != <span class="keyword">null</span>) &#123;</span><br><span class="line">			enhancer.setClassLoader(classLoader);</span><br><span class="line">			<span class="keyword">if</span> (classLoader <span class="keyword">instanceof</span> SmartClassLoader &amp;&amp;</span><br><span class="line">					((SmartClassLoader) classLoader).isClassReloadable(proxySuperClass)) &#123;</span><br><span class="line">				enhancer.setUseCache(<span class="keyword">false</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		enhancer.setSuperclass(proxySuperClass);</span><br><span class="line">		enhancer.setInterfaces(AopProxyUtils.completeProxiedInterfaces(<span class="keyword">this</span>.advised));</span><br><span class="line">		enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);</span><br><span class="line">		enhancer.setStrategy(<span class="keyword">new</span> ClassLoaderAwareUndeclaredThrowableStrategy(classLoader));</span><br><span class="line"></span><br><span class="line">		Callback[] callbacks = getCallbacks(rootClass);</span><br><span class="line">		Class&lt;?&gt;[] types = <span class="keyword">new</span> Class&lt;?&gt;[callbacks.length];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; types.length; x++) &#123;</span><br><span class="line">			types[x] = callbacks[x].getClass();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// fixedInterceptorMap only populated at this point, after getCallbacks call above</span></span><br><span class="line">		enhancer.setCallbackFilter(<span class="keyword">new</span> ProxyCallbackFilter(</span><br><span class="line">				<span class="keyword">this</span>.advised.getConfigurationOnlyCopy(), <span class="keyword">this</span>.fixedInterceptorMap, <span class="keyword">this</span>.fixedInterceptorOffset));</span><br><span class="line">		enhancer.setCallbackTypes(types);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Generate the proxy class and create a proxy instance.</span></span><br><span class="line">		<span class="keyword">return</span> createProxyClassAndInstance(enhancer, callbacks);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (CodeGenerationException | IllegalArgumentException ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">&quot;Could not generate CGLIB subclass of &quot;</span> + <span class="keyword">this</span>.advised.getTargetClass() +</span><br><span class="line">				<span class="string">&quot;: Common causes of this problem include using a final class or a non-visible class&quot;</span>,</span><br><span class="line">				ex);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">		<span class="comment">// TargetSource.getTarget() failed</span></span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">&quot;Unexpected AOP exception&quot;</span>, ex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码时CglibAopProxy的getProxy()方法，在这里面，通过设置合适的enhancer，以及callbacks，然后调用create方法来创建代理对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createProxyClassAndInstance</span><span class="params">(Enhancer enhancer, Callback[] callbacks)</span> </span>&#123;</span><br><span class="line">	enhancer.setInterceptDuringConstruction(<span class="keyword">false</span>);</span><br><span class="line">	enhancer.setCallbacks(callbacks);</span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">this</span>.constructorArgs != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.constructorArgTypes != <span class="keyword">null</span> ?</span><br><span class="line">			enhancer.create(<span class="keyword">this</span>.constructorArgTypes, <span class="keyword">this</span>.constructorArgs) :</span><br><span class="line">			enhancer.create());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结和思考"><a href="#总结和思考" class="headerlink" title="总结和思考"></a>总结和思考</h2><p>通过阅读spring aop的代码，可以发现，spring aop实现，主要是通过将 &lt;aop: advisor&gt; 标签来解析成 RootBeanDefinition 来完成对aop 代理对象的定义，然后在通过两种不同的代理生成方法，cglib以及jdk proxy的方法来完成对代理对象的生成。</p>
<p>那么，RootBeanDefinition的定义是如何的呢？他是如何表示不同的切点，通知等这些aop的概念的呢？这个问题值得深入探讨一下。</p>
<p>另外，cglib 以及 jdk proxy 是如何对RootBeanDefinition就行解析来完成代理对象的构建的呢？</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ol>
<li><a target="_blank" rel="noopener" href="https://ustccat.github.io/2018/10/18/CGLib.html">cglib</a></li>
<li><a target="_blank" rel="noopener" href="https://ustccat.github.io/2018/10/27/Java-Proxy.html">JDK Dynamic Proxy</a></li>
<li><a target="_blank" rel="noopener" href="http://www.importnew.com/24459.html">Spring源码分析：AOP源码解析（下篇）</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2019/05/08/2018-11-20-books-and-tasks/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Robinson">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Road To Excelsior">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/05/08/2018-11-20-books-and-tasks/" class="post-title-link" itemprop="url">books and tasks in 2018</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-05-08 15:53:10" itemprop="dateCreated datePublished" datetime="2019-05-08T15:53:10+08:00">2019-05-08</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><h2 id="1-what-do-i-want-to-do-mostly"><a href="#1-what-do-i-want-to-do-mostly" class="headerlink" title="1. what do i want to do mostly"></a>1. what do i want to do mostly</h2><ol>
<li>to become an open minded and active person full of energy</li>
<li>to help my family to premote their business</li>
<li>to read, to think, to communicate, to work</li>
<li>to become a full stack engineer</li>
<li>to save money and increase the incomes</li>
</ol>
<h2 id="2-steps-to-achieve-all-of-these-fastly-and-solidly"><a href="#2-steps-to-achieve-all-of-these-fastly-and-solidly" class="headerlink" title="2. steps to achieve all of these fastly and solidly"></a>2. steps to achieve all of these fastly and solidly</h2><p>First, to become an open minded and active person full of energy, i need to do following things:</p>
<ol>
<li>execise, 每周至少保证有两天，两到三个小时的运动量，注意在运动时要科学，高效，不要讲时间和精力浪费在没有意义的动作上。</li>
<li>sleep，每天至少保证七个小时的睡眠，注意睡眠时的质量，睡前不要做影响睡眠的事情，注意保暖，卫生和整洁。</li>
<li>hygiene，注意自己衣物，床上用品，房间的整洁，每周不定时的打扫，清理。</li>
<li>food，注意荤素搭配，营养均衡，吃健康的事物，但不拒绝垃圾食品</li>
</ol>
<p>Second, to help my family to premote their business, i need to do following things:</p>
<ol>
<li>communicate with them, to understand their small business, to think how to use my ability to help them.</li>
<li>to iterate fast to show their solutions and revise frequently.</li>
</ol>
<p>Third, to read, to think, to communicate, to work, i need to do following things:</p>
<ol>
<li>books</li>
<li>1 技术类书籍</li>
<li>2 经济学书籍</li>
<li>3 心理学书籍</li>
<li>talk with many person, understand their thoughts, to think what i can to help them.</li>
</ol>
<h2 id="3-书单-实时更新，截止到目前"><a href="#3-书单-实时更新，截止到目前" class="headerlink" title="3 书单(实时更新，截止到目前)"></a>3 书单(实时更新，截止到目前)</h2><h3 id="3-1-技术类书籍-今年读的书籍"><a href="#3-1-技术类书籍-今年读的书籍" class="headerlink" title="3.1.技术类书籍(今年读的书籍)"></a>3.1.技术类书籍(今年读的书籍)</h3><ol>
<li>《web api的设计与开发》 评分：8 状态：在读 后续：读完</li>
<li>《图解http》 评分：6 状态：已读 后续：可再读</li>
<li>《DDD领域驱动设计精简版》 评分：5 状态：已读 后续：放弃</li>
<li>《JavaScript 权威指南(第六版)》 评分：8 状态：在读 后续：阅读最新版</li>
<li>《CSS 权威指南(第三版)》 评分：7 状态：已读完 后续：可再读</li>
<li>《Vue.js 实战》 评分：5 状态：放弃 后续：</li>
<li>《JavaScript DOM编程艺术(第二版)》 评分：8 状态：已读 后续：可再读</li>
<li>《领域驱动设计 软件核心复杂性应对之道》 评分：9 状态：已读第二遍 后续：可补充查阅阅读</li>
<li>《实现领域驱动设计》评分：9 状态：已读 后续：可择机再读</li>
</ol>
<h3 id="3-2-心理学书籍"><a href="#3-2-心理学书籍" class="headerlink" title="3.2.心理学书籍"></a>3.2.心理学书籍</h3><h3 id="3-3-经济学书籍"><a href="#3-3-经济学书籍" class="headerlink" title="3.3.经济学书籍"></a>3.3.经济学书籍</h3><ol>
<li>《经济学原理第五版(微观分册)》评分：8 状态：已读 后续：可再读</li>
<li>《经济学原理第五版(宏观分册)》评分：8 状态：已读 后续：可再读</li>
<li>《就业，利息和货币通论》评分： 状态： 后续：</li>
</ol>
<h3 id="3-4-好的博客文章"><a href="#3-4-好的博客文章" class="headerlink" title="3.4.好的博客文章"></a>3.4.好的博客文章</h3><ol>
<li><a target="_blank" rel="noopener" href="http://www.codeceo.com/article/habits-to-be-better-programmer.html">让你变成优秀程序员的几个小习惯</a></li>
</ol>
<h2 id="3-总结和思考"><a href="#3-总结和思考" class="headerlink" title="3. 总结和思考"></a>3. 总结和思考</h2><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2019/05/08/2018-12-07-How-To-Read-Code/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Robinson">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Road To Excelsior">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/05/08/2018-12-07-How-To-Read-Code/" class="post-title-link" itemprop="url">How To Read Code</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-05-08 15:53:10" itemprop="dateCreated datePublished" datetime="2019-05-08T15:53:10+08:00">2019-05-08</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><p>私以为写代码的最终目的都是为了更快更好的做出为用户服务的好产品，为了能够达到这个目的，就需要阅读前辈写出的好的代码，这样的过程主要有两个目的：1.阅读一些经典的框架代码能够让自己更加清楚的了解框架的作用，明白它的限制范围，同时在出现bug时知道问题具体出现哪里；2.阅读经典的代码可以让自己了解好的代码结构是怎么样的，以便培养出优秀的代码风格和代码框架设计。</p>
<p>那么怎样阅读这些huge, unstructured, maintained-by-dozens-of-people, internally-inconsistent, undocumented的代码呢？</p>
<h2 id="1-Build-and-Run-the-Program"><a href="#1-Build-and-Run-the-Program" class="headerlink" title="1. Build and Run the Program"></a>1. Build and Run the Program</h2><p>能够运行这个程序并且观察它的外部行为，在研究程序内在时是非常有用的。程序的文档同时也很有用，但是文档可能因为一些历史原因而不能保证足够的准确。</p>
<p>能够自行编译程序可以帮助你弄清楚哪些外部库是被调用的，哪个编译器以及链接器是有用的……等。并且，如果可以编译一个debug版本的程序，就可以进行单步调试。<a href="">Study the source with Debugger</a>。</p>
<p>同时，也可以添加或者扩展程序的日志，让它告诉你程序是怎么做的。</p>
<h2 id="2-Find-the-High-Level-Logic"><a href="#2-Find-the-High-Level-Logic" class="headerlink" title="2. Find the High-Level Logic"></a>2. Find the High-Level Logic</h2><p>找到程序的入口，观察程序是如何初始化，运行，并且终结停止的。</p>
<p>大多数的程序会有一个main loop，这一点很重要。（但是如果程序使用了外部框架，那么主循环可能在框架里，而不是在应用程序里）。</p>
<p>发现程序终止的条件。这个包括正常的exits，以及非正常的退出。</p>
<p><em>很多事件驱动，以及面向对象的设计没有”main”入口</em>。</p>
<h2 id="3-Draw-Some-Flowcharts"><a href="#3-Draw-Some-Flowcharts" class="headerlink" title="3. Draw Some Flowcharts"></a>3. Draw Some Flowcharts</h2><p>我们都知道流程图是一种糟糕的设计工具，但是他们被用在分析程序流时却十分有用；你不可能将所有的信息保存在脑袋里，所以，在阅读时，画出一些流程图或者状态图是非常有必要的。需要注意的是，注意关注所有的分支情况。</p>
<h2 id="4-Examine-Library-Calls"><a href="#4-Examine-Library-Calls" class="headerlink" title="4. Examine Library Calls"></a>4. Examine Library Calls</h2><p>如果程序使用了外部的库，检查外部的库调用，并且阅读关于这些调用的文档。（这可能是唯一可用的文档了，所以利用好它）。</p>
<h2 id="5-Search-for-Key-Words"><a href="#5-Search-for-Key-Words" class="headerlink" title="5. Search for Key Words"></a>5. Search for Key Words</h2><p>使用编辑器的查找特性来查找所有关联的关键字。</p>
<h2 id="6-Leverage-the-Power-of-Code-Comprehension-Tools"><a href="#6-Leverage-the-Power-of-Code-Comprehension-Tools" class="headerlink" title="6. Leverage the Power of Code Comprehension Tools"></a>6. Leverage the Power of Code Comprehension Tools</h2><p>一些很棒的技术可以被用来做搜索工具，更好的可以用来分析源代码，以及查找引用，生成流程图。这些东西可以被用来回答以下的问题，对于面向对象的代码：</p>
<ol>
<li>谁调用了这个方法？</li>
<li>谁实现了接口，或者这个类的子类？</li>
<li>哪个是这个类的父类？</li>
<li>在哪里这些类被创建，保存，作为参数或者返回来传递？</li>
<li>这个类覆盖了超类的哪些方法？</li>
<li>在哪里这个类的方法可能被多态调用，比如说，通过一个基类或者接口？</li>
</ol>
<p>这里有一个参考文档：<br>“Comprehension and Visualisation of Object-Oriented Code for Inspections” <a target="_blank" rel="noopener" href="http://www.cis.strath.ac.uk/research/efocs/abstracts.html#EFoCS-33-98">http://www.cis.strath.ac.uk/research/efocs/abstracts.html#EFoCS-33-98</a><br>第五节</p>
<h2 id="7-Print-the-code"><a href="#7-Print-the-code" class="headerlink" title="7. Print the code"></a>7. Print the code</h2><p>可以通过物理标记代码的方法，来加快对代码的理解。对关键的代码画上圈圈，或者重点标注重要的变量。</p>
<h2 id="8-Write-UnitTests"><a href="#8-Write-UnitTests" class="headerlink" title="8. Write UnitTests"></a>8. Write UnitTests</h2><p>通过编写测试<a target="_blank" rel="noopener" href="http://wiki.c2.com/?UnitTest">Unit Test</a>，可以验证你的想法，保证代码按照你的想法来运行，获得正确的答案。<br>如果没有足够的单元测试，那么你肯定需要在修改源代码时，编写足够的单元测试。</p>
<h2 id="9-Comment-the-Code"><a href="#9-Comment-the-Code" class="headerlink" title="9. Comment the Code"></a>9. Comment the Code</h2><p>将代码拷贝进一个个人的CVS或者RCS库中，并且根据你自己的理解来进行标注。当你理解了部分的代码，标记就会改变。这个步骤在你进行重构代码时是一个重要的过程。</p>
<p>对你非常不熟悉代码进行反向工程时一个最好的方式就是通过仔细检查得到 <a target="_blank" rel="noopener" href="http://wiki.c2.com/?HoareTriple">HoareTriples</a>，并且计算出一个流程的最弱的前置条件。了解过程的不变量通常会为其预期目的提供有价值的线索，从而让您从代码中获得理解，往往这些过程不能通过命名不佳的变量来猜测。</p>
<h2 id="10-Clean-Up-the-Code"><a href="#10-Clean-Up-the-Code" class="headerlink" title="10. Clean Up the Code"></a>10. Clean Up the Code</h2><p>一个旧的写作技巧，用于重新熟悉你很久以前写过但忘记了或者用于分析别人的文本的文本，就是随着你的进行编辑它。这就是主动阅读。通过以一种不同的方式或者更愉悦的方式来重写。您可能已经注意到Wiki在重构或重新编辑页面时，您会比阅读它更深入地理解这些材料。代码与写作没有太大区别。</p>
<p>因此，在阅读代码时，请在进行时重新格式化，重新调整空格模板，标注代码。修复拼写，保证代码和编码规范一致。 通常代码是稍微匆忙写的，所以让其他人稍后来使代码看起来更加专业也是另外一个好处。</p>
<p>但是，如果您进行了很多更改，请运行单元测试UnitTests。打破事情不一定是害怕的事情。通过找到系统的较为脆弱的部分和系统的相关依赖部分（通常是你没注意到的），你就可以了解系统。</p>
<p>一篇关于这项技术的文章是”Make bad code good”，在&lt;JavaWorld <a target="_blank" rel="noopener" href="http://www.javaworld.com/javaworld/jw-03-2001/jw-0323-badcode.html&gt;%E3%80%82">http://www.javaworld.com/javaworld/jw-03-2001/jw-0323-badcode.html&gt;。</a></p>
<h2 id="11-总结和思考"><a href="#11-总结和思考" class="headerlink" title="11. 总结和思考"></a>11. 总结和思考</h2><p>这篇文档觉得很有用，所以就翻译了。其主要的宗旨就是一些小技巧和工具来加速和简化大型工程代码的理解和分析过程。上面大多数的技巧我以前也使用过，但是没有形成系统化的思维，所以这次的总结正好弥补了我在总结这方面技巧的短板。同时，关于其对前置条件(路径)的解释，这个是我以前没有关注过的，觉得是一个不错的技巧，无论多么复杂的代码，最终的目的都是通过一个依次有序的步骤来解决一个问题。所以对于前置条件的分析可以很好的找到代码逻辑中的关键路径。也可以很好的描绘出流程图。</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ol>
<li><a target="_blank" rel="noopener" href="http://wiki.c2.com/?TipsForReadingCode">Tips For Reading Code</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2019/05/08/2019-04-09-Isolation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Robinson">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Road To Excelsior">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/05/08/2019-04-09-Isolation/" class="post-title-link" itemprop="url">数据库中的隔离</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-05-08 15:53:10" itemprop="dateCreated datePublished" datetime="2019-05-08T15:53:10+08:00">2019-05-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-12-18 00:45:26" itemprop="dateModified" datetime="2020-12-18T00:45:26+08:00">2020-12-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><p>在数据库系统中，隔离性表示了事务的完整性对用户和其他系统的可见程度。举个例子，比如说一个用户创建了一个订单，并且已经创建了抬头，但是没有创建订单详情列表，那么这个抬头信息对于其他系统/用户(包含是一个并发操作，像是订单报告)是可见的呢？</p>
<p>一个低级别的隔离增加了更多用户同时对数据的可见性，但是也增加了一些用户可能碰到的并发问题（例如脏读，或者更新丢失的问题）。相反，较高的隔离级别会减少用户可能遇到的并发问题，但需要更多系统资源并增加一个事务阻止另一个事务的可能性。</p>
<p>隔离通常在数据库级别定义为一个属性，用于定义一个操作所做的更改如何/何时对其他操作可见。在较旧的系统上，它可以系统地实现，例如通过使用临时表。在双层系统中，需要事务处理（TP）管理器来维护隔离。在n层系统中（例如多个网站试图预订航班上的最后一个座位），需要结合存储过程和交易管理来提交预订并向客户发送确认。</p>
<p>隔离是ACID（原子性，一致性，隔离性，耐久性）属性之一。</p>
<h2 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h2><p>并发控制包括DBMS中的底层机制，它处理隔离并保证相关的正确性。数据库和存储引擎（见上文）大量使用它来保证并发事务的正确执行，以及（不同的机制）其他DBMS进程的正确性。与事务相关的机制通常将数据库数据访问操作的时间（事务调度）约束为特定的时序模型，这些时序模型通常包含可序列化，和可恢复的特性。约束数据库访问操作执行通常意味着降低的性能（执行速率），因此并发控制机制通常被设计为在约束下提供可能的最佳性能。通常，在不影响正确性的情况下，可序列化属性因为更好的性能需求通常会被破坏，但是，可恢复属性则不会被破坏，因为这个可能会导致数据库完整性被破坏。</p>
<p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Two-phase_locking">两阶段锁定(two-phase locking)</a>是DBMS中最常用的事务并发控制方法，用于提供可序列化和可恢复性的正确性。为了访问数据库对象，事务首先需要获取该对象的锁。根据访问操作类型（例如，读取或写入对象）和锁定类型，如果另一个事务正在为该对象保持锁定，则可以阻止和推迟获取锁定。</p>
<h2 id="读现象"><a href="#读现象" class="headerlink" title="读现象"></a>读现象</h2><p>当事务1读取事务2可能已更改的数据时，ANSI / ISO标准SQL 92引用三种不同的读取现象。</p>
<p>在以下示例中，发生了两个事务。 在第一个中，执行查询1。 然后，在第二个事务中，执行并提交查询2。 最后，在第一个事务中，再次执行查询1。</p>
<p>查询使用了下面的数据库表user：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>age</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>Joe</td>
<td>20</td>
</tr>
<tr>
<td>2</td>
<td>Jill</td>
<td>25</td>
</tr>
</tbody></table>
<h3 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h3><p>当允许事务从已被另一个正在运行的事务修改但尚未提交的行读取数据时，会发生脏读（也称为未提交的依赖关系）。</p>
<p>脏读取与非可重复读取的工作方式类似; 但是，第二个事务不需要为第一个查询提交以返回不同的结果。在我们的示例中，事务2更改了一行，但未提交更改。 然后，事务1读取未提交的数据。 现在，如果事务2回滚其更改（已由事务1读取）或更新对数据库的不同更改，则事务1的记录中的数据视图可能是错误的。</p>
<p><img src="/assets/posts/Isolation/dirty-read.png">{:width=”600px” height=”400px”}</p>
<h3 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h3><p>发生不可重复的读取，当在事务过程中，行被检索两次并且行内的值在读取之间不同。</p>
<p>当执行SELECT时未获取读锁定时，或者在执行SELECT操作时 <strong>释放</strong> 受影响行上获取的锁定时，基于锁的并发控制方法中可能会发生不可重复读取现象。 在<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Multiversion_concurrency_control">多版本并发控制</a>方法下，当受到提交冲突影响的事务必须回滚的要求被放宽时，可能发生不可重复的读取。</p>
<p><img src="/assets/posts/Isolation/non-repeatable-read.png">{:width=”600px” height=”400px”}</p>
<p>在此示例中，事务2成功提交，这意味着它对id为1的行的更改应该变为可见。 但是，事务1已经在该行中看到了不同的年龄值。 在SERIALIZABLE和REPEATABLE READ隔离级别，DBMS对于第二个SELECT必须返回旧值。在READ COMMITTED和READ UNCOMMITTED，DBMS可以返回更新的值; 这是一个不可重复读的操作。</p>
<p>有两种基本策略用于防止不可重复的读取。 第一种是延迟事务2的执行，直到事务1已提交或回滚。 当使用锁时采用此方法，并生成串行调度T1，T2。 一个串行的计划表现出可重复的读取行为。</p>
<p>另外一种策略，在多版本并发控制中使用，T2允许被首先提交，这可以产生更好的并发性能。但是，T1，它开始早于T2，必须继续在数据库的过去版本上运行 - 这是它启动时的快照。当事务1最终尝试提交时，DBMS检查提交事务1的结果是否等于调度T1，T2。 如果是，则可以继续进行事务1。 但是，如果看不到它是等效的，则事务1必须以序列化失败的形式回滚。</p>
<p>在基于锁得并发控制方法中，在可重复读的隔离级别模式下，id = 1的行会被锁住，因此阻塞住查询Query 2直到第一个事务被提交或者回滚。在READ COMMITTED模式下，第二次Query 1被执行时，age字段就会被改变。</p>
<p>在基于多版本的并发控制方法中，在SERIALIZABLE隔离级别中，两个select 查询都会看到事务1开始时得数据库快照版本数据。因此，他们会返回相同的数据。但是，如果事务1也准备update这一行的话，一个序列化失败会出现，并且事务1将会强制回滚。</p>
<p>在READ COMMITTED 隔离级别，每个查询都会看到query开始时得一个快照版本。因此，它们对于更新的行都会看到不同的数据。在这种模式下，不会出现序列化失败错误，因为没有可序列化得承诺，并且不必重试事务1。</p>
<h3 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h3><p>当在事务过程中，新行被另一个事务添加或删除到正在读取的记录时，会发生幻像读取。</p>
<p>在执行SELECT … WHERE操作时未获取范围锁定时，可能会发生这种情况。当事务1重复一个范围的SELECT … WHERE查询时，并且，在两个操作之间，事务2创建（即INSERT）满足该WHERE子句的新行（在目标表中）,幻象读取是一非可重复读的一个特例。</p>
<p><img src="/assets/posts/Isolation/Phantom-read.png">{:width=”800px” height=”400px”}</p>
<p>请注意，事务1执行了两次相同的查询。 如果保持最高级别的隔离，则应同时返回相同的行集，实际上这是在SQL SERIALIZABLE隔离级别操作的数据库中强制要求的。 但是，在较小的隔离级别，第二次可以返回不同的行集。</p>
<p>在SERIALIZABLE隔离模式下，查询1将导致所有年龄在10到30范围内的记录被锁定，因此查询2将阻塞，直到第一个事务被提交。 在REPEATABLE READ模式下，范围不会被锁定，允许插入记录，第二次执行Query 1以在其结果中包含新行。</p>
<h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><p>在DBMS（数据库管理系统）中的四个ACID属性中，隔离属性是最常放松的属性。 在尝试保持最高级别的隔离时，DBMS通常会获取数据锁定，这可能会导致并发性丢失或实现多版本并发控制。 这需要添加逻辑以使应用程序正常运行。</p>
<p>大多数DBMS提供了许多事务隔离级别，这些级别控制选择数据时发生的锁定程度。 对于许多数据库应用程序，可以构造大多数数据库事务以避免需要高隔离级别（例如，SERIALIZABLE级别），从而减少系统的锁定开销。程序员必须仔细分析数据库访问代码，以确保任何放松隔离不会导致难以找到的软件错误。 相反，如果使用更高的隔离级别，则会增加死锁的可能性，这也需要仔细分析和编程技术以避免。</p>
<p>ANSI / ISO SQL标准定义的隔离级别如下所示。</p>
<h3 id="Serializable（可串行化）"><a href="#Serializable（可串行化）" class="headerlink" title="Serializable（可串行化）"></a>Serializable（可串行化）</h3><p>这是最高的隔离级别。</p>
<p>使用基于锁的并发控制DBMS实现，可序列化需要在事务结束时释放读取和写入锁（在所选数据上获取）。 当SELECT查询使用ranged WHERE子句时，也必须获取范围锁，尤其是为了避免幻像读取现象。</p>
<p>使用基于非锁定的并发控制时，不会获取锁定; 但是，如果系统检测到多个并发事务之间的写冲突，则只允许其中一个事务提交。 有关此主题的更多详细信息，请参阅快照隔离。</p>
<p>来自:(第二次非正式审查草案）ISO / IEC 9075：1992，数据库语言SQL- 1992年7月30日：保证隔离级别SERIALIZABLE的并发SQL事务的执行是可序列化的。 可序列化执行被定义为执行并发执行SQL事务的操作，这些操作产生与那些相同SQL事务的某些串行执行相同的效果。 串行执行是指每个SQL事务在下一个SQL事务开始之前执行完成的执行。</p>
<h3 id="Repeatable-reads（可重复读）"><a href="#Repeatable-reads（可重复读）" class="headerlink" title="Repeatable reads（可重复读）"></a>Repeatable reads（可重复读）</h3><p>在此隔离级别中，基于锁的并发控制DBMS实现保持读取和写入锁定（在选定数据上获取），直到事务结束。 但是，不管理范围锁定，因此可能会发生幻像读取。</p>
<p>在这种隔离级别写入偏移是可能得，这种现象是两个不同的写入者（他们之前已经读过他们正在更新的列）允许两个写入表中的同一列，从而导致列具有的数据是 这两笔交易的混合。</p>
<h3 id="Read-committed（读已提交）"><a href="#Read-committed（读已提交）" class="headerlink" title="Read committed（读已提交）"></a>Read committed（读已提交）</h3><p>在此隔离级别中，基于锁的并发控制DBMS实现保持写锁（在所选数据上获取）直到事务结束，但是一旦执行SELECT操作就会释放读锁（因此不可重复读取现象 可以发生在这种隔离级别）。与上一级别一样，不管理范围锁定。</p>
<p>换句话说，read committed是一个隔离级别，它保证读取时提交任何数据。 它只是限制读者看到任何中间的，未提交的，“脏”的读。 它没有任何承诺，如果事务重新发出读取，它将找到相同的数据; 数据在读取后可以自由更改。</p>
<h3 id="Read-uncommitted（读未提交）"><a href="#Read-uncommitted（读未提交）" class="headerlink" title="Read uncommitted（读未提交）"></a>Read uncommitted（读未提交）</h3><p>这是最低的隔离级别。在此级别中，允许脏读，因此一个事务可能会看到其他事务所做的尚未提交的更改。</p>
<p>由于每个隔离级别都比下面的隔离级别更强，因为没有更高的隔离级别允许更低级别的操作禁止，标准允许DBMS以比请求更强的隔离级别运行事务（例如，“读取已提交”） 事务实际上可以在“可重复读”隔离级别执行。</p>
<h2 id="缺省的隔离级别"><a href="#缺省的隔离级别" class="headerlink" title="缺省的隔离级别"></a>缺省的隔离级别</h2><p>不同DBMS的默认隔离级别变化很大。 大多数具有事务的数据库允许用户设置任何隔离级别。 在执行SELECT语句以获取锁时，某些DBMS还需要其他语法（例如，SELECT … FOR UPDATE以获取访问行上的独占写锁）。</p>
<p>但是，上述定义被批评为含糊不清，并且没有准确反映许多数据库提供的隔离：</p>
<blockquote>
<p>本文展示了定义隔离级别的异常方法中的一些缺点。 三种ANSI现象是模棱两可的，即使在他们最松散的解释中也不排除某些异常行为……这会导致一些反直觉的结果。 特别是，基于锁的隔离级别具有与ANSI等效的不同的特性。 这令人不安，因为商业数据库系统通常使用锁定实现。 另外，ANSI现象不区分商业系统中流行的多种类型的隔离级别行为。</p>
</blockquote>
<p>还有其他关于ANSI SQL的隔离定义的批评，因为它鼓励实现者做“坏事”：</p>
<blockquote>
<p>…它假设锁定模式用于并发控制，而不是乐观或多版本并发方案，它依赖于微妙的方式。这意味着所提出的语义是不明确的。</p>
</blockquote>
<h2 id="隔离级别，读现象，以及锁"><a href="#隔离级别，读现象，以及锁" class="headerlink" title="隔离级别，读现象，以及锁"></a>隔离级别，读现象，以及锁</h2><p>Isolation levels vs read phenomena<br><img src="/assets/posts/Isolation/isolation-level.png">{:width=”600px” height=”200px”}</p>
<p>如果所有事务都使用可重复读取或可序列化操作，则不会发生丢失更新。</p>
<p>Anomaly Serializable与Serializable不同。也就是说，Serializable计划应该没有所有三种现象类型，这是必要的，但还不够。</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Isolation_(database_systems)#Non-repeatable_reads">Isolation (database systems)</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2019/05/08/2019-01-07-plans-in-2019/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Robinson">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Road To Excelsior">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/05/08/2019-01-07-plans-in-2019/" class="post-title-link" itemprop="url">Plans in 2019</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-05-08 15:53:10" itemprop="dateCreated datePublished" datetime="2019-05-08T15:53:10+08:00">2019-05-08</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><p>读书，读完一本勾一本，觉得好的做标记再读。</p>
<h2 id="1-书单"><a href="#1-书单" class="headerlink" title="1. 书单"></a>1. 书单</h2><h3 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a>计算机基础</h3><ul>
<li>《计算机科学导论》</li>
<li>《计算机操作系统》</li>
<li>《操作系统原理及应用》</li>
</ul>
<h3 id="Java-基础和进阶"><a href="#Java-基础和进阶" class="headerlink" title="Java 基础和进阶"></a>Java 基础和进阶</h3><ul>
<li>《疯狂Java讲义》</li>
<li>《Java核心基础卷1/2》</li>
<li>《Java编程思想》</li>
<li>《Java 8实战》</li>
<li>《jls11》</li>
<li>《Effective Java》</li>
<li>《Java网络编程 第四版》</li>
<li>《Java性能优化权威指南》</li>
</ul>
<h3 id="Java-并发编程"><a href="#Java-并发编程" class="headerlink" title="Java 并发编程"></a>Java 并发编程</h3><ul>
<li>《Java多线程编程核心技术》</li>
<li>《Java多线程编程实战指南》</li>
<li>《实战Java高并发程序设计》</li>
<li>《Java并发编程实战》</li>
<li>《Java并发编程的艺术》</li>
</ul>
<h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><ul>
<li>《设计模式之禅》</li>
</ul>
<h3 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h3><ul>
<li>《深入理解Java虚拟机(第二版)》</li>
<li>《jvms11》</li>
<li>《hotspot》</li>
<li>《虚拟机参数》</li>
</ul>
<h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><ul>
<li>《Redis入门指南》</li>
<li>《Redis实战中文版》</li>
<li>《Redis设计与实现》</li>
<li>《深入分布式缓存，从原理到实践》</li>
<li>《Redis深度历险：核心原理和应用实践》</li>
<li>《redis设计与实现 第二版》</li>
</ul>
<h3 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h3><ul>
<li>《Mysql数据库应用从入门到精通》</li>
<li>《sql 学习指南》</li>
<li>《数据库索引设计与优化》</li>
<li>《高性能mysql》</li>
<li>《Mysql技术内幕- Innodb 存储引擎》</li>
<li>《分布式数据架构及企业实践-基于Mysql中间件》</li>
<li><a target="_blank" rel="noopener" href="https://www.mysql.com/">Mysql官网</a></li>
</ul>
<h3 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h3><ul>
<li>《Maven实战》</li>
</ul>
<h3 id="Shiro"><a href="#Shiro" class="headerlink" title="Shiro"></a>Shiro</h3><ul>
<li>《跟我学shiro教程》</li>
</ul>
<h3 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h3><ul>
<li>《MongoDB 权威指南（第二版）》</li>
</ul>
<h3 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h3><ul>
<li>《Elasticsearch大数据搜索引擎》</li>
<li>《Elasticsearch服务器开发（第二版）》</li>
<li>《Elasticsearch权威指南（中文版）》</li>
<li>《深入理解Elasticsearch 原书第二版》</li>
</ul>
<h3 id="消息中间件"><a href="#消息中间件" class="headerlink" title="消息中间件"></a>消息中间件</h3><ul>
<li>《分布式消息中间件实践》</li>
</ul>
<h3 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h3><ul>
<li>《RabbitMQ实战指南》</li>
<li>《RabbitMQ实战 高效部署分布式消息队列》</li>
<li>《RabbitMQ 官网》</li>
</ul>
<h3 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h3><ul>
<li>《RocketMQ技术内幕》</li>
<li>《RocketMQ实战与原理解析》</li>
</ul>
<h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><ul>
<li>《Linux命令行与Linux脚本编程大全》</li>
<li>《Unix环境高级编程》</li>
<li>《Unix网络编程》</li>
<li>《Linux系统编程手册》</li>
</ul>
<h3 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h3><ul>
<li>《Netty权威指南》</li>
</ul>
<h3 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h3><ul>
<li>《Nginx高性能Web服务器详解》</li>
<li>《Nginx高性能Web服务器实战教程》</li>
<li>《深入理解Nginx模块开发与架构解析第二版》</li>
</ul>
<h3 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h3><ul>
<li>《精通Spring 4.x++ 企业应用开发实战》</li>
<li>《Spring源码深度解析》</li>
<li>《Spring揭秘》</li>
</ul>
<h3 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a>Spring Boot</h3><ul>
<li>《Spring Boot 2 精髓》</li>
<li>《深入实践Spring Boot》</li>
<li>《Spring Boot 实战》</li>
</ul>
<h3 id="Spring-Cloud"><a href="#Spring-Cloud" class="headerlink" title="Spring Cloud"></a>Spring Cloud</h3><ul>
<li>《Spring Cloud 与 Docker 微服务架构实战》</li>
<li>《Spring Cloud 微服务实战》</li>
<li>《深入理解Spring Cloud 与微服务构建》</li>
<li>《Spring Cloud 微服务架构进阶》</li>
</ul>
<h3 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h3><ul>
<li>《Mybatis 从入门到精通》</li>
<li>《深入浅出Mybatis 技术原理与实战》</li>
</ul>
<h3 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h3><ul>
<li>《Zookeeper 分布式过程协同技术详解》</li>
</ul>
<h3 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a>Dubbo</h3><ul>
<li><a target="_blank" rel="noopener" href="https://dubbo.incubator.apache.org/zh-cn/">Dubbo官方文档</a></li>
</ul>
<h3 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h3><ul>
<li>《Tomcat 与Java Web开发技术详解》</li>
<li>《Tomcat 架构解析》</li>
<li>《tomcat 内核设计剖析》</li>
</ul>
<h3 id="数据结构和算法"><a href="#数据结构和算法" class="headerlink" title="数据结构和算法"></a>数据结构和算法</h3><ul>
<li>《Java 数据结构和算法》</li>
</ul>
<h3 id="Java-编程规范"><a href="#Java-编程规范" class="headerlink" title="Java 编程规范"></a>Java 编程规范</h3><ul>
<li>《阿里巴巴Java 开发手册》<ul>
<li>状态：<code>完成</code>{:.success}</li>
<li>点评：一个小册子，但非常有指导性，可以收藏，时不时浏览一次即可。</li>
</ul>
</li>
<li>《重构，改善既有代码的设计》</li>
<li>《敏捷软件开发》</li>
<li>《单元测试之道 Java版》<ul>
<li>状态：<code>完成</code>{:.success}</li>
<li>点评：对于单元测试非常全面的一本原则性指导的书籍，以较为清晰的逻辑叙述了单元测试的内容，如果有时间，可以再读一遍。</li>
</ul>
</li>
</ul>
<h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><ul>
<li>《图解HTTP》</li>
<li>《图解TCP/IP》</li>
<li>《TCP/IP详解》</li>
</ul>
<h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><ul>
<li>《Design Data Intensive Applications》<ul>
<li>状态：<code>在读</code>{:.info}</li>
<li>点评：非常好的一本书，但是对于无实际项目经验的人，不推荐，里面的一些知识，需要有着实际的项目经验才能把控的全面。</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2019/05/08/2019-04-19-How-to-design-a-good-API/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Robinson">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Road To Excelsior">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/05/08/2019-04-19-How-to-design-a-good-API/" class="post-title-link" itemprop="url">How to design a good API and why it matters?</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-05-08 15:53:10" itemprop="dateCreated datePublished" datetime="2019-05-08T15:53:10+08:00">2019-05-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-12-18 00:46:40" itemprop="dateModified" datetime="2020-12-18T00:46:40+08:00">2020-12-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h1><h2 id="1-1-为什么接口设计很重要？"><a href="#1-1-为什么接口设计很重要？" class="headerlink" title="1.1.为什么接口设计很重要？"></a>1.1.为什么接口设计很重要？</h2><ul>
<li>API可能是一个公司最重要的资产<ul>
<li>用户花了很多心血：购买，使用，学习等</li>
<li>停止使用API的成本可能很高</li>
<li>成功的公开API能够抓住用户</li>
</ul>
</li>
<li>API也可能是公司最大的责任之一<ul>
<li>糟糕的API会导致无休止的技术支持需求</li>
</ul>
</li>
<li>公开的API是永久性的 - 只有一次机会保证其正确</li>
</ul>
<h2 id="1-2-为何接口设计对于你很重要？"><a href="#1-2-为何接口设计对于你很重要？" class="headerlink" title="1.2.为何接口设计对于你很重要？"></a>1.2.为何接口设计对于你很重要？</h2><ul>
<li>如果你是程序员，你就是一个API 设计者<ul>
<li>好的代码是模块化的 - 每个模块有一个API</li>
</ul>
</li>
<li>有用的模块往往会被重用<ul>
<li>一旦模块有用户，则不能随意更改API</li>
<li>良好的可重用模块是企业资产</li>
</ul>
</li>
<li>在API设计上进行思考可提高代码质量</li>
</ul>
<h2 id="1-3-优秀的API的特点"><a href="#1-3-优秀的API的特点" class="headerlink" title="1.3.优秀的API的特点"></a>1.3.优秀的API的特点</h2><ul>
<li>易于学习</li>
<li>易于使用，即便没有文档</li>
<li>很难被误用</li>
<li>易于阅读和维护使用它的代码</li>
<li>足够强大到满足需求</li>
<li>易于扩展</li>
<li>适合受众</li>
</ul>
<h1 id="2-概况"><a href="#2-概况" class="headerlink" title="2.概况"></a>2.概况</h1><h2 id="2-1-API设计的流程"><a href="#2-1-API设计的流程" class="headerlink" title="2.1.API设计的流程"></a>2.1.API设计的流程</h2><h3 id="2-1-1-以合理的怀疑态度收集需求"><a href="#2-1-1-以合理的怀疑态度收集需求" class="headerlink" title="2.1.1 以合理的怀疑态度收集需求"></a>2.1.1 以合理的怀疑态度收集需求</h3><ul>
<li>通常你会得到建议的解决方案<ul>
<li>更好的方案可能存在</li>
</ul>
</li>
<li>你的工作是提取出真实的需求<ul>
<li>应采用用户案例的形式</li>
</ul>
</li>
<li>构建一个更加通用的API是更简单，且更有价值的</li>
</ul>
<h3 id="2-1-2-以简短的细则开始-1页足够"><a href="#2-1-2-以简短的细则开始-1页足够" class="headerlink" title="2.1.2 以简短的细则开始 - 1页足够"></a>2.1.2 以简短的细则开始 - 1页足够</h3><ul>
<li>在这个阶段，敏捷是胜过完整性的</li>
<li>将细则在尽可能多的人之间传播<ul>
<li>听取他们的输入，并且慎重对待</li>
</ul>
</li>
<li>如果保持细则简短，则易于修改</li>
<li>持续更新这个细则</li>
</ul>
<h3 id="2-1-3-尽早，经常写入你的API"><a href="#2-1-3-尽早，经常写入你的API" class="headerlink" title="2.1.3 尽早，经常写入你的API"></a>2.1.3 尽早，经常写入你的API</h3><ul>
<li>在实现之前开始设计API<ul>
<li>可以避免会被丢弃的实现</li>
</ul>
</li>
<li>在细则完全确定之前开始设计API<ul>
<li>可以避免会被丢弃的细则</li>
</ul>
</li>
<li>持续地更新你的API<ul>
<li>避免令人讨厌的惊喜</li>
<li>代码依靠样例和单元测试存活</li>
</ul>
</li>
</ul>
<h3 id="2-1-4-写入SPI-Service-Provider-Interface-更为重要"><a href="#2-1-4-写入SPI-Service-Provider-Interface-更为重要" class="headerlink" title="2.1.4 写入SPI(Service Provider Interface)更为重要"></a>2.1.4 写入SPI(Service Provider Interface)更为重要</h3><ul>
<li>Service Provider Interface(SPI) 关于SPI介绍，参见: <a target="_blank" rel="noopener" href="https://juejin.im/post/5af952fdf265da0b9e652de3">JavaSPI机制介绍</a><ul>
<li>插件接口，可支持多种实现</li>
</ul>
</li>
<li>在发布前，编写多个插件<ul>
<li>如果只写一个插件，可能不能支持另外一个</li>
<li>如果写两个插件，可能支持更多的（需求）</li>
<li>如果写三个插件，可能就能正常工作</li>
</ul>
</li>
</ul>
<h3 id="2-1-5-维护现实的期望"><a href="#2-1-5-维护现实的期望" class="headerlink" title="2.1.5 维护现实的期望"></a>2.1.5 维护现实的期望</h3><ul>
<li>大多数API设计都过度约束了<ul>
<li>你不能使每个人满意</li>
<li>只需要平等的对待每一个人的需求</li>
</ul>
</li>
<li>期望会犯错误<ul>
<li>一段时间的真实调用会将这些错误冲刷掉</li>
<li>期待能持续发展API</li>
</ul>
</li>
</ul>
<h2 id="2-2-设计原则"><a href="#2-2-设计原则" class="headerlink" title="2.2.设计原则"></a>2.2.设计原则</h2><h3 id="2-2-1-API应该只做一件事情，并且做好这件事情"><a href="#2-2-1-API应该只做一件事情，并且做好这件事情" class="headerlink" title="2.2.1 API应该只做一件事情，并且做好这件事情"></a>2.2.1 API应该只做一件事情，并且做好这件事情</h3><ul>
<li>API的功能应该非常容易解释<ul>
<li>如果很难命名API，这可能是一个坏的标志</li>
<li>好的命名驱动着开发</li>
<li>易于拆分和合并模块</li>
</ul>
</li>
</ul>
<h3 id="2-2-2-API应该尽可能的小"><a href="#2-2-2-API应该尽可能的小" class="headerlink" title="2.2.2 API应该尽可能的小"></a>2.2.2 API应该尽可能的小</h3><ul>
<li>API应该满足它的需求</li>
<li>当存在疑问时，放弃这个API<ul>
<li>功能，方法，类，参数等</li>
<li><code>你永远可以添加，但是决不能移除</code>{:.error}</li>
</ul>
</li>
<li>概念比实体更加重要</li>
<li>寻找良好的能效比</li>
</ul>
<h3 id="2-2-3-实现不应该影响API"><a href="#2-2-3-实现不应该影响API" class="headerlink" title="2.2.3 实现不应该影响API"></a>2.2.3 实现不应该影响API</h3><ul>
<li>实现细节<ul>
<li>会迷惑用户</li>
<li>限制改变实现的自由</li>
</ul>
</li>
<li>了解什么是实现细节<ul>
<li>不要过度指定方法的行为</li>
<li>例子：不要指定hash函数的细节</li>
<li>所有可调整的参数都是可疑的</li>
</ul>
</li>
<li>不要让实现的细节<code>&quot;泄露&quot;</code>{:.error}到API</li>
</ul>
<h3 id="2-2-4-最小化所有对象的可访问性"><a href="#2-2-4-最小化所有对象的可访问性" class="headerlink" title="2.2.4 最小化所有对象的可访问性"></a>2.2.4 最小化所有对象的可访问性</h3><ul>
<li>使类和成员变量尽可能是Private的</li>
<li>公有类不应该有公有成员变量（常量除外）</li>
<li>这样可以最大化信息隐藏</li>
<li>允许独立使用，理解，构建，测试和调试模块</li>
</ul>
<h3 id="2-2-5-命名很重要-API是一种小语言"><a href="#2-2-5-命名很重要-API是一种小语言" class="headerlink" title="2.2.5 命名很重要 - API是一种小语言"></a>2.2.5 命名很重要 - API是一种小语言</h3><ul>
<li>名称需要最大化自解释性<ul>
<li>避免神秘的缩写</li>
</ul>
</li>
<li>保持一致 - 相同的单词意味着相同的事情<ul>
<li>这个原则是横跨所有API的，跨平台的</li>
</ul>
</li>
<li>定期争取对称性</li>
<li>代码需要像散文一样</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (car.speed() &gt; <span class="number">2</span> * SPEED_LIMIT)</span><br><span class="line">  generateAlert(<span class="string">&quot;Watch out for cops!&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="2-2-6-文档很重要"><a href="#2-2-6-文档很重要" class="headerlink" title="2.2.6 文档很重要"></a>2.2.6 文档很重要</h3><blockquote>
<p>重用是说起来容易做起来难的事情。实现重用需要好的设计以及非常好的文档。即便我们看到好的设计（这是不常见的），如果没有好的文档，也不会实现目标中的代码重用。</p>
</blockquote>
<h3 id="2-2-7-文档的宗旨"><a href="#2-2-7-文档的宗旨" class="headerlink" title="2.2.7 文档的宗旨"></a>2.2.7 文档的宗旨</h3><ul>
<li>为每个类，接口，方法，构造器，参数以及异常编写文档<ul>
<li>类：这个类实例代表什么</li>
<li>方法：方法和客户端之间的契约<ul>
<li>前置条件，后置条件，副作用</li>
</ul>
</li>
<li>参数：表明单位，类型，所有权</li>
</ul>
</li>
<li>非常仔细地记录状态空间</li>
</ul>
<h3 id="2-2-8-考虑API设计决策的性能后果"><a href="#2-2-8-考虑API设计决策的性能后果" class="headerlink" title="2.2.8 考虑API设计决策的性能后果"></a>2.2.8 考虑API设计决策的性能后果</h3><ul>
<li>错误的决策会影响性能<ul>
<li>使类型是可变的</li>
<li>提供构造器而不是静态工厂，参见：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/8b6f21cf0ca3">考虑用静态工厂方法代替构造器</a></li>
<li>使用实现类型而不是接口类型，参见：<a target="_blank" rel="noopener" href="https://blog.csdn.net/summerxiachen/article/details/79733800">实现类型vs 接口类型</a></li>
</ul>
</li>
<li>不要包装API以获得性能<ul>
<li>潜在的性能问题可能会被解决，但是造成的后遗症是永久的</li>
<li>好的设计通常拥有优秀的性能</li>
</ul>
</li>
</ul>
<h3 id="2-2-9-API设计决策对性能的影响是真实和永久的"><a href="#2-2-9-API设计决策对性能的影响是真实和永久的" class="headerlink" title="2.2.9 API设计决策对性能的影响是真实和永久的"></a>2.2.9 API设计决策对性能的影响是真实和永久的</h3><ul>
<li>Component.getSize()返回 Dimension</li>
<li>Dimension是可变的，每次调用getSize都会分配一个Dimension，所以造成了百万次无用的对象分配</li>
<li>替代版本在1.2添加，但是旧的客户端代码依旧很慢</li>
</ul>
<h3 id="2-2-10-API必须与平台和平共存"><a href="#2-2-10-API必须与平台和平共存" class="headerlink" title="2.2.10 API必须与平台和平共存"></a>2.2.10 API必须与平台和平共存</h3><ul>
<li>做到习惯做法<ul>
<li>遵循标准的命名传统</li>
<li>避免使用过时的参数和返回类型</li>
<li>模仿核心API和语言中的模式</li>
</ul>
</li>
<li>利用对API友好的特性<ul>
<li>泛型，变量，枚举，默认参数</li>
</ul>
</li>
<li>了解并避免API陷阱和缺陷<ul>
<li>Finalizers, public static final arrays</li>
</ul>
</li>
</ul>
<h2 id="2-3-类设计"><a href="#2-3-类设计" class="headerlink" title="2.3.类设计"></a>2.3.类设计</h2><h3 id="2-3-1-最小化可变性"><a href="#2-3-1-最小化可变性" class="headerlink" title="2.3.1 最小化可变性"></a>2.3.1 最小化可变性</h3><ul>
<li>除非有必要，否则类应该是不可变的<ul>
<li>优势：简单，线程安全，可重用</li>
<li>劣势：对于每个值都有独立的对象</li>
</ul>
</li>
<li>如果是可变的，保证状态空间尽可能小，定义明确的<ul>
<li>明确何时调用哪种方法是合法的</li>
</ul>
</li>
</ul>
<p>正面案例：TimerTask<br>反面案例：Date, Calendar</p>
<h3 id="2-3-2-只在有意义时创建子类"><a href="#2-3-2-只在有意义时创建子类" class="headerlink" title="2.3.2 只在有意义时创建子类"></a>2.3.2 只在有意义时创建子类</h3><ul>
<li>子类意味着可替代性<ul>
<li>只在存在一对多的(is-a)的关系时运行创建子类</li>
<li>否则，使用组合</li>
</ul>
</li>
<li>公共类不应该为了便于实现，而为其他公共类创建子类</li>
</ul>
<p>反面案例：Stack extends Vector<br>        Properties extends Hashtable<br>正面案例：Set extends Collection</p>
<h3 id="2-3-3-对于继承需要设计和文档，否则就禁止"><a href="#2-3-3-对于继承需要设计和文档，否则就禁止" class="headerlink" title="2.3.3 对于继承需要设计和文档，否则就禁止"></a>2.3.3 对于继承需要设计和文档，否则就禁止</h3><ul>
<li>继承违反了封装原则<ul>
<li>子类对于父类的实现细节是敏感的</li>
</ul>
</li>
<li>如果你允许创建子类，则文档自用<ul>
<li>方法如何相互使用</li>
</ul>
</li>
<li>保守政策：所有的具体类都是final的 参见: <a target="_blank" rel="noopener" href="http://www.importnew.com/7553.html">深入理解Java中的final关键字</a></li>
</ul>
<p>反面案例：Many concrete classes in J2SE libraries<br>正面案例：AbstractSet, AbstractMap</p>
<h2 id="2-4-方法设计"><a href="#2-4-方法设计" class="headerlink" title="2.4.方法设计"></a>2.4.方法设计</h2><h3 id="2-4-1-不要让客户端做任何模块可以做的事情"><a href="#2-4-1-不要让客户端做任何模块可以做的事情" class="headerlink" title="2.4.1 不要让客户端做任何模块可以做的事情"></a>2.4.1 不要让客户端做任何模块可以做的事情</h3><ul>
<li>减少对样板代码的需求<ul>
<li>通常可以通过剪切-粘贴的方式完成</li>
<li>丑陋，误导，且容易出错</li>
</ul>
</li>
</ul>
<p>样例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.w3c.dom.*;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> javax.xml.transform.*;</span><br><span class="line"><span class="keyword">import</span> javax.xml.transform.dom.*;</span><br><span class="line"><span class="keyword">import</span> javax.xml.transform.stream.*;</span><br><span class="line"> <span class="comment">// DOM code to write an XML document to a specified output stream.</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">writeDoc</span><span class="params">(Document doc, OutputStream out)</span><span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    Transformer t = TransformerFactory.newInstance().newTransformer();</span><br><span class="line">    t.setOutputProperty(OutputKeys.DOCTYPE_SYSTEM, doc.getDoctype().getSystemId());</span><br><span class="line">    t.transform(<span class="keyword">new</span> DOMSource(doc), <span class="keyword">new</span> StreamResult(out));</span><br><span class="line">  &#125; <span class="keyword">catch</span>(TransformerException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(e); <span class="comment">// Can’t happen!</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码，关于javax.xml模块的相关客户端代码可以移除。</p>
<h3 id="2-4-2-不要违反最小惊讶原则"><a href="#2-4-2-不要违反最小惊讶原则" class="headerlink" title="2.4.2 不要违反最小惊讶原则"></a>2.4.2 不要违反最小惊讶原则</h3><ul>
<li>API的使用不应该被其行为惊讶<ul>
<li>这个原则值得额外的实现成本</li>
<li>这个原则也值得降低性能</li>
</ul>
</li>
</ul>
<p>反面样例：<br><img src="/assets/posts/api-design/Thread.png"></p>
<h3 id="2-4-3-为所有可访问字段数据提供String-形式的程序访问方法"><a href="#2-4-3-为所有可访问字段数据提供String-形式的程序访问方法" class="headerlink" title="2.4.3 为所有可访问字段数据提供String 形式的程序访问方法"></a>2.4.3 为所有可访问字段数据提供String 形式的程序访问方法</h3><ul>
<li>否则，客户端需要解析出字符串<ul>
<li>对于客户端来说是痛苦的</li>
<li>更糟糕的是，将字符串格式变成了事实上的API</li>
</ul>
</li>
</ul>
<p>正反面样例：<br><img src="/assets/posts/api-design/Throwable.png"></p>
<h3 id="2-4-4-慎重地进行重载"><a href="#2-4-4-慎重地进行重载" class="headerlink" title="2.4.4 慎重地进行重载"></a>2.4.4 慎重地进行重载</h3><ul>
<li>避免模糊的重载行为<ul>
<li>对于同一个实际行为写了多个重载</li>
<li>保守原则：相同数目的参数不要有两个（重载方法）</li>
</ul>
</li>
<li>仅仅因为你可以并不代表你应该这样做<ul>
<li>这个时候一般使用另一个名称会更好</li>
</ul>
</li>
<li>如果你提供了模糊的重载，保证相同的参数产生相同的行为</li>
</ul>
<p>反面案例：<br><img src="/assets/posts/api-design/TreeSet.png"></p>
<h3 id="2-4-5-使用合适的参数类型和返回类型"><a href="#2-4-5-使用合适的参数类型和返回类型" class="headerlink" title="2.4.5 使用合适的参数类型和返回类型"></a>2.4.5 使用合适的参数类型和返回类型</h3><ul>
<li>对于输入，相较与类，鼓励使用接口类型<ul>
<li>提供了灵活性，性能</li>
</ul>
</li>
<li>使用最具体的输入参数类型<ul>
<li>将错误从运行时移到了编译时</li>
</ul>
</li>
<li>如果存在更合适的类型，不要使用String<ul>
<li>String是笨重的，易出错的，慢的</li>
</ul>
</li>
<li>不要使用float类型用于货币价值<ul>
<li>双浮点数容易造成不准确的结果</li>
</ul>
</li>
<li>使用double(64 bits)而不是float(32 bit)<ul>
<li>精度丢失是真实的，而性能并没有提升多少</li>
</ul>
</li>
</ul>
<h3 id="2-4-6-在方法中保持一致的参数顺序"><a href="#2-4-6-在方法中保持一致的参数顺序" class="headerlink" title="2.4.6 在方法中保持一致的参数顺序"></a>2.4.6 在方法中保持一致的参数顺序</h3><ul>
<li>特别是在参数类型相同的情况下<br>反面案例:<br><img src="/assets/posts/api-design/copy.png"><br>正面案例:<br><img src="/assets/posts/api-design/parameter.png"></li>
</ul>
<h3 id="2-4-7-避免长的参数列表"><a href="#2-4-7-避免长的参数列表" class="headerlink" title="2.4.7 避免长的参数列表"></a>2.4.7 避免长的参数列表</h3><ul>
<li>三个或更少的参数比较理想<ul>
<li>如果过多，用户就需要去参考文档了</li>
</ul>
</li>
<li>对于过长的，且类型相同的参数列表是有伤害性的<ul>
<li>程序员可能错误地转置参数</li>
<li>程序可能会正常的编译，运行，但是行为错误了</li>
</ul>
</li>
<li>两种缩短参数列表的方法<ul>
<li>将方法拆分</li>
<li>创建helper class来存储参数<br>反面案例：<br><img src="/assets/posts/api-design/toolongparameter.png"></li>
</ul>
</li>
</ul>
<h3 id="2-4-8-避免返回需要异常处理的返回值"><a href="#2-4-8-避免返回需要异常处理的返回值" class="headerlink" title="2.4.8  避免返回需要异常处理的返回值"></a>2.4.8  避免返回需要异常处理的返回值</h3><ul>
<li>返回0长度的列表，或空集合，而不是null<br>反面样例：<br><img src="/assets/posts/api-design/nullexamper.png"></li>
</ul>
<h2 id="2-5-异常设计"><a href="#2-5-异常设计" class="headerlink" title="2.5.异常设计"></a>2.5.异常设计</h2><h3 id="2-5-1-抛出异常以表明特殊情况"><a href="#2-5-1-抛出异常以表明特殊情况" class="headerlink" title="2.5.1 抛出异常以表明特殊情况"></a>2.5.1 抛出异常以表明特殊情况</h3><ul>
<li>不要强迫客户端使用异常来控制流程</li>
</ul>
<p>反面案例:<br><img src="/assets/posts/api-design/flowControl.png"></p>
<ul>
<li>相反，不要无声地失败</li>
</ul>
<p>反面案例：<br><img src="/assets/posts/api-design/ThreadGroup.png"></p>
<h3 id="2-5-2-赞成未受检的异常"><a href="#2-5-2-赞成未受检的异常" class="headerlink" title="2.5.2 赞成未受检的异常"></a>2.5.2 赞成未受检的异常</h3><ul>
<li>Checked - 客户端必须采用恢复措施</li>
<li>Unchecked - 程序错误</li>
<li>过度使用受检异常会导致样板代码(boilerplate)</li>
</ul>
<p>反面样例：<br><img src="/assets/posts/api-design/uncheck.png"></p>
<h3 id="2-5-3-需要在异常中保存失败的捕捉信息"><a href="#2-5-3-需要在异常中保存失败的捕捉信息" class="headerlink" title="2.5.3 需要在异常中保存失败的捕捉信息"></a>2.5.3 需要在异常中保存失败的捕捉信息</h3><ul>
<li>便于诊断和恢复</li>
<li>对于未受检异常，消息就足够了</li>
<li>对于受检异常，请提供访问者信息</li>
</ul>
<h2 id="2-6-重构API设计"><a href="#2-6-重构API设计" class="headerlink" title="2.6.重构API设计"></a>2.6.重构API设计</h2><p>向量中的子列表操作：<br><img src="/assets/posts/api-design/vector.png"></p>
<ul>
<li>不是很强大 - 只支持搜索</li>
<li>没有文档的话，很难使用</li>
</ul>
<p>重构这个操作：<br><img src="/assets/posts/api-design/subList.png"></p>
<ul>
<li>非常强大 - 支持所有的操作</li>
<li>使用接口，降低了概念的重量<ul>
<li>提高了概念的能效比</li>
</ul>
</li>
<li>没有文档，也能简单使用</li>
</ul>
<h1 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h1><ul>
<li>API设计是一个严肃且有回报的工艺<ul>
<li>改善了很多编程者，终端用户，公司等</li>
</ul>
</li>
<li>这篇文档涵盖了一些该工艺的启发式方法<ul>
<li>不要无脑附和</li>
<li>在没有合理的原因的情况下，也不要违背</li>
</ul>
</li>
<li>API设计很难<ul>
<li>它不是一个单独的过程</li>
<li>完美是不存在的，但是可以持续改进</li>
</ul>
</li>
</ul>
<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ol>
<li><a href="/assets/posts/api-design/a.pdf">How to design a good API and why it matters</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2019/05/08/2019-04-21-Unit-Test/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Robinson">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Road To Excelsior">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/05/08/2019-04-21-Unit-Test/" class="post-title-link" itemprop="url">单元测试</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-05-08 15:53:10" itemprop="dateCreated datePublished" datetime="2019-05-08T15:53:10+08:00">2019-05-08</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-单元测试"><a href="#1-单元测试" class="headerlink" title="1.单元测试"></a>1.单元测试</h2><h3 id="1-1-什么是单元测试？"><a href="#1-1-什么是单元测试？" class="headerlink" title="1.1 什么是单元测试？"></a>1.1 什么是单元测试？</h3><p><strong>单元测试</strong>是开发者编写的一小段代码，用于检测被测代码的一个很小的、很明确的的功能是否正常。</p>
<h3 id="1-2-一般原则"><a href="#1-2-一般原则" class="headerlink" title="1.2 一般原则"></a>1.2 一般原则</h3><ol>
<li>测试任何可能失败的地方。</li>
<li>测试任何已经失败的地方。</li>
<li>对于新加的代码，在被证明正确之前，都可能是有问题的。</li>
<li>至少编写和产品代码一样多的测试代码。</li>
<li>针对每次编译都做局部测试。</li>
<li>签入代码之前做全局测试。</li>
</ol>
<h2 id="2-使用Junit来进行单元测试"><a href="#2-使用Junit来进行单元测试" class="headerlink" title="2.使用Junit来进行单元测试"></a>2.使用Junit来进行单元测试</h2><p>测试代码<code>必须</code>{:.error}要做以下这几件事情：</p>
<ul>
<li>准备测试所需要的各种条件（创建所有必须的对象，分配必要的资源等等）。</li>
<li>调用要测试的方法。</li>
<li>验证被测试方法的行为和期望是否一致。</li>
<li>完成后清理各种资源</li>
</ul>
<h2 id="3-测试哪些内容：Right-BICEP"><a href="#3-测试哪些内容：Right-BICEP" class="headerlink" title="3.测试哪些内容：Right-BICEP"></a>3.测试哪些内容：Right-BICEP</h2><h3 id="3-1-Right-结果是否正确？"><a href="#3-1-Right-结果是否正确？" class="headerlink" title="3.1 Right-结果是否正确？"></a>3.1 Right-结果是否正确？</h3><ul>
<li>如果代码能够运行正确，我要怎么才知道它是正确的呢？</li>
<li>使用数据文件。</li>
</ul>
<h3 id="3-2-B-是否所有的边界条件都是正确的？"><a href="#3-2-B-是否所有的边界条件都是正确的？" class="headerlink" title="3.2 B-是否所有的边界条件都是正确的？"></a>3.2 B-是否所有的边界条件都是正确的？</h3><p>一个想到可能得边界条件的简单办法是记住短语CORRECT。</p>
<ul>
<li>Conformance（一致性） – 值是否和预期一致。</li>
<li>Ordering（顺序性）– 值是否如应该的那样，是有序或者无序的。</li>
<li>Range（区间性） – 值是否位于合理的最小值和最大值之内。</li>
<li>Reference（依赖性）– 代码是否引用了一些不在代码本身控制范围之内的外部资源。</li>
<li>Existence（存在性） – 值是否存在（例如，是否是非null, 非0， 在一个集合中等等）。</li>
<li>Cardinatity(基数性) – 是否恰好有足够的值？</li>
<li>Time（相对或者绝对的时间性）– 所有事情的发生是否是有序的？是否是在正确的时刻？是否恰好及时？</li>
</ul>
<h3 id="3-3-I-能查一下反向关联吗？"><a href="#3-3-I-能查一下反向关联吗？" class="headerlink" title="3.3 I-能查一下反向关联吗？"></a>3.3 I-能查一下反向关联吗？</h3><p>对于一些方法，我们可以使用反向的逻辑关系来验证它们。<br>需要注意的是：当你同时编写原方法和它的反向测试时，一些bug可能会被在两个函数中都出现的错误所掩盖。在可能的情况下，应该使用不同的原理来编写反向测试。</p>
<h3 id="3-4-C-能用其他手段交叉检查一下结果吗？"><a href="#3-4-C-能用其他手段交叉检查一下结果吗？" class="headerlink" title="3.4 C-能用其他手段交叉检查一下结果吗？"></a>3.4 C-能用其他手段交叉检查一下结果吗？</h3><p>你同样可能使用其他的手段来交叉检查函数的结果。比如使用一些比较弱的版本来检查我们新写的新版本函数效果。</p>
<h3 id="3-5-E-你是否可以强制错误条件的发生？"><a href="#3-5-E-你是否可以强制错误条件的发生？" class="headerlink" title="3.5 E-你是否可以强制错误条件的发生？"></a>3.5 E-你是否可以强制<strong>错误条件</strong>的发生？</h3><p>使用Mock对象来模拟错误条件来产生各种条件：</p>
<ul>
<li>内存耗光</li>
<li>磁盘用满</li>
<li>时钟出问题</li>
<li>网络不可用或者有问题</li>
<li>系统过载</li>
<li>显示分辨率过高或过低</li>
</ul>
<h3 id="3-6-P-是否满足性能要求？"><a href="#3-6-P-是否满足性能要求？" class="headerlink" title="3.6 P-是否满足性能要求？"></a>3.6 P-是否满足性能要求？</h3><p>考虑使用JUnitPerf等工具来进行性能测试。</p>
<h2 id="4-使用mock来模拟对象"><a href="#4-使用mock来模拟对象" class="headerlink" title="4.使用mock来模拟对象"></a>4.使用mock来模拟对象</h2><p>参见文档: <a target="_blank" rel="noopener" href="http://www.importnew.com/24741.html">Junit mockito 解耦合测试</a></p>
<h2 id="5-好的测试所具有的品质"><a href="#5-好的测试所具有的品质" class="headerlink" title="5.好的测试所具有的品质"></a>5.好的测试所具有的品质</h2><p>好的测试应该具有如下的品质，合称为A-TRIP:</p>
<ul>
<li>自动化（Automatic)<ul>
<li>调用测试自动化</li>
<li>检查结果自动化</li>
</ul>
</li>
<li>彻底的（Thorough）<ul>
<li>完整度测试</li>
</ul>
</li>
<li>可重复（Repeatable）<ul>
<li>每个测试必须独立其他的测试，而且还必须独立于周围的环境。</li>
</ul>
</li>
<li>独立的（Independent）<ul>
<li>一次只测试了一样东西（一个测试函数应该专注于代码产品中的一个函数），或者组合起来并共同提供某个特性的一组函数</li>
<li>测试没有依赖于其他任何的测试; 这里可以使用<code>Mockito</code>{:.error}</li>
<li>每个测试方法的setUp 以及teardown函数，以及每个类的setup函数和teardown函数帮助实现了这个特性</li>
<li><code>每个测试都应该是一座孤岛</code>{:.error}</li>
</ul>
</li>
<li>专业的（Professional）</li>
</ul>
<h3 id="5-1-对测试进行测试"><a href="#5-1-对测试进行测试" class="headerlink" title="5.1 对测试进行测试"></a>5.1 对测试进行测试</h3><p>如何保证测试代码是正确的：</p>
<ul>
<li>在修正bug的同时改进测试。</li>
<li>通过引入bug来证明测试。</li>
</ul>
<p>步骤：</p>
<ol>
<li>验明 bug。</li>
<li>编写一个将失败的测试来证明 bug 的存在。</li>
<li>修正代码，让测试通过。</li>
<li>验证所有的测试依然可以通过。（也就是，你没有在修补的时候损坏其他的测试）</li>
<li>这种方法能够持续有效的增长测试覆盖率，而从已经存在的代码中逃脱到荒漠的bug的数目会同时下井。</li>
</ol>
<h2 id="6-开发者对单元测试的自我修养"><a href="#6-开发者对单元测试的自我修养" class="headerlink" title="6.开发者对单元测试的自我修养"></a>6.开发者对单元测试的自我修养</h2><h3 id="6-1-宗旨："><a href="#6-1-宗旨：" class="headerlink" title="6.1 宗旨："></a>6.1 宗旨：</h3><ol>
<li>需要避免养成<code>忽略</code>{:.error}”失败的测试结果”的习惯。</li>
<li><code>所有的测试应该在任何时刻都能通过</code>{:.error}</li>
</ol>
<h3 id="6-2-如何遵循这些宗旨呢？"><a href="#6-2-如何遵循这些宗旨呢？" class="headerlink" title="6.2 如何遵循这些宗旨呢？"></a>6.2 如何遵循这些宗旨呢？</h3><ol>
<li>不完整的代码（比如说，仅嵌入了一个类文件，而忘记了它所依赖的其他文件）。</li>
<li>不能编译的代码。</li>
<li>代码能编译，但是会破坏已经存在的代码，比如使得已经存在的代码编译失败。</li>
<li>没有相应单元测试的代码。</li>
<li>不能通过单元测试的代码。</li>
<li>通过了自己的测试，但是导致系统其他地方的其他测试失败的代码。</li>
</ol>
<h3 id="6-3-测试的频率的一般性原则："><a href="#6-3-测试的频率的一般性原则：" class="headerlink" title="6.3 测试的频率的一般性原则："></a>6.3 测试的频率的一般性原则：</h3><ol>
<li>编写新的函数。</li>
</ol>
<ul>
<li>编译并运行本地的单元测试。</li>
</ul>
<ol start="2">
<li>修正bug。</li>
</ol>
<ul>
<li>关于修正bug的单元测试的流程，见 <em>5.1</em>。</li>
</ul>
<ol start="3">
<li>每次成功编译之后。</li>
</ol>
<ul>
<li>运行本地的单元测试。</li>
</ul>
<ol start="4">
<li>每次对版本控制的签入。</li>
</ol>
<ul>
<li>运行所有的模块或者系统的单元的测试。</li>
</ul>
<ol start="5">
<li>通过持续构建工具来持续不断地测试。</li>
</ol>
<h3 id="6-4-测试与遗留代码"><a href="#6-4-测试与遗留代码" class="headerlink" title="6.4 测试与遗留代码"></a>6.4 测试与遗留代码</h3><h3 id="6-5-测试与评审"><a href="#6-5-测试与评审" class="headerlink" title="6.5 测试与评审"></a>6.5 测试与评审</h3><p>无论进行何种形式的代码评审，都要让<code>测试代码成为评审过程的一个组成部分</code>{:.error}。</p>
<h2 id="7-设计话题"><a href="#7-设计话题" class="headerlink" title="7.设计话题"></a>7.设计话题</h2><h3 id="7-1-测试驱动的设计"><a href="#7-1-测试驱动的设计" class="headerlink" title="7.1 测试驱动的设计"></a>7.1 测试驱动的设计</h3><p>如果你总是在编写实现代码之前，就先编写它们的测试代码，那么你就是在使用测试驱动的开发这么一种很有用的技术。这种编码方式的一个优点是，你可以享受到”测试驱动的设计”的好处，并且大大改善接口的设计。</p>
<p>因为总是自己亲自来调用这些接口，所以通常都能获得更好的接口设计。正如一句谚语所说 – 你总是能够利用这些反馈来改善接口的设计。</p>
<h3 id="7-2-测试无效的参数"><a href="#7-2-测试无效的参数" class="headerlink" title="7.2 测试无效的参数"></a>7.2 测试无效的参数</h3><p>原则：<code>别让野蛮人进门</code>{:.error}。</p>
<h2 id="8-个人经验总结"><a href="#8-个人经验总结" class="headerlink" title="8. 个人经验总结"></a>8. 个人经验总结</h2><ol>
<li><p>对于Java service程序，dao层可以通过事务自动回滚来保证对数据库的无侵犯性；其他层，如manager层，service层等，可以通过Mock工具来保证单元测试的独立性和可重复性。</p>
</li>
<li><p>对于web程序，可以通过Mockito, MockMVC, JUnit来配合使用进行controller层的定制化单元测试。</p>
</li>
</ol>
<p>歪个楼：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/633d83dd303b">Spring MVC @JsonView使用详解</a></p>
<h2 id="9-参考文献"><a href="#9-参考文献" class="headerlink" title="9.参考文献"></a>9.参考文献</h2><ul>
<li>《单元测试之道 Java版》</li>
<li>Mockito介绍:<ul>
<li><a target="_blank" rel="noopener" href="https://javacodehouse.com/blog/mockito-tutorial/">How to mock with Mockito (A comprehensive guide with examples)</a></li>
<li><a target="_blank" rel="noopener" href="http://youngfor.me/2017/07/30/mockito-spy/">Mockito Spy 用法</a></li>
<li><a target="_blank" rel="noopener" href="https://site.mockito.org/">Mockito官网</a></li>
<li><a target="_blank" rel="noopener" href="https://memorynotfound.com/unit-test-spring-mvc-rest-service-junit-mockito/">Unit Test Spring MVC Rest Service: MockMVC, JUnit, Mockito</a></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2019/05/08/2019-04-24-Java-Reflection/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Robinson">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Road To Excelsior">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/05/08/2019-04-24-Java-Reflection/" class="post-title-link" itemprop="url">Java Reflection</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-05-08 15:53:10" itemprop="dateCreated datePublished" datetime="2019-05-08T15:53:10+08:00">2019-05-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-12-18 00:46:50" itemprop="dateModified" datetime="2020-12-18T00:46:50+08:00">2020-12-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>反射是Java语言的一种特性。它被用来在<strong>运行时</strong>检查或者修改方法，类，接口的行为。</p>
<ul>
<li>反射所需要的类 reflection 在java.lang.reflect包中；</li>
<li>反射提供了一个对象所属的类信息以及可供运行的对象的方法的信息；</li>
<li>通过反射，可以在运行时调用指定的方法，而无视它们所用的访问限定符；</li>
</ul>
<h2 id="获取类，构造器，方法信息"><a href="#获取类，构造器，方法信息" class="headerlink" title="获取类，构造器，方法信息"></a>获取类，构造器，方法信息</h2><ul>
<li><code>Class</code>{:.error} getClass() 方法被用来获取某个对象所属类的名称</li>
<li><code>Constructors</code>{:.error} getConstructors方法可以被用来获取某个对象所属类的公有构造器信息</li>
<li><code>Methods</code>{:.error} getMethods() 方法被用来获取某个对象所属于类的公有方法信息</li>
</ul>
<p>例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo;</span><br><span class="line"></span><br><span class="line"><span class="comment">// class whose object is to be created</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="comment">// creating a private field</span></span><br><span class="line">    <span class="keyword">private</span> String s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// creating a public constructor</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">()</span>  </span>&#123;  s = <span class="string">&quot;GeeksforGeeks&quot;</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Creating a public method with no arguments</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;The string is &quot;</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Creating a public method with int as argument</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">(<span class="keyword">int</span> n)</span>  </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;The number is &quot;</span> + n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// creating a private method</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Private method invoked&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构建一个方法来为这个类生成对象;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Creating object whose property is to be checked</span></span><br><span class="line">        Test obj = <span class="keyword">new</span> Test();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Creating class object from the object using</span></span><br><span class="line">        <span class="comment">// getclass method</span></span><br><span class="line">        Class cls = obj.getClass();</span><br><span class="line">        System.out.println(<span class="string">&quot;The name of class is &quot;</span> +</span><br><span class="line">                cls.getName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Getting the constructor of the class through the</span></span><br><span class="line">        <span class="comment">// object of the class</span></span><br><span class="line">        Constructor constructor = cls.getConstructor();</span><br><span class="line">        System.out.println(<span class="string">&quot;The name of constructor is &quot;</span> +</span><br><span class="line">                constructor.getName());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;The public methods of class are : &quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Getting methods of the class through the object</span></span><br><span class="line">        <span class="comment">// of the class by using getMethods</span></span><br><span class="line">        Method[] methods = cls.getMethods();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Printing method names</span></span><br><span class="line">        <span class="keyword">for</span> (Method method : methods)</span><br><span class="line">            System.out.println(method.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">````</span><br><span class="line"></span><br><span class="line">观察结果可见：</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">The name of <span class="class"><span class="keyword">class</span> <span class="title">is</span> <span class="title">com</span>.<span class="title">example</span>.<span class="title">demo</span>.<span class="title">Test</span></span></span><br><span class="line"><span class="class"><span class="title">The</span> <span class="title">name</span> <span class="title">of</span> <span class="title">constructor</span> <span class="title">is</span> <span class="title">com</span>.<span class="title">example</span>.<span class="title">demo</span>.<span class="title">Test</span></span></span><br><span class="line">The public methods of class are : </span><br><span class="line">method1</span><br><span class="line">method2</span><br><span class="line">wait</span><br><span class="line">wait</span><br><span class="line">wait</span><br><span class="line">equals</span><br><span class="line">toString</span><br><span class="line">hashCode</span><br><span class="line">getClass</span><br><span class="line">notify</span><br><span class="line">notifyAll</span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>需要说明如下几点：</p>
<ol>
<li>因为Java中所有的类都继承Object，所以公有方法中有一些是Object类中的方法列表；</li>
<li>除了获取上面一些信息，还能获取类的成员变量信息，方法的参数列表信息，返回值信息，异常信息等</li>
</ol>
<h2 id="调用反射调用类，构造器，方法"><a href="#调用反射调用类，构造器，方法" class="headerlink" title="调用反射调用类，构造器，方法"></a>调用反射调用类，构造器，方法</h2><p>承接上个代码案例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: fuxi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2019/4/24</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Creating object whose property is to be checked</span></span><br><span class="line">        Test obj = <span class="keyword">new</span> Test();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Creating class object from the object using</span></span><br><span class="line">        <span class="comment">// getclass method</span></span><br><span class="line">        Class cls = obj.getClass();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// creates object of desired method by providing the</span></span><br><span class="line">        <span class="comment">// method name and parameter class as arguments to</span></span><br><span class="line">        <span class="comment">// the getDeclaredMethod</span></span><br><span class="line">        Method methodcall1 = cls.getDeclaredMethod(<span class="string">&quot;method2&quot;</span>,</span><br><span class="line">                <span class="keyword">int</span>.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// invokes the method at runtime</span></span><br><span class="line">        methodcall1.invoke(obj, <span class="number">19</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// creates object of the desired field by providing</span></span><br><span class="line">        <span class="comment">// the name of field as argument to the</span></span><br><span class="line">        <span class="comment">// getDeclaredField method</span></span><br><span class="line">        Field field = cls.getDeclaredField(<span class="string">&quot;s&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// allows the object to access the field irrespective</span></span><br><span class="line">        <span class="comment">// of the access specifier used with the field</span></span><br><span class="line">        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// takes object and the new value to be assigned</span></span><br><span class="line">        <span class="comment">// to the field as arguments</span></span><br><span class="line">        field.set(obj, <span class="string">&quot;JAVA&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Creates object of desired method by providing the</span></span><br><span class="line">        <span class="comment">// method name as argument to the getDeclaredMethod</span></span><br><span class="line">        Method methodcall2 = cls.getDeclaredMethod(<span class="string">&quot;method1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// invokes the method at runtime</span></span><br><span class="line">        methodcall2.invoke(obj);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Creates object of the desired method by providing</span></span><br><span class="line">        <span class="comment">// the name of method as argument to the</span></span><br><span class="line">        <span class="comment">// getDeclaredMethod method</span></span><br><span class="line">        Method methodcall3 = cls.getDeclaredMethod(<span class="string">&quot;method3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// allows the object to access the method irrespective</span></span><br><span class="line">        <span class="comment">// of the access specifier used with the method</span></span><br><span class="line">        methodcall3.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// invokes the method at runtime</span></span><br><span class="line">        methodcall3.invoke(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行查看代码的结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The number is <span class="number">19</span></span><br><span class="line">The string is JAVA</span><br><span class="line">Private method invoked</span><br></pre></td></tr></table></figure>

<p>通过代码，可以观察到一下几点：</p>
<ul>
<li>如果知道方法的名称和参数类型，可以通过反射来获取这个方法。可以使用getDeclaredMethod()，来创建一个待调用的方法对象。</li>
<li>可以通过invoke方法来在运行时调用指定类的方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 在具有指定参数的指定对象上调用此对象表示的基础方法。</span></span><br><span class="line"><span class="comment">* 各个参数自动解包以匹配原始形式参数，并且原始参数和引用参数都根据需要进行方法调用转换。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object obj, Object... args)</span></span>&#123;...&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>通过反射，可以获取私有变量和私有方法，并使用上诉方法来调用这些私有变量和私有方法。具体的话，使用以下两个步骤来达到目的：<ol>
<li><strong>Class.getDeclaredField(FieldName):</strong> 被用来获取私有成员。这个方法用来返回一个指定字段名称的Field类型的对象。</li>
<li><strong>Field.setAccessible(true):</strong> 无论字段使用的访问修饰符如何，都允许访问该字段。</li>
</ol>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>使用反射的优势在哪里：</p>
<ul>
<li><strong>可扩展性功能</strong>：应用程序可以通过使用完全限定名称创建可扩展性对象的实例来使用外部的用户定义类。</li>
<li><strong>调试和测试工具</strong>：调试器使用反射的一些性质来检查私有类和方法。</li>
</ul>
<p>使用反射的劣势在哪里：</p>
<ul>
<li><strong>性能损耗</strong>：反射操作的性能低于非反射操作，应避免使用在对性能敏感的应用程序中频繁调用的代码段中。</li>
<li><strong>封装暴露</strong>：反射代码打破了抽象，因此可能会通过升级平台来改变行为。</li>
</ul>
<p>关于对反射知识的总结，我是在阅读Java注解以及Spring AOP时，发现这些技术都使用了反射作为运行时代码信息获取执行的基础，所以就回过头来阅读相关的文档。具体关于注解方面的资源，可见：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/briblue/article/details/73824058">Java 注解 （Annotation）</a></p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ol>
<li><a target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/reflection-in-java/">Reflection in Java</a></li>
<li><a target="_blank" rel="noopener" href="https://www.oracle.com/technetwork/articles/java/javareflection-1536171.html">Using Java Reflection</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Robinson</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">29</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Robinson</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
