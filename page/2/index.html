<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Road To Excelsior">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="Road To Excelsior">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Robinson">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Road To Excelsior</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Road To Excelsior</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2019/05/08/2018-11-19-Spring-AOP-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Robinson">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Road To Excelsior">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/05/08/2018-11-19-Spring-AOP-2/" class="post-title-link" itemprop="url">Spring AOP(2) - 实例化</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-05-08 15:53:10" itemprop="dateCreated datePublished" datetime="2019-05-08T15:53:10+08:00">2019-05-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-12-18 00:44:41" itemprop="dateModified" datetime="2020-12-18T00:44:41+08:00">2020-12-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><p>承接一，在完成了对aop标签的bean的初始化之后，AbstractApplicationContext通过refresh()方法来中的finishBeanFactoryInitialization 来完成对beanFactory中的aop相关的RootBeanDefinition的实例化，其通过为不同的bean生成不同类型的代理（主要是JdkDynamicAopProxy或者ObjenesisCglibAopProxy代理)实现面向切面编程的目的。</p>
<h2 id="1-代理对象实例化"><a href="#1-代理对象实例化" class="headerlink" title="1. 代理对象实例化"></a>1. 代理对象实例化</h2><p>下图显示了通过断点调试的方法打印出了aop 代理对象实例化的过程：</p>
<p>![](/assets/posts/Spring aop instance/aop-instance.png)</p>
<p>通过分析如下，其主要包含了如下几个步骤：</p>
<ol>
<li>判断是否需要为bean生成代理；</li>
<li>创建AopProxy代理接口实现类；</li>
<li>通过接口实现类的getProxy方法来获取<bean>对应的代理；</li>
</ol>
<h3 id="1-1-判断是否为bean生成代理"><a href="#1-1-判断是否为bean生成代理" class="headerlink" title="1.1 判断是否为bean生成代理"></a>1.1 判断是否为bean生成代理</h3><p>在AbstractAutoProxyCreator中，wrapIfNecessary方法显示了什么时候为bean生成代理包装的过程，其主要通过拿到bean对应的Advisor数组，只要Advisor数组不为空，那么就会通过第17行的代码为<bean>创建代理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Wrap the given bean if necessary, i.e. if it is eligible for being proxied.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bean the raw bean instance</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanName the name of the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> cacheKey the cache key for metadata access</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a proxy wrapping the bean, or the raw bean instance as-is</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">wrapIfNecessary</span><span class="params">(Object bean, String beanName, Object cacheKey)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (StringUtils.hasLength(beanName) &amp;&amp; <span class="keyword">this</span>.targetSourcedBeans.contains(beanName)) &#123;</span><br><span class="line">		<span class="keyword">return</span> bean;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (Boolean.FALSE.equals(<span class="keyword">this</span>.advisedBeans.get(cacheKey))) &#123;</span><br><span class="line">		<span class="keyword">return</span> bean;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) &#123;</span><br><span class="line">		<span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">		<span class="keyword">return</span> bean;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Create proxy if we have advice.</span></span><br><span class="line">	Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, <span class="keyword">null</span>);</span><br><span class="line">	<span class="keyword">if</span> (specificInterceptors != DO_NOT_PROXY) &#123;</span><br><span class="line">		<span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.TRUE);</span><br><span class="line">		Object proxy = createProxy(</span><br><span class="line">				bean.getClass(), beanName, specificInterceptors, <span class="keyword">new</span> SingletonTargetSource(bean));</span><br><span class="line">		<span class="keyword">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line">		<span class="keyword">return</span> proxy;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">	<span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里面的AbstractAutoProxyCreator是如何引用在实例化bean中的呢？？在前面的ioc博客中显示，AbstractAutowireCapableBeanFactory作为功能最强大的bean factory，其在实例化bean的过程(initializeBean)中，调用了applyBeanPostProcessorsAfterInitialization()方法，在bean初始化之后进行了后处理。在这个方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">applyBeanPostProcessorsAfterInitialization</span><span class="params">(Object existingBean, String beanName)</span></span></span><br><span class="line"><span class="function">		<span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">	Object result = existingBean;</span><br><span class="line">	<span class="keyword">for</span> (BeanPostProcessor beanProcessor : getBeanPostProcessors()) &#123;</span><br><span class="line">		Object current = beanProcessor.postProcessAfterInitialization(result, beanName);</span><br><span class="line">		<span class="keyword">if</span> (current == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> result;</span><br><span class="line">		&#125;</span><br><span class="line">		result = current;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其调用了父虚拟类的getBeanPostProcessors的方法获得了BeanPostProcessor来完成了对bean的处理，这里AbstractAutoProxyCreator是BeanPostProcessor的一个实现(虚)类。也就是说，在bean factory中已经存在对应的BeanPostProcessor实例来完成对符合条件的bean进行代理对象的创建的。</p>
<p>其中关于AbstractAutoProxyCreator的类层次架构如下：<br>![](/assets/posts/Spring aop instance/AbstractAutoProxyCreator.png)</p>
<h3 id="1-2-创建AopProxy代理接口实现类"><a href="#1-2-创建AopProxy代理接口实现类" class="headerlink" title="1.2 创建AopProxy代理接口实现类"></a>1.2 创建AopProxy代理接口实现类</h3><p>在AbstractAutoProxyCreator中,createProxy方法用来为给定的bean创建AOP代理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create an AOP proxy for the given bean.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanClass the class of the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanName the name of the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> specificInterceptors the set of interceptors that is</span></span><br><span class="line"><span class="comment"> * specific to this bean (may be empty, but not null)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> targetSource the TargetSource for the proxy,</span></span><br><span class="line"><span class="comment"> * already pre-configured to access the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the AOP proxy for the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #buildAdvisors</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createProxy</span><span class="params">(Class&lt;?&gt; beanClass, <span class="meta">@Nullable</span> String beanName,</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="meta">@Nullable</span> Object[] specificInterceptors, TargetSource targetSource)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.beanFactory <span class="keyword">instanceof</span> ConfigurableListableBeanFactory) &#123;</span><br><span class="line">		AutoProxyUtils.exposeTargetClass((ConfigurableListableBeanFactory) <span class="keyword">this</span>.beanFactory, beanName, beanClass);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ProxyFactory proxyFactory = <span class="keyword">new</span> ProxyFactory();</span><br><span class="line">	proxyFactory.copyFrom(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!proxyFactory.isProxyTargetClass()) &#123;</span><br><span class="line">		<span class="keyword">if</span> (shouldProxyTargetClass(beanClass, beanName)) &#123;</span><br><span class="line">			proxyFactory.setProxyTargetClass(<span class="keyword">true</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			evaluateProxyInterfaces(beanClass, proxyFactory);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Advisor[] advisors = buildAdvisors(beanName, specificInterceptors);</span><br><span class="line">	proxyFactory.addAdvisors(advisors);</span><br><span class="line">	proxyFactory.setTargetSource(targetSource);</span><br><span class="line">	customizeProxyFactory(proxyFactory);</span><br><span class="line"></span><br><span class="line">	proxyFactory.setFrozen(<span class="keyword">this</span>.freezeProxy);</span><br><span class="line">	<span class="keyword">if</span> (advisorsPreFiltered()) &#123;</span><br><span class="line">		proxyFactory.setPreFiltered(<span class="keyword">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> proxyFactory.getProxy(getProxyClassLoader());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进入最后一行的工厂方法中，proxyFactory.getProxy()的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create a new proxy according to the settings in this factory.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Can be called repeatedly. Effect will vary if we&#x27;ve added</span></span><br><span class="line"><span class="comment"> * or removed interfaces. Can add and remove interceptors.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Uses the given class loader (if necessary for proxy creation).</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> classLoader the class loader to create the proxy with</span></span><br><span class="line"><span class="comment"> * (or &#123;<span class="doctag">@code</span> null&#125; for the low-level proxy facility&#x27;s default)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the proxy object</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(<span class="meta">@Nullable</span> ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> createAopProxy().getProxy(classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见，这个方法根据这个工厂的设定来创建一个新的代理。先看看，这个工厂类的继承层次：<br>![](/assets/posts/Spring aop instance/ProxyFactory.png)</p>
<p>进入方法可见，其调用ProxyCreatorSupport的方法来获取指定的AopProxy代理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Subclasses should call this to get a new AOP proxy. They should &lt;b&gt;not&lt;/b&gt;</span></span><br><span class="line"><span class="comment"> * create an AOP proxy with &#123;<span class="doctag">@code</span> this&#125; as an argument.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> AopProxy <span class="title">createAopProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!<span class="keyword">this</span>.active) &#123;</span><br><span class="line">		activate();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> getAopProxyFactory().createAopProxy(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>hold on。那么问题来了，哪里获取指定的proxy实例呢，答案在getAopProxyFactory方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> AopProxyFactory aopProxyFactory;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the AopProxyFactory that this ProxyConfig uses.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AopProxyFactory <span class="title">getAopProxyFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.aopProxyFactory;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>即，其通过AopProxyFactory的工厂实现类完成了对不同类型的bean选择不同的proxy的过程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultAopProxyFactory</span> <span class="keyword">implements</span> <span class="title">AopProxyFactory</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> AopProxy <span class="title">createAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class="line">			Class&lt;?&gt; targetClass = config.getTargetClass();</span><br><span class="line">			<span class="keyword">if</span> (targetClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">&quot;TargetSource cannot determine target class: &quot;</span> +</span><br><span class="line">						<span class="string">&quot;Either an interface or a target is required for proxy creation.&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> ObjenesisCglibAopProxy(config);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Determine whether the supplied &#123;<span class="doctag">@link</span> AdvisedSupport&#125; has only the</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@link</span> org.springframework.aop.SpringProxy&#125; interface specified</span></span><br><span class="line"><span class="comment">	 * (or no proxy interfaces specified at all).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">hasNoUserSuppliedProxyInterfaces</span><span class="params">(AdvisedSupport config)</span> </span>&#123;</span><br><span class="line">		Class&lt;?&gt;[] ifcs = config.getProxiedInterfaces();</span><br><span class="line">		<span class="keyword">return</span> (ifcs.length == <span class="number">0</span> || (ifcs.length == <span class="number">1</span> &amp;&amp; SpringProxy.class.isAssignableFrom(ifcs[<span class="number">0</span>])));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>平时我们说AOP原理三句话就能概括：</p>
<ol>
<li>对类生成代理使用CGLIB</li>
<li>对接口生成代理使用JDK原生的Proxy</li>
<li>可以通过配置文件指定对接口使用CGLIB生成代理</li>
</ol>
<p>其中，关于CGLIB的介绍，可见参考文档一，关于JDK PROXY可见参考文档二。</p>
<h3 id="1-3-通过getProxy方法来获取对应的代理"><a href="#1-3-通过getProxy方法来获取对应的代理" class="headerlink" title="1.3 通过getProxy方法来获取对应的代理"></a>1.3 通过getProxy方法来获取<bean>对应的代理</h3><p>关于AopProxy接口的定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.aop.framework;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.lang.Nullable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Delegate interface for a configured AOP proxy, allowing for the creation</span></span><br><span class="line"><span class="comment"> * of actual proxy objects.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Out-of-the-box implementations are available for JDK dynamic proxies</span></span><br><span class="line"><span class="comment"> * and for CGLIB proxies, as applied by &#123;<span class="doctag">@link</span> DefaultAopProxyFactory&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Rod Johnson</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Juergen Hoeller</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> DefaultAopProxyFactory</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AopProxy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Create a new proxy object.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Uses the AopProxy&#x27;s default class loader (if necessary for proxy creation):</span></span><br><span class="line"><span class="comment">	 * usually, the thread context class loader.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> the new proxy object (never &#123;<span class="doctag">@code</span> null&#125;)</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> Thread#getContextClassLoader()</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function">Object <span class="title">getProxy</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Create a new proxy object.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Uses the given class loader (if necessary for proxy creation).</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@code</span> null&#125; will simply be passed down and thus lead to the low-level</span></span><br><span class="line"><span class="comment">	 * proxy facility&#x27;s default, which is usually different from the default chosen</span></span><br><span class="line"><span class="comment">	 * by the AopProxy implementation&#x27;s &#123;<span class="doctag">@link</span> #getProxy()&#125; method.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> classLoader the class loader to create the proxy with</span></span><br><span class="line"><span class="comment">	 * (or &#123;<span class="doctag">@code</span> null&#125; for the low-level proxy facility&#x27;s default)</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> the new proxy object (never &#123;<span class="doctag">@code</span> null&#125;)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function">Object <span class="title">getProxy</span><span class="params">(<span class="meta">@Nullable</span> ClassLoader classLoader)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在我们的样例中，采用的是CglibAopProxy来获取代理，关于Cglib的相关介绍，可见参考文档一。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(<span class="meta">@Nullable</span> ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">		logger.debug(<span class="string">&quot;Creating CGLIB proxy: target source is &quot;</span> + <span class="keyword">this</span>.advised.getTargetSource());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		Class&lt;?&gt; rootClass = <span class="keyword">this</span>.advised.getTargetClass();</span><br><span class="line">		Assert.state(rootClass != <span class="keyword">null</span>, <span class="string">&quot;Target class must be available for creating a CGLIB proxy&quot;</span>);</span><br><span class="line"></span><br><span class="line">		Class&lt;?&gt; proxySuperClass = rootClass;</span><br><span class="line">		<span class="keyword">if</span> (ClassUtils.isCglibProxyClass(rootClass)) &#123;</span><br><span class="line">			proxySuperClass = rootClass.getSuperclass();</span><br><span class="line">			Class&lt;?&gt;[] additionalInterfaces = rootClass.getInterfaces();</span><br><span class="line">			<span class="keyword">for</span> (Class&lt;?&gt; additionalInterface : additionalInterfaces) &#123;</span><br><span class="line">				<span class="keyword">this</span>.advised.addInterface(additionalInterface);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Validate the class, writing log messages as necessary.</span></span><br><span class="line">		validateClassIfNecessary(proxySuperClass, classLoader);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Configure CGLIB Enhancer...</span></span><br><span class="line">		Enhancer enhancer = createEnhancer();</span><br><span class="line">		<span class="keyword">if</span> (classLoader != <span class="keyword">null</span>) &#123;</span><br><span class="line">			enhancer.setClassLoader(classLoader);</span><br><span class="line">			<span class="keyword">if</span> (classLoader <span class="keyword">instanceof</span> SmartClassLoader &amp;&amp;</span><br><span class="line">					((SmartClassLoader) classLoader).isClassReloadable(proxySuperClass)) &#123;</span><br><span class="line">				enhancer.setUseCache(<span class="keyword">false</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		enhancer.setSuperclass(proxySuperClass);</span><br><span class="line">		enhancer.setInterfaces(AopProxyUtils.completeProxiedInterfaces(<span class="keyword">this</span>.advised));</span><br><span class="line">		enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);</span><br><span class="line">		enhancer.setStrategy(<span class="keyword">new</span> ClassLoaderAwareUndeclaredThrowableStrategy(classLoader));</span><br><span class="line"></span><br><span class="line">		Callback[] callbacks = getCallbacks(rootClass);</span><br><span class="line">		Class&lt;?&gt;[] types = <span class="keyword">new</span> Class&lt;?&gt;[callbacks.length];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; types.length; x++) &#123;</span><br><span class="line">			types[x] = callbacks[x].getClass();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// fixedInterceptorMap only populated at this point, after getCallbacks call above</span></span><br><span class="line">		enhancer.setCallbackFilter(<span class="keyword">new</span> ProxyCallbackFilter(</span><br><span class="line">				<span class="keyword">this</span>.advised.getConfigurationOnlyCopy(), <span class="keyword">this</span>.fixedInterceptorMap, <span class="keyword">this</span>.fixedInterceptorOffset));</span><br><span class="line">		enhancer.setCallbackTypes(types);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Generate the proxy class and create a proxy instance.</span></span><br><span class="line">		<span class="keyword">return</span> createProxyClassAndInstance(enhancer, callbacks);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (CodeGenerationException | IllegalArgumentException ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">&quot;Could not generate CGLIB subclass of &quot;</span> + <span class="keyword">this</span>.advised.getTargetClass() +</span><br><span class="line">				<span class="string">&quot;: Common causes of this problem include using a final class or a non-visible class&quot;</span>,</span><br><span class="line">				ex);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">		<span class="comment">// TargetSource.getTarget() failed</span></span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">&quot;Unexpected AOP exception&quot;</span>, ex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码时CglibAopProxy的getProxy()方法，在这里面，通过设置合适的enhancer，以及callbacks，然后调用create方法来创建代理对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createProxyClassAndInstance</span><span class="params">(Enhancer enhancer, Callback[] callbacks)</span> </span>&#123;</span><br><span class="line">	enhancer.setInterceptDuringConstruction(<span class="keyword">false</span>);</span><br><span class="line">	enhancer.setCallbacks(callbacks);</span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">this</span>.constructorArgs != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.constructorArgTypes != <span class="keyword">null</span> ?</span><br><span class="line">			enhancer.create(<span class="keyword">this</span>.constructorArgTypes, <span class="keyword">this</span>.constructorArgs) :</span><br><span class="line">			enhancer.create());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结和思考"><a href="#总结和思考" class="headerlink" title="总结和思考"></a>总结和思考</h2><p>通过阅读spring aop的代码，可以发现，spring aop实现，主要是通过将 &lt;aop: advisor&gt; 标签来解析成 RootBeanDefinition 来完成对aop 代理对象的定义，然后在通过两种不同的代理生成方法，cglib以及jdk proxy的方法来完成对代理对象的生成。</p>
<p>那么，RootBeanDefinition的定义是如何的呢？他是如何表示不同的切点，通知等这些aop的概念的呢？这个问题值得深入探讨一下。</p>
<p>另外，cglib 以及 jdk proxy 是如何对RootBeanDefinition就行解析来完成代理对象的构建的呢？</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ol>
<li><a target="_blank" rel="noopener" href="https://ustccat.github.io/2018/10/18/CGLib.html">cglib</a></li>
<li><a target="_blank" rel="noopener" href="https://ustccat.github.io/2018/10/27/Java-Proxy.html">JDK Dynamic Proxy</a></li>
<li><a target="_blank" rel="noopener" href="http://www.importnew.com/24459.html">Spring源码分析：AOP源码解析（下篇）</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2019/05/08/2018-11-20-books-and-tasks/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Robinson">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Road To Excelsior">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/05/08/2018-11-20-books-and-tasks/" class="post-title-link" itemprop="url">books and tasks in 2018</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-05-08 15:53:10" itemprop="dateCreated datePublished" datetime="2019-05-08T15:53:10+08:00">2019-05-08</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><h2 id="1-what-do-i-want-to-do-mostly"><a href="#1-what-do-i-want-to-do-mostly" class="headerlink" title="1. what do i want to do mostly"></a>1. what do i want to do mostly</h2><ol>
<li>to become an open minded and active person full of energy</li>
<li>to help my family to premote their business</li>
<li>to read, to think, to communicate, to work</li>
<li>to become a full stack engineer</li>
<li>to save money and increase the incomes</li>
</ol>
<h2 id="2-steps-to-achieve-all-of-these-fastly-and-solidly"><a href="#2-steps-to-achieve-all-of-these-fastly-and-solidly" class="headerlink" title="2. steps to achieve all of these fastly and solidly"></a>2. steps to achieve all of these fastly and solidly</h2><p>First, to become an open minded and active person full of energy, i need to do following things:</p>
<ol>
<li>execise, 每周至少保证有两天，两到三个小时的运动量，注意在运动时要科学，高效，不要讲时间和精力浪费在没有意义的动作上。</li>
<li>sleep，每天至少保证七个小时的睡眠，注意睡眠时的质量，睡前不要做影响睡眠的事情，注意保暖，卫生和整洁。</li>
<li>hygiene，注意自己衣物，床上用品，房间的整洁，每周不定时的打扫，清理。</li>
<li>food，注意荤素搭配，营养均衡，吃健康的事物，但不拒绝垃圾食品</li>
</ol>
<p>Second, to help my family to premote their business, i need to do following things:</p>
<ol>
<li>communicate with them, to understand their small business, to think how to use my ability to help them.</li>
<li>to iterate fast to show their solutions and revise frequently.</li>
</ol>
<p>Third, to read, to think, to communicate, to work, i need to do following things:</p>
<ol>
<li>books</li>
<li>1 技术类书籍</li>
<li>2 经济学书籍</li>
<li>3 心理学书籍</li>
<li>talk with many person, understand their thoughts, to think what i can to help them.</li>
</ol>
<h2 id="3-书单-实时更新，截止到目前"><a href="#3-书单-实时更新，截止到目前" class="headerlink" title="3 书单(实时更新，截止到目前)"></a>3 书单(实时更新，截止到目前)</h2><h3 id="3-1-技术类书籍-今年读的书籍"><a href="#3-1-技术类书籍-今年读的书籍" class="headerlink" title="3.1.技术类书籍(今年读的书籍)"></a>3.1.技术类书籍(今年读的书籍)</h3><ol>
<li>《web api的设计与开发》 评分：8 状态：在读 后续：读完</li>
<li>《图解http》 评分：6 状态：已读 后续：可再读</li>
<li>《DDD领域驱动设计精简版》 评分：5 状态：已读 后续：放弃</li>
<li>《JavaScript 权威指南(第六版)》 评分：8 状态：在读 后续：阅读最新版</li>
<li>《CSS 权威指南(第三版)》 评分：7 状态：已读完 后续：可再读</li>
<li>《Vue.js 实战》 评分：5 状态：放弃 后续：</li>
<li>《JavaScript DOM编程艺术(第二版)》 评分：8 状态：已读 后续：可再读</li>
<li>《领域驱动设计 软件核心复杂性应对之道》 评分：9 状态：已读第二遍 后续：可补充查阅阅读</li>
<li>《实现领域驱动设计》评分：9 状态：已读 后续：可择机再读</li>
</ol>
<h3 id="3-2-心理学书籍"><a href="#3-2-心理学书籍" class="headerlink" title="3.2.心理学书籍"></a>3.2.心理学书籍</h3><h3 id="3-3-经济学书籍"><a href="#3-3-经济学书籍" class="headerlink" title="3.3.经济学书籍"></a>3.3.经济学书籍</h3><ol>
<li>《经济学原理第五版(微观分册)》评分：8 状态：已读 后续：可再读</li>
<li>《经济学原理第五版(宏观分册)》评分：8 状态：已读 后续：可再读</li>
<li>《就业，利息和货币通论》评分： 状态： 后续：</li>
</ol>
<h3 id="3-4-好的博客文章"><a href="#3-4-好的博客文章" class="headerlink" title="3.4.好的博客文章"></a>3.4.好的博客文章</h3><ol>
<li><a target="_blank" rel="noopener" href="http://www.codeceo.com/article/habits-to-be-better-programmer.html">让你变成优秀程序员的几个小习惯</a></li>
</ol>
<h2 id="3-总结和思考"><a href="#3-总结和思考" class="headerlink" title="3. 总结和思考"></a>3. 总结和思考</h2><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2019/05/08/2018-12-07-How-To-Read-Code/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Robinson">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Road To Excelsior">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/05/08/2018-12-07-How-To-Read-Code/" class="post-title-link" itemprop="url">How To Read Code</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-05-08 15:53:10" itemprop="dateCreated datePublished" datetime="2019-05-08T15:53:10+08:00">2019-05-08</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><p>私以为写代码的最终目的都是为了更快更好的做出为用户服务的好产品，为了能够达到这个目的，就需要阅读前辈写出的好的代码，这样的过程主要有两个目的：1.阅读一些经典的框架代码能够让自己更加清楚的了解框架的作用，明白它的限制范围，同时在出现bug时知道问题具体出现哪里；2.阅读经典的代码可以让自己了解好的代码结构是怎么样的，以便培养出优秀的代码风格和代码框架设计。</p>
<p>那么怎样阅读这些huge, unstructured, maintained-by-dozens-of-people, internally-inconsistent, undocumented的代码呢？</p>
<h2 id="1-Build-and-Run-the-Program"><a href="#1-Build-and-Run-the-Program" class="headerlink" title="1. Build and Run the Program"></a>1. Build and Run the Program</h2><p>能够运行这个程序并且观察它的外部行为，在研究程序内在时是非常有用的。程序的文档同时也很有用，但是文档可能因为一些历史原因而不能保证足够的准确。</p>
<p>能够自行编译程序可以帮助你弄清楚哪些外部库是被调用的，哪个编译器以及链接器是有用的……等。并且，如果可以编译一个debug版本的程序，就可以进行单步调试。<a href="">Study the source with Debugger</a>。</p>
<p>同时，也可以添加或者扩展程序的日志，让它告诉你程序是怎么做的。</p>
<h2 id="2-Find-the-High-Level-Logic"><a href="#2-Find-the-High-Level-Logic" class="headerlink" title="2. Find the High-Level Logic"></a>2. Find the High-Level Logic</h2><p>找到程序的入口，观察程序是如何初始化，运行，并且终结停止的。</p>
<p>大多数的程序会有一个main loop，这一点很重要。（但是如果程序使用了外部框架，那么主循环可能在框架里，而不是在应用程序里）。</p>
<p>发现程序终止的条件。这个包括正常的exits，以及非正常的退出。</p>
<p><em>很多事件驱动，以及面向对象的设计没有”main”入口</em>。</p>
<h2 id="3-Draw-Some-Flowcharts"><a href="#3-Draw-Some-Flowcharts" class="headerlink" title="3. Draw Some Flowcharts"></a>3. Draw Some Flowcharts</h2><p>我们都知道流程图是一种糟糕的设计工具，但是他们被用在分析程序流时却十分有用；你不可能将所有的信息保存在脑袋里，所以，在阅读时，画出一些流程图或者状态图是非常有必要的。需要注意的是，注意关注所有的分支情况。</p>
<h2 id="4-Examine-Library-Calls"><a href="#4-Examine-Library-Calls" class="headerlink" title="4. Examine Library Calls"></a>4. Examine Library Calls</h2><p>如果程序使用了外部的库，检查外部的库调用，并且阅读关于这些调用的文档。（这可能是唯一可用的文档了，所以利用好它）。</p>
<h2 id="5-Search-for-Key-Words"><a href="#5-Search-for-Key-Words" class="headerlink" title="5. Search for Key Words"></a>5. Search for Key Words</h2><p>使用编辑器的查找特性来查找所有关联的关键字。</p>
<h2 id="6-Leverage-the-Power-of-Code-Comprehension-Tools"><a href="#6-Leverage-the-Power-of-Code-Comprehension-Tools" class="headerlink" title="6. Leverage the Power of Code Comprehension Tools"></a>6. Leverage the Power of Code Comprehension Tools</h2><p>一些很棒的技术可以被用来做搜索工具，更好的可以用来分析源代码，以及查找引用，生成流程图。这些东西可以被用来回答以下的问题，对于面向对象的代码：</p>
<ol>
<li>谁调用了这个方法？</li>
<li>谁实现了接口，或者这个类的子类？</li>
<li>哪个是这个类的父类？</li>
<li>在哪里这些类被创建，保存，作为参数或者返回来传递？</li>
<li>这个类覆盖了超类的哪些方法？</li>
<li>在哪里这个类的方法可能被多态调用，比如说，通过一个基类或者接口？</li>
</ol>
<p>这里有一个参考文档：<br>“Comprehension and Visualisation of Object-Oriented Code for Inspections” <a target="_blank" rel="noopener" href="http://www.cis.strath.ac.uk/research/efocs/abstracts.html#EFoCS-33-98">http://www.cis.strath.ac.uk/research/efocs/abstracts.html#EFoCS-33-98</a><br>第五节</p>
<h2 id="7-Print-the-code"><a href="#7-Print-the-code" class="headerlink" title="7. Print the code"></a>7. Print the code</h2><p>可以通过物理标记代码的方法，来加快对代码的理解。对关键的代码画上圈圈，或者重点标注重要的变量。</p>
<h2 id="8-Write-UnitTests"><a href="#8-Write-UnitTests" class="headerlink" title="8. Write UnitTests"></a>8. Write UnitTests</h2><p>通过编写测试<a target="_blank" rel="noopener" href="http://wiki.c2.com/?UnitTest">Unit Test</a>，可以验证你的想法，保证代码按照你的想法来运行，获得正确的答案。<br>如果没有足够的单元测试，那么你肯定需要在修改源代码时，编写足够的单元测试。</p>
<h2 id="9-Comment-the-Code"><a href="#9-Comment-the-Code" class="headerlink" title="9. Comment the Code"></a>9. Comment the Code</h2><p>将代码拷贝进一个个人的CVS或者RCS库中，并且根据你自己的理解来进行标注。当你理解了部分的代码，标记就会改变。这个步骤在你进行重构代码时是一个重要的过程。</p>
<p>对你非常不熟悉代码进行反向工程时一个最好的方式就是通过仔细检查得到 <a target="_blank" rel="noopener" href="http://wiki.c2.com/?HoareTriple">HoareTriples</a>，并且计算出一个流程的最弱的前置条件。了解过程的不变量通常会为其预期目的提供有价值的线索，从而让您从代码中获得理解，往往这些过程不能通过命名不佳的变量来猜测。</p>
<h2 id="10-Clean-Up-the-Code"><a href="#10-Clean-Up-the-Code" class="headerlink" title="10. Clean Up the Code"></a>10. Clean Up the Code</h2><p>一个旧的写作技巧，用于重新熟悉你很久以前写过但忘记了或者用于分析别人的文本的文本，就是随着你的进行编辑它。这就是主动阅读。通过以一种不同的方式或者更愉悦的方式来重写。您可能已经注意到Wiki在重构或重新编辑页面时，您会比阅读它更深入地理解这些材料。代码与写作没有太大区别。</p>
<p>因此，在阅读代码时，请在进行时重新格式化，重新调整空格模板，标注代码。修复拼写，保证代码和编码规范一致。 通常代码是稍微匆忙写的，所以让其他人稍后来使代码看起来更加专业也是另外一个好处。</p>
<p>但是，如果您进行了很多更改，请运行单元测试UnitTests。打破事情不一定是害怕的事情。通过找到系统的较为脆弱的部分和系统的相关依赖部分（通常是你没注意到的），你就可以了解系统。</p>
<p>一篇关于这项技术的文章是”Make bad code good”，在&lt;JavaWorld <a target="_blank" rel="noopener" href="http://www.javaworld.com/javaworld/jw-03-2001/jw-0323-badcode.html&gt;%E3%80%82">http://www.javaworld.com/javaworld/jw-03-2001/jw-0323-badcode.html&gt;。</a></p>
<h2 id="11-总结和思考"><a href="#11-总结和思考" class="headerlink" title="11. 总结和思考"></a>11. 总结和思考</h2><p>这篇文档觉得很有用，所以就翻译了。其主要的宗旨就是一些小技巧和工具来加速和简化大型工程代码的理解和分析过程。上面大多数的技巧我以前也使用过，但是没有形成系统化的思维，所以这次的总结正好弥补了我在总结这方面技巧的短板。同时，关于其对前置条件(路径)的解释，这个是我以前没有关注过的，觉得是一个不错的技巧，无论多么复杂的代码，最终的目的都是通过一个依次有序的步骤来解决一个问题。所以对于前置条件的分析可以很好的找到代码逻辑中的关键路径。也可以很好的描绘出流程图。</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ol>
<li><a target="_blank" rel="noopener" href="http://wiki.c2.com/?TipsForReadingCode">Tips For Reading Code</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2019/05/08/2019-04-09-Isolation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Robinson">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Road To Excelsior">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/05/08/2019-04-09-Isolation/" class="post-title-link" itemprop="url">数据库中的隔离</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-05-08 15:53:10" itemprop="dateCreated datePublished" datetime="2019-05-08T15:53:10+08:00">2019-05-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-12-18 00:45:26" itemprop="dateModified" datetime="2020-12-18T00:45:26+08:00">2020-12-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><p>在数据库系统中，隔离性表示了事务的完整性对用户和其他系统的可见程度。举个例子，比如说一个用户创建了一个订单，并且已经创建了抬头，但是没有创建订单详情列表，那么这个抬头信息对于其他系统/用户(包含是一个并发操作，像是订单报告)是可见的呢？</p>
<p>一个低级别的隔离增加了更多用户同时对数据的可见性，但是也增加了一些用户可能碰到的并发问题（例如脏读，或者更新丢失的问题）。相反，较高的隔离级别会减少用户可能遇到的并发问题，但需要更多系统资源并增加一个事务阻止另一个事务的可能性。</p>
<p>隔离通常在数据库级别定义为一个属性，用于定义一个操作所做的更改如何/何时对其他操作可见。在较旧的系统上，它可以系统地实现，例如通过使用临时表。在双层系统中，需要事务处理（TP）管理器来维护隔离。在n层系统中（例如多个网站试图预订航班上的最后一个座位），需要结合存储过程和交易管理来提交预订并向客户发送确认。</p>
<p>隔离是ACID（原子性，一致性，隔离性，耐久性）属性之一。</p>
<h2 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h2><p>并发控制包括DBMS中的底层机制，它处理隔离并保证相关的正确性。数据库和存储引擎（见上文）大量使用它来保证并发事务的正确执行，以及（不同的机制）其他DBMS进程的正确性。与事务相关的机制通常将数据库数据访问操作的时间（事务调度）约束为特定的时序模型，这些时序模型通常包含可序列化，和可恢复的特性。约束数据库访问操作执行通常意味着降低的性能（执行速率），因此并发控制机制通常被设计为在约束下提供可能的最佳性能。通常，在不影响正确性的情况下，可序列化属性因为更好的性能需求通常会被破坏，但是，可恢复属性则不会被破坏，因为这个可能会导致数据库完整性被破坏。</p>
<p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Two-phase_locking">两阶段锁定(two-phase locking)</a>是DBMS中最常用的事务并发控制方法，用于提供可序列化和可恢复性的正确性。为了访问数据库对象，事务首先需要获取该对象的锁。根据访问操作类型（例如，读取或写入对象）和锁定类型，如果另一个事务正在为该对象保持锁定，则可以阻止和推迟获取锁定。</p>
<h2 id="读现象"><a href="#读现象" class="headerlink" title="读现象"></a>读现象</h2><p>当事务1读取事务2可能已更改的数据时，ANSI / ISO标准SQL 92引用三种不同的读取现象。</p>
<p>在以下示例中，发生了两个事务。 在第一个中，执行查询1。 然后，在第二个事务中，执行并提交查询2。 最后，在第一个事务中，再次执行查询1。</p>
<p>查询使用了下面的数据库表user：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>age</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>Joe</td>
<td>20</td>
</tr>
<tr>
<td>2</td>
<td>Jill</td>
<td>25</td>
</tr>
</tbody></table>
<h3 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h3><p>当允许事务从已被另一个正在运行的事务修改但尚未提交的行读取数据时，会发生脏读（也称为未提交的依赖关系）。</p>
<p>脏读取与非可重复读取的工作方式类似; 但是，第二个事务不需要为第一个查询提交以返回不同的结果。在我们的示例中，事务2更改了一行，但未提交更改。 然后，事务1读取未提交的数据。 现在，如果事务2回滚其更改（已由事务1读取）或更新对数据库的不同更改，则事务1的记录中的数据视图可能是错误的。</p>
<p><img src="/assets/posts/Isolation/dirty-read.png">{:width=”600px” height=”400px”}</p>
<h3 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h3><p>发生不可重复的读取，当在事务过程中，行被检索两次并且行内的值在读取之间不同。</p>
<p>当执行SELECT时未获取读锁定时，或者在执行SELECT操作时 <strong>释放</strong> 受影响行上获取的锁定时，基于锁的并发控制方法中可能会发生不可重复读取现象。 在<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Multiversion_concurrency_control">多版本并发控制</a>方法下，当受到提交冲突影响的事务必须回滚的要求被放宽时，可能发生不可重复的读取。</p>
<p><img src="/assets/posts/Isolation/non-repeatable-read.png">{:width=”600px” height=”400px”}</p>
<p>在此示例中，事务2成功提交，这意味着它对id为1的行的更改应该变为可见。 但是，事务1已经在该行中看到了不同的年龄值。 在SERIALIZABLE和REPEATABLE READ隔离级别，DBMS对于第二个SELECT必须返回旧值。在READ COMMITTED和READ UNCOMMITTED，DBMS可以返回更新的值; 这是一个不可重复读的操作。</p>
<p>有两种基本策略用于防止不可重复的读取。 第一种是延迟事务2的执行，直到事务1已提交或回滚。 当使用锁时采用此方法，并生成串行调度T1，T2。 一个串行的计划表现出可重复的读取行为。</p>
<p>另外一种策略，在多版本并发控制中使用，T2允许被首先提交，这可以产生更好的并发性能。但是，T1，它开始早于T2，必须继续在数据库的过去版本上运行 - 这是它启动时的快照。当事务1最终尝试提交时，DBMS检查提交事务1的结果是否等于调度T1，T2。 如果是，则可以继续进行事务1。 但是，如果看不到它是等效的，则事务1必须以序列化失败的形式回滚。</p>
<p>在基于锁得并发控制方法中，在可重复读的隔离级别模式下，id = 1的行会被锁住，因此阻塞住查询Query 2直到第一个事务被提交或者回滚。在READ COMMITTED模式下，第二次Query 1被执行时，age字段就会被改变。</p>
<p>在基于多版本的并发控制方法中，在SERIALIZABLE隔离级别中，两个select 查询都会看到事务1开始时得数据库快照版本数据。因此，他们会返回相同的数据。但是，如果事务1也准备update这一行的话，一个序列化失败会出现，并且事务1将会强制回滚。</p>
<p>在READ COMMITTED 隔离级别，每个查询都会看到query开始时得一个快照版本。因此，它们对于更新的行都会看到不同的数据。在这种模式下，不会出现序列化失败错误，因为没有可序列化得承诺，并且不必重试事务1。</p>
<h3 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h3><p>当在事务过程中，新行被另一个事务添加或删除到正在读取的记录时，会发生幻像读取。</p>
<p>在执行SELECT … WHERE操作时未获取范围锁定时，可能会发生这种情况。当事务1重复一个范围的SELECT … WHERE查询时，并且，在两个操作之间，事务2创建（即INSERT）满足该WHERE子句的新行（在目标表中）,幻象读取是一非可重复读的一个特例。</p>
<p><img src="/assets/posts/Isolation/Phantom-read.png">{:width=”800px” height=”400px”}</p>
<p>请注意，事务1执行了两次相同的查询。 如果保持最高级别的隔离，则应同时返回相同的行集，实际上这是在SQL SERIALIZABLE隔离级别操作的数据库中强制要求的。 但是，在较小的隔离级别，第二次可以返回不同的行集。</p>
<p>在SERIALIZABLE隔离模式下，查询1将导致所有年龄在10到30范围内的记录被锁定，因此查询2将阻塞，直到第一个事务被提交。 在REPEATABLE READ模式下，范围不会被锁定，允许插入记录，第二次执行Query 1以在其结果中包含新行。</p>
<h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><p>在DBMS（数据库管理系统）中的四个ACID属性中，隔离属性是最常放松的属性。 在尝试保持最高级别的隔离时，DBMS通常会获取数据锁定，这可能会导致并发性丢失或实现多版本并发控制。 这需要添加逻辑以使应用程序正常运行。</p>
<p>大多数DBMS提供了许多事务隔离级别，这些级别控制选择数据时发生的锁定程度。 对于许多数据库应用程序，可以构造大多数数据库事务以避免需要高隔离级别（例如，SERIALIZABLE级别），从而减少系统的锁定开销。程序员必须仔细分析数据库访问代码，以确保任何放松隔离不会导致难以找到的软件错误。 相反，如果使用更高的隔离级别，则会增加死锁的可能性，这也需要仔细分析和编程技术以避免。</p>
<p>ANSI / ISO SQL标准定义的隔离级别如下所示。</p>
<h3 id="Serializable（可串行化）"><a href="#Serializable（可串行化）" class="headerlink" title="Serializable（可串行化）"></a>Serializable（可串行化）</h3><p>这是最高的隔离级别。</p>
<p>使用基于锁的并发控制DBMS实现，可序列化需要在事务结束时释放读取和写入锁（在所选数据上获取）。 当SELECT查询使用ranged WHERE子句时，也必须获取范围锁，尤其是为了避免幻像读取现象。</p>
<p>使用基于非锁定的并发控制时，不会获取锁定; 但是，如果系统检测到多个并发事务之间的写冲突，则只允许其中一个事务提交。 有关此主题的更多详细信息，请参阅快照隔离。</p>
<p>来自:(第二次非正式审查草案）ISO / IEC 9075：1992，数据库语言SQL- 1992年7月30日：保证隔离级别SERIALIZABLE的并发SQL事务的执行是可序列化的。 可序列化执行被定义为执行并发执行SQL事务的操作，这些操作产生与那些相同SQL事务的某些串行执行相同的效果。 串行执行是指每个SQL事务在下一个SQL事务开始之前执行完成的执行。</p>
<h3 id="Repeatable-reads（可重复读）"><a href="#Repeatable-reads（可重复读）" class="headerlink" title="Repeatable reads（可重复读）"></a>Repeatable reads（可重复读）</h3><p>在此隔离级别中，基于锁的并发控制DBMS实现保持读取和写入锁定（在选定数据上获取），直到事务结束。 但是，不管理范围锁定，因此可能会发生幻像读取。</p>
<p>在这种隔离级别写入偏移是可能得，这种现象是两个不同的写入者（他们之前已经读过他们正在更新的列）允许两个写入表中的同一列，从而导致列具有的数据是 这两笔交易的混合。</p>
<h3 id="Read-committed（读已提交）"><a href="#Read-committed（读已提交）" class="headerlink" title="Read committed（读已提交）"></a>Read committed（读已提交）</h3><p>在此隔离级别中，基于锁的并发控制DBMS实现保持写锁（在所选数据上获取）直到事务结束，但是一旦执行SELECT操作就会释放读锁（因此不可重复读取现象 可以发生在这种隔离级别）。与上一级别一样，不管理范围锁定。</p>
<p>换句话说，read committed是一个隔离级别，它保证读取时提交任何数据。 它只是限制读者看到任何中间的，未提交的，“脏”的读。 它没有任何承诺，如果事务重新发出读取，它将找到相同的数据; 数据在读取后可以自由更改。</p>
<h3 id="Read-uncommitted（读未提交）"><a href="#Read-uncommitted（读未提交）" class="headerlink" title="Read uncommitted（读未提交）"></a>Read uncommitted（读未提交）</h3><p>这是最低的隔离级别。在此级别中，允许脏读，因此一个事务可能会看到其他事务所做的尚未提交的更改。</p>
<p>由于每个隔离级别都比下面的隔离级别更强，因为没有更高的隔离级别允许更低级别的操作禁止，标准允许DBMS以比请求更强的隔离级别运行事务（例如，“读取已提交”） 事务实际上可以在“可重复读”隔离级别执行。</p>
<h2 id="缺省的隔离级别"><a href="#缺省的隔离级别" class="headerlink" title="缺省的隔离级别"></a>缺省的隔离级别</h2><p>不同DBMS的默认隔离级别变化很大。 大多数具有事务的数据库允许用户设置任何隔离级别。 在执行SELECT语句以获取锁时，某些DBMS还需要其他语法（例如，SELECT … FOR UPDATE以获取访问行上的独占写锁）。</p>
<p>但是，上述定义被批评为含糊不清，并且没有准确反映许多数据库提供的隔离：</p>
<blockquote>
<p>本文展示了定义隔离级别的异常方法中的一些缺点。 三种ANSI现象是模棱两可的，即使在他们最松散的解释中也不排除某些异常行为……这会导致一些反直觉的结果。 特别是，基于锁的隔离级别具有与ANSI等效的不同的特性。 这令人不安，因为商业数据库系统通常使用锁定实现。 另外，ANSI现象不区分商业系统中流行的多种类型的隔离级别行为。</p>
</blockquote>
<p>还有其他关于ANSI SQL的隔离定义的批评，因为它鼓励实现者做“坏事”：</p>
<blockquote>
<p>…它假设锁定模式用于并发控制，而不是乐观或多版本并发方案，它依赖于微妙的方式。这意味着所提出的语义是不明确的。</p>
</blockquote>
<h2 id="隔离级别，读现象，以及锁"><a href="#隔离级别，读现象，以及锁" class="headerlink" title="隔离级别，读现象，以及锁"></a>隔离级别，读现象，以及锁</h2><p>Isolation levels vs read phenomena<br><img src="/assets/posts/Isolation/isolation-level.png">{:width=”600px” height=”200px”}</p>
<p>如果所有事务都使用可重复读取或可序列化操作，则不会发生丢失更新。</p>
<p>Anomaly Serializable与Serializable不同。也就是说，Serializable计划应该没有所有三种现象类型，这是必要的，但还不够。</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Isolation_(database_systems)#Non-repeatable_reads">Isolation (database systems)</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2019/05/08/2019-01-07-plans-in-2019/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Robinson">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Road To Excelsior">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/05/08/2019-01-07-plans-in-2019/" class="post-title-link" itemprop="url">Plans in 2019</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-05-08 15:53:10" itemprop="dateCreated datePublished" datetime="2019-05-08T15:53:10+08:00">2019-05-08</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><p>读书，读完一本勾一本，觉得好的做标记再读。</p>
<h2 id="1-书单"><a href="#1-书单" class="headerlink" title="1. 书单"></a>1. 书单</h2><h3 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a>计算机基础</h3><ul>
<li>《计算机科学导论》</li>
<li>《计算机操作系统》</li>
<li>《操作系统原理及应用》</li>
</ul>
<h3 id="Java-基础和进阶"><a href="#Java-基础和进阶" class="headerlink" title="Java 基础和进阶"></a>Java 基础和进阶</h3><ul>
<li>《疯狂Java讲义》</li>
<li>《Java核心基础卷1/2》</li>
<li>《Java编程思想》</li>
<li>《Java 8实战》</li>
<li>《jls11》</li>
<li>《Effective Java》</li>
<li>《Java网络编程 第四版》</li>
<li>《Java性能优化权威指南》</li>
</ul>
<h3 id="Java-并发编程"><a href="#Java-并发编程" class="headerlink" title="Java 并发编程"></a>Java 并发编程</h3><ul>
<li>《Java多线程编程核心技术》</li>
<li>《Java多线程编程实战指南》</li>
<li>《实战Java高并发程序设计》</li>
<li>《Java并发编程实战》</li>
<li>《Java并发编程的艺术》</li>
</ul>
<h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><ul>
<li>《设计模式之禅》</li>
</ul>
<h3 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h3><ul>
<li>《深入理解Java虚拟机(第二版)》</li>
<li>《jvms11》</li>
<li>《hotspot》</li>
<li>《虚拟机参数》</li>
</ul>
<h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><ul>
<li>《Redis入门指南》</li>
<li>《Redis实战中文版》</li>
<li>《Redis设计与实现》</li>
<li>《深入分布式缓存，从原理到实践》</li>
<li>《Redis深度历险：核心原理和应用实践》</li>
<li>《redis设计与实现 第二版》</li>
</ul>
<h3 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h3><ul>
<li>《Mysql数据库应用从入门到精通》</li>
<li>《sql 学习指南》</li>
<li>《数据库索引设计与优化》</li>
<li>《高性能mysql》</li>
<li>《Mysql技术内幕- Innodb 存储引擎》</li>
<li>《分布式数据架构及企业实践-基于Mysql中间件》</li>
<li><a target="_blank" rel="noopener" href="https://www.mysql.com/">Mysql官网</a></li>
</ul>
<h3 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h3><ul>
<li>《Maven实战》</li>
</ul>
<h3 id="Shiro"><a href="#Shiro" class="headerlink" title="Shiro"></a>Shiro</h3><ul>
<li>《跟我学shiro教程》</li>
</ul>
<h3 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h3><ul>
<li>《MongoDB 权威指南（第二版）》</li>
</ul>
<h3 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h3><ul>
<li>《Elasticsearch大数据搜索引擎》</li>
<li>《Elasticsearch服务器开发（第二版）》</li>
<li>《Elasticsearch权威指南（中文版）》</li>
<li>《深入理解Elasticsearch 原书第二版》</li>
</ul>
<h3 id="消息中间件"><a href="#消息中间件" class="headerlink" title="消息中间件"></a>消息中间件</h3><ul>
<li>《分布式消息中间件实践》</li>
</ul>
<h3 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h3><ul>
<li>《RabbitMQ实战指南》</li>
<li>《RabbitMQ实战 高效部署分布式消息队列》</li>
<li>《RabbitMQ 官网》</li>
</ul>
<h3 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h3><ul>
<li>《RocketMQ技术内幕》</li>
<li>《RocketMQ实战与原理解析》</li>
</ul>
<h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><ul>
<li>《Linux命令行与Linux脚本编程大全》</li>
<li>《Unix环境高级编程》</li>
<li>《Unix网络编程》</li>
<li>《Linux系统编程手册》</li>
</ul>
<h3 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h3><ul>
<li>《Netty权威指南》</li>
</ul>
<h3 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h3><ul>
<li>《Nginx高性能Web服务器详解》</li>
<li>《Nginx高性能Web服务器实战教程》</li>
<li>《深入理解Nginx模块开发与架构解析第二版》</li>
</ul>
<h3 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h3><ul>
<li>《精通Spring 4.x++ 企业应用开发实战》</li>
<li>《Spring源码深度解析》</li>
<li>《Spring揭秘》</li>
</ul>
<h3 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a>Spring Boot</h3><ul>
<li>《Spring Boot 2 精髓》</li>
<li>《深入实践Spring Boot》</li>
<li>《Spring Boot 实战》</li>
</ul>
<h3 id="Spring-Cloud"><a href="#Spring-Cloud" class="headerlink" title="Spring Cloud"></a>Spring Cloud</h3><ul>
<li>《Spring Cloud 与 Docker 微服务架构实战》</li>
<li>《Spring Cloud 微服务实战》</li>
<li>《深入理解Spring Cloud 与微服务构建》</li>
<li>《Spring Cloud 微服务架构进阶》</li>
</ul>
<h3 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h3><ul>
<li>《Mybatis 从入门到精通》</li>
<li>《深入浅出Mybatis 技术原理与实战》</li>
</ul>
<h3 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h3><ul>
<li>《Zookeeper 分布式过程协同技术详解》</li>
</ul>
<h3 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a>Dubbo</h3><ul>
<li><a target="_blank" rel="noopener" href="https://dubbo.incubator.apache.org/zh-cn/">Dubbo官方文档</a></li>
</ul>
<h3 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h3><ul>
<li>《Tomcat 与Java Web开发技术详解》</li>
<li>《Tomcat 架构解析》</li>
<li>《tomcat 内核设计剖析》</li>
</ul>
<h3 id="数据结构和算法"><a href="#数据结构和算法" class="headerlink" title="数据结构和算法"></a>数据结构和算法</h3><ul>
<li>《Java 数据结构和算法》</li>
</ul>
<h3 id="Java-编程规范"><a href="#Java-编程规范" class="headerlink" title="Java 编程规范"></a>Java 编程规范</h3><ul>
<li>《阿里巴巴Java 开发手册》<ul>
<li>状态：<code>完成</code>{:.success}</li>
<li>点评：一个小册子，但非常有指导性，可以收藏，时不时浏览一次即可。</li>
</ul>
</li>
<li>《重构，改善既有代码的设计》</li>
<li>《敏捷软件开发》</li>
<li>《单元测试之道 Java版》<ul>
<li>状态：<code>完成</code>{:.success}</li>
<li>点评：对于单元测试非常全面的一本原则性指导的书籍，以较为清晰的逻辑叙述了单元测试的内容，如果有时间，可以再读一遍。</li>
</ul>
</li>
</ul>
<h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><ul>
<li>《图解HTTP》</li>
<li>《图解TCP/IP》</li>
<li>《TCP/IP详解》</li>
</ul>
<h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><ul>
<li>《Design Data Intensive Applications》<ul>
<li>状态：<code>在读</code>{:.info}</li>
<li>点评：非常好的一本书，但是对于无实际项目经验的人，不推荐，里面的一些知识，需要有着实际的项目经验才能把控的全面。</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2019/05/08/2019-04-19-How-to-design-a-good-API/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Robinson">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Road To Excelsior">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/05/08/2019-04-19-How-to-design-a-good-API/" class="post-title-link" itemprop="url">How to design a good API and why it matters?</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-05-08 15:53:10" itemprop="dateCreated datePublished" datetime="2019-05-08T15:53:10+08:00">2019-05-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-12-18 00:46:40" itemprop="dateModified" datetime="2020-12-18T00:46:40+08:00">2020-12-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h1><h2 id="1-1-为什么接口设计很重要？"><a href="#1-1-为什么接口设计很重要？" class="headerlink" title="1.1.为什么接口设计很重要？"></a>1.1.为什么接口设计很重要？</h2><ul>
<li>API可能是一个公司最重要的资产<ul>
<li>用户花了很多心血：购买，使用，学习等</li>
<li>停止使用API的成本可能很高</li>
<li>成功的公开API能够抓住用户</li>
</ul>
</li>
<li>API也可能是公司最大的责任之一<ul>
<li>糟糕的API会导致无休止的技术支持需求</li>
</ul>
</li>
<li>公开的API是永久性的 - 只有一次机会保证其正确</li>
</ul>
<h2 id="1-2-为何接口设计对于你很重要？"><a href="#1-2-为何接口设计对于你很重要？" class="headerlink" title="1.2.为何接口设计对于你很重要？"></a>1.2.为何接口设计对于你很重要？</h2><ul>
<li>如果你是程序员，你就是一个API 设计者<ul>
<li>好的代码是模块化的 - 每个模块有一个API</li>
</ul>
</li>
<li>有用的模块往往会被重用<ul>
<li>一旦模块有用户，则不能随意更改API</li>
<li>良好的可重用模块是企业资产</li>
</ul>
</li>
<li>在API设计上进行思考可提高代码质量</li>
</ul>
<h2 id="1-3-优秀的API的特点"><a href="#1-3-优秀的API的特点" class="headerlink" title="1.3.优秀的API的特点"></a>1.3.优秀的API的特点</h2><ul>
<li>易于学习</li>
<li>易于使用，即便没有文档</li>
<li>很难被误用</li>
<li>易于阅读和维护使用它的代码</li>
<li>足够强大到满足需求</li>
<li>易于扩展</li>
<li>适合受众</li>
</ul>
<h1 id="2-概况"><a href="#2-概况" class="headerlink" title="2.概况"></a>2.概况</h1><h2 id="2-1-API设计的流程"><a href="#2-1-API设计的流程" class="headerlink" title="2.1.API设计的流程"></a>2.1.API设计的流程</h2><h3 id="2-1-1-以合理的怀疑态度收集需求"><a href="#2-1-1-以合理的怀疑态度收集需求" class="headerlink" title="2.1.1 以合理的怀疑态度收集需求"></a>2.1.1 以合理的怀疑态度收集需求</h3><ul>
<li>通常你会得到建议的解决方案<ul>
<li>更好的方案可能存在</li>
</ul>
</li>
<li>你的工作是提取出真实的需求<ul>
<li>应采用用户案例的形式</li>
</ul>
</li>
<li>构建一个更加通用的API是更简单，且更有价值的</li>
</ul>
<h3 id="2-1-2-以简短的细则开始-1页足够"><a href="#2-1-2-以简短的细则开始-1页足够" class="headerlink" title="2.1.2 以简短的细则开始 - 1页足够"></a>2.1.2 以简短的细则开始 - 1页足够</h3><ul>
<li>在这个阶段，敏捷是胜过完整性的</li>
<li>将细则在尽可能多的人之间传播<ul>
<li>听取他们的输入，并且慎重对待</li>
</ul>
</li>
<li>如果保持细则简短，则易于修改</li>
<li>持续更新这个细则</li>
</ul>
<h3 id="2-1-3-尽早，经常写入你的API"><a href="#2-1-3-尽早，经常写入你的API" class="headerlink" title="2.1.3 尽早，经常写入你的API"></a>2.1.3 尽早，经常写入你的API</h3><ul>
<li>在实现之前开始设计API<ul>
<li>可以避免会被丢弃的实现</li>
</ul>
</li>
<li>在细则完全确定之前开始设计API<ul>
<li>可以避免会被丢弃的细则</li>
</ul>
</li>
<li>持续地更新你的API<ul>
<li>避免令人讨厌的惊喜</li>
<li>代码依靠样例和单元测试存活</li>
</ul>
</li>
</ul>
<h3 id="2-1-4-写入SPI-Service-Provider-Interface-更为重要"><a href="#2-1-4-写入SPI-Service-Provider-Interface-更为重要" class="headerlink" title="2.1.4 写入SPI(Service Provider Interface)更为重要"></a>2.1.4 写入SPI(Service Provider Interface)更为重要</h3><ul>
<li>Service Provider Interface(SPI) 关于SPI介绍，参见: <a target="_blank" rel="noopener" href="https://juejin.im/post/5af952fdf265da0b9e652de3">JavaSPI机制介绍</a><ul>
<li>插件接口，可支持多种实现</li>
</ul>
</li>
<li>在发布前，编写多个插件<ul>
<li>如果只写一个插件，可能不能支持另外一个</li>
<li>如果写两个插件，可能支持更多的（需求）</li>
<li>如果写三个插件，可能就能正常工作</li>
</ul>
</li>
</ul>
<h3 id="2-1-5-维护现实的期望"><a href="#2-1-5-维护现实的期望" class="headerlink" title="2.1.5 维护现实的期望"></a>2.1.5 维护现实的期望</h3><ul>
<li>大多数API设计都过度约束了<ul>
<li>你不能使每个人满意</li>
<li>只需要平等的对待每一个人的需求</li>
</ul>
</li>
<li>期望会犯错误<ul>
<li>一段时间的真实调用会将这些错误冲刷掉</li>
<li>期待能持续发展API</li>
</ul>
</li>
</ul>
<h2 id="2-2-设计原则"><a href="#2-2-设计原则" class="headerlink" title="2.2.设计原则"></a>2.2.设计原则</h2><h3 id="2-2-1-API应该只做一件事情，并且做好这件事情"><a href="#2-2-1-API应该只做一件事情，并且做好这件事情" class="headerlink" title="2.2.1 API应该只做一件事情，并且做好这件事情"></a>2.2.1 API应该只做一件事情，并且做好这件事情</h3><ul>
<li>API的功能应该非常容易解释<ul>
<li>如果很难命名API，这可能是一个坏的标志</li>
<li>好的命名驱动着开发</li>
<li>易于拆分和合并模块</li>
</ul>
</li>
</ul>
<h3 id="2-2-2-API应该尽可能的小"><a href="#2-2-2-API应该尽可能的小" class="headerlink" title="2.2.2 API应该尽可能的小"></a>2.2.2 API应该尽可能的小</h3><ul>
<li>API应该满足它的需求</li>
<li>当存在疑问时，放弃这个API<ul>
<li>功能，方法，类，参数等</li>
<li><code>你永远可以添加，但是决不能移除</code>{:.error}</li>
</ul>
</li>
<li>概念比实体更加重要</li>
<li>寻找良好的能效比</li>
</ul>
<h3 id="2-2-3-实现不应该影响API"><a href="#2-2-3-实现不应该影响API" class="headerlink" title="2.2.3 实现不应该影响API"></a>2.2.3 实现不应该影响API</h3><ul>
<li>实现细节<ul>
<li>会迷惑用户</li>
<li>限制改变实现的自由</li>
</ul>
</li>
<li>了解什么是实现细节<ul>
<li>不要过度指定方法的行为</li>
<li>例子：不要指定hash函数的细节</li>
<li>所有可调整的参数都是可疑的</li>
</ul>
</li>
<li>不要让实现的细节<code>&quot;泄露&quot;</code>{:.error}到API</li>
</ul>
<h3 id="2-2-4-最小化所有对象的可访问性"><a href="#2-2-4-最小化所有对象的可访问性" class="headerlink" title="2.2.4 最小化所有对象的可访问性"></a>2.2.4 最小化所有对象的可访问性</h3><ul>
<li>使类和成员变量尽可能是Private的</li>
<li>公有类不应该有公有成员变量（常量除外）</li>
<li>这样可以最大化信息隐藏</li>
<li>允许独立使用，理解，构建，测试和调试模块</li>
</ul>
<h3 id="2-2-5-命名很重要-API是一种小语言"><a href="#2-2-5-命名很重要-API是一种小语言" class="headerlink" title="2.2.5 命名很重要 - API是一种小语言"></a>2.2.5 命名很重要 - API是一种小语言</h3><ul>
<li>名称需要最大化自解释性<ul>
<li>避免神秘的缩写</li>
</ul>
</li>
<li>保持一致 - 相同的单词意味着相同的事情<ul>
<li>这个原则是横跨所有API的，跨平台的</li>
</ul>
</li>
<li>定期争取对称性</li>
<li>代码需要像散文一样</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (car.speed() &gt; <span class="number">2</span> * SPEED_LIMIT)</span><br><span class="line">  generateAlert(<span class="string">&quot;Watch out for cops!&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="2-2-6-文档很重要"><a href="#2-2-6-文档很重要" class="headerlink" title="2.2.6 文档很重要"></a>2.2.6 文档很重要</h3><blockquote>
<p>重用是说起来容易做起来难的事情。实现重用需要好的设计以及非常好的文档。即便我们看到好的设计（这是不常见的），如果没有好的文档，也不会实现目标中的代码重用。</p>
</blockquote>
<h3 id="2-2-7-文档的宗旨"><a href="#2-2-7-文档的宗旨" class="headerlink" title="2.2.7 文档的宗旨"></a>2.2.7 文档的宗旨</h3><ul>
<li>为每个类，接口，方法，构造器，参数以及异常编写文档<ul>
<li>类：这个类实例代表什么</li>
<li>方法：方法和客户端之间的契约<ul>
<li>前置条件，后置条件，副作用</li>
</ul>
</li>
<li>参数：表明单位，类型，所有权</li>
</ul>
</li>
<li>非常仔细地记录状态空间</li>
</ul>
<h3 id="2-2-8-考虑API设计决策的性能后果"><a href="#2-2-8-考虑API设计决策的性能后果" class="headerlink" title="2.2.8 考虑API设计决策的性能后果"></a>2.2.8 考虑API设计决策的性能后果</h3><ul>
<li>错误的决策会影响性能<ul>
<li>使类型是可变的</li>
<li>提供构造器而不是静态工厂，参见：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/8b6f21cf0ca3">考虑用静态工厂方法代替构造器</a></li>
<li>使用实现类型而不是接口类型，参见：<a target="_blank" rel="noopener" href="https://blog.csdn.net/summerxiachen/article/details/79733800">实现类型vs 接口类型</a></li>
</ul>
</li>
<li>不要包装API以获得性能<ul>
<li>潜在的性能问题可能会被解决，但是造成的后遗症是永久的</li>
<li>好的设计通常拥有优秀的性能</li>
</ul>
</li>
</ul>
<h3 id="2-2-9-API设计决策对性能的影响是真实和永久的"><a href="#2-2-9-API设计决策对性能的影响是真实和永久的" class="headerlink" title="2.2.9 API设计决策对性能的影响是真实和永久的"></a>2.2.9 API设计决策对性能的影响是真实和永久的</h3><ul>
<li>Component.getSize()返回 Dimension</li>
<li>Dimension是可变的，每次调用getSize都会分配一个Dimension，所以造成了百万次无用的对象分配</li>
<li>替代版本在1.2添加，但是旧的客户端代码依旧很慢</li>
</ul>
<h3 id="2-2-10-API必须与平台和平共存"><a href="#2-2-10-API必须与平台和平共存" class="headerlink" title="2.2.10 API必须与平台和平共存"></a>2.2.10 API必须与平台和平共存</h3><ul>
<li>做到习惯做法<ul>
<li>遵循标准的命名传统</li>
<li>避免使用过时的参数和返回类型</li>
<li>模仿核心API和语言中的模式</li>
</ul>
</li>
<li>利用对API友好的特性<ul>
<li>泛型，变量，枚举，默认参数</li>
</ul>
</li>
<li>了解并避免API陷阱和缺陷<ul>
<li>Finalizers, public static final arrays</li>
</ul>
</li>
</ul>
<h2 id="2-3-类设计"><a href="#2-3-类设计" class="headerlink" title="2.3.类设计"></a>2.3.类设计</h2><h3 id="2-3-1-最小化可变性"><a href="#2-3-1-最小化可变性" class="headerlink" title="2.3.1 最小化可变性"></a>2.3.1 最小化可变性</h3><ul>
<li>除非有必要，否则类应该是不可变的<ul>
<li>优势：简单，线程安全，可重用</li>
<li>劣势：对于每个值都有独立的对象</li>
</ul>
</li>
<li>如果是可变的，保证状态空间尽可能小，定义明确的<ul>
<li>明确何时调用哪种方法是合法的</li>
</ul>
</li>
</ul>
<p>正面案例：TimerTask<br>反面案例：Date, Calendar</p>
<h3 id="2-3-2-只在有意义时创建子类"><a href="#2-3-2-只在有意义时创建子类" class="headerlink" title="2.3.2 只在有意义时创建子类"></a>2.3.2 只在有意义时创建子类</h3><ul>
<li>子类意味着可替代性<ul>
<li>只在存在一对多的(is-a)的关系时运行创建子类</li>
<li>否则，使用组合</li>
</ul>
</li>
<li>公共类不应该为了便于实现，而为其他公共类创建子类</li>
</ul>
<p>反面案例：Stack extends Vector<br>        Properties extends Hashtable<br>正面案例：Set extends Collection</p>
<h3 id="2-3-3-对于继承需要设计和文档，否则就禁止"><a href="#2-3-3-对于继承需要设计和文档，否则就禁止" class="headerlink" title="2.3.3 对于继承需要设计和文档，否则就禁止"></a>2.3.3 对于继承需要设计和文档，否则就禁止</h3><ul>
<li>继承违反了封装原则<ul>
<li>子类对于父类的实现细节是敏感的</li>
</ul>
</li>
<li>如果你允许创建子类，则文档自用<ul>
<li>方法如何相互使用</li>
</ul>
</li>
<li>保守政策：所有的具体类都是final的 参见: <a target="_blank" rel="noopener" href="http://www.importnew.com/7553.html">深入理解Java中的final关键字</a></li>
</ul>
<p>反面案例：Many concrete classes in J2SE libraries<br>正面案例：AbstractSet, AbstractMap</p>
<h2 id="2-4-方法设计"><a href="#2-4-方法设计" class="headerlink" title="2.4.方法设计"></a>2.4.方法设计</h2><h3 id="2-4-1-不要让客户端做任何模块可以做的事情"><a href="#2-4-1-不要让客户端做任何模块可以做的事情" class="headerlink" title="2.4.1 不要让客户端做任何模块可以做的事情"></a>2.4.1 不要让客户端做任何模块可以做的事情</h3><ul>
<li>减少对样板代码的需求<ul>
<li>通常可以通过剪切-粘贴的方式完成</li>
<li>丑陋，误导，且容易出错</li>
</ul>
</li>
</ul>
<p>样例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.w3c.dom.*;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> javax.xml.transform.*;</span><br><span class="line"><span class="keyword">import</span> javax.xml.transform.dom.*;</span><br><span class="line"><span class="keyword">import</span> javax.xml.transform.stream.*;</span><br><span class="line"> <span class="comment">// DOM code to write an XML document to a specified output stream.</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">writeDoc</span><span class="params">(Document doc, OutputStream out)</span><span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    Transformer t = TransformerFactory.newInstance().newTransformer();</span><br><span class="line">    t.setOutputProperty(OutputKeys.DOCTYPE_SYSTEM, doc.getDoctype().getSystemId());</span><br><span class="line">    t.transform(<span class="keyword">new</span> DOMSource(doc), <span class="keyword">new</span> StreamResult(out));</span><br><span class="line">  &#125; <span class="keyword">catch</span>(TransformerException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(e); <span class="comment">// Can’t happen!</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码，关于javax.xml模块的相关客户端代码可以移除。</p>
<h3 id="2-4-2-不要违反最小惊讶原则"><a href="#2-4-2-不要违反最小惊讶原则" class="headerlink" title="2.4.2 不要违反最小惊讶原则"></a>2.4.2 不要违反最小惊讶原则</h3><ul>
<li>API的使用不应该被其行为惊讶<ul>
<li>这个原则值得额外的实现成本</li>
<li>这个原则也值得降低性能</li>
</ul>
</li>
</ul>
<p>反面样例：<br><img src="/assets/posts/api-design/Thread.png"></p>
<h3 id="2-4-3-为所有可访问字段数据提供String-形式的程序访问方法"><a href="#2-4-3-为所有可访问字段数据提供String-形式的程序访问方法" class="headerlink" title="2.4.3 为所有可访问字段数据提供String 形式的程序访问方法"></a>2.4.3 为所有可访问字段数据提供String 形式的程序访问方法</h3><ul>
<li>否则，客户端需要解析出字符串<ul>
<li>对于客户端来说是痛苦的</li>
<li>更糟糕的是，将字符串格式变成了事实上的API</li>
</ul>
</li>
</ul>
<p>正反面样例：<br><img src="/assets/posts/api-design/Throwable.png"></p>
<h3 id="2-4-4-慎重地进行重载"><a href="#2-4-4-慎重地进行重载" class="headerlink" title="2.4.4 慎重地进行重载"></a>2.4.4 慎重地进行重载</h3><ul>
<li>避免模糊的重载行为<ul>
<li>对于同一个实际行为写了多个重载</li>
<li>保守原则：相同数目的参数不要有两个（重载方法）</li>
</ul>
</li>
<li>仅仅因为你可以并不代表你应该这样做<ul>
<li>这个时候一般使用另一个名称会更好</li>
</ul>
</li>
<li>如果你提供了模糊的重载，保证相同的参数产生相同的行为</li>
</ul>
<p>反面案例：<br><img src="/assets/posts/api-design/TreeSet.png"></p>
<h3 id="2-4-5-使用合适的参数类型和返回类型"><a href="#2-4-5-使用合适的参数类型和返回类型" class="headerlink" title="2.4.5 使用合适的参数类型和返回类型"></a>2.4.5 使用合适的参数类型和返回类型</h3><ul>
<li>对于输入，相较与类，鼓励使用接口类型<ul>
<li>提供了灵活性，性能</li>
</ul>
</li>
<li>使用最具体的输入参数类型<ul>
<li>将错误从运行时移到了编译时</li>
</ul>
</li>
<li>如果存在更合适的类型，不要使用String<ul>
<li>String是笨重的，易出错的，慢的</li>
</ul>
</li>
<li>不要使用float类型用于货币价值<ul>
<li>双浮点数容易造成不准确的结果</li>
</ul>
</li>
<li>使用double(64 bits)而不是float(32 bit)<ul>
<li>精度丢失是真实的，而性能并没有提升多少</li>
</ul>
</li>
</ul>
<h3 id="2-4-6-在方法中保持一致的参数顺序"><a href="#2-4-6-在方法中保持一致的参数顺序" class="headerlink" title="2.4.6 在方法中保持一致的参数顺序"></a>2.4.6 在方法中保持一致的参数顺序</h3><ul>
<li>特别是在参数类型相同的情况下<br>反面案例:<br><img src="/assets/posts/api-design/copy.png"><br>正面案例:<br><img src="/assets/posts/api-design/parameter.png"></li>
</ul>
<h3 id="2-4-7-避免长的参数列表"><a href="#2-4-7-避免长的参数列表" class="headerlink" title="2.4.7 避免长的参数列表"></a>2.4.7 避免长的参数列表</h3><ul>
<li>三个或更少的参数比较理想<ul>
<li>如果过多，用户就需要去参考文档了</li>
</ul>
</li>
<li>对于过长的，且类型相同的参数列表是有伤害性的<ul>
<li>程序员可能错误地转置参数</li>
<li>程序可能会正常的编译，运行，但是行为错误了</li>
</ul>
</li>
<li>两种缩短参数列表的方法<ul>
<li>将方法拆分</li>
<li>创建helper class来存储参数<br>反面案例：<br><img src="/assets/posts/api-design/toolongparameter.png"></li>
</ul>
</li>
</ul>
<h3 id="2-4-8-避免返回需要异常处理的返回值"><a href="#2-4-8-避免返回需要异常处理的返回值" class="headerlink" title="2.4.8  避免返回需要异常处理的返回值"></a>2.4.8  避免返回需要异常处理的返回值</h3><ul>
<li>返回0长度的列表，或空集合，而不是null<br>反面样例：<br><img src="/assets/posts/api-design/nullexamper.png"></li>
</ul>
<h2 id="2-5-异常设计"><a href="#2-5-异常设计" class="headerlink" title="2.5.异常设计"></a>2.5.异常设计</h2><h3 id="2-5-1-抛出异常以表明特殊情况"><a href="#2-5-1-抛出异常以表明特殊情况" class="headerlink" title="2.5.1 抛出异常以表明特殊情况"></a>2.5.1 抛出异常以表明特殊情况</h3><ul>
<li>不要强迫客户端使用异常来控制流程</li>
</ul>
<p>反面案例:<br><img src="/assets/posts/api-design/flowControl.png"></p>
<ul>
<li>相反，不要无声地失败</li>
</ul>
<p>反面案例：<br><img src="/assets/posts/api-design/ThreadGroup.png"></p>
<h3 id="2-5-2-赞成未受检的异常"><a href="#2-5-2-赞成未受检的异常" class="headerlink" title="2.5.2 赞成未受检的异常"></a>2.5.2 赞成未受检的异常</h3><ul>
<li>Checked - 客户端必须采用恢复措施</li>
<li>Unchecked - 程序错误</li>
<li>过度使用受检异常会导致样板代码(boilerplate)</li>
</ul>
<p>反面样例：<br><img src="/assets/posts/api-design/uncheck.png"></p>
<h3 id="2-5-3-需要在异常中保存失败的捕捉信息"><a href="#2-5-3-需要在异常中保存失败的捕捉信息" class="headerlink" title="2.5.3 需要在异常中保存失败的捕捉信息"></a>2.5.3 需要在异常中保存失败的捕捉信息</h3><ul>
<li>便于诊断和恢复</li>
<li>对于未受检异常，消息就足够了</li>
<li>对于受检异常，请提供访问者信息</li>
</ul>
<h2 id="2-6-重构API设计"><a href="#2-6-重构API设计" class="headerlink" title="2.6.重构API设计"></a>2.6.重构API设计</h2><p>向量中的子列表操作：<br><img src="/assets/posts/api-design/vector.png"></p>
<ul>
<li>不是很强大 - 只支持搜索</li>
<li>没有文档的话，很难使用</li>
</ul>
<p>重构这个操作：<br><img src="/assets/posts/api-design/subList.png"></p>
<ul>
<li>非常强大 - 支持所有的操作</li>
<li>使用接口，降低了概念的重量<ul>
<li>提高了概念的能效比</li>
</ul>
</li>
<li>没有文档，也能简单使用</li>
</ul>
<h1 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h1><ul>
<li>API设计是一个严肃且有回报的工艺<ul>
<li>改善了很多编程者，终端用户，公司等</li>
</ul>
</li>
<li>这篇文档涵盖了一些该工艺的启发式方法<ul>
<li>不要无脑附和</li>
<li>在没有合理的原因的情况下，也不要违背</li>
</ul>
</li>
<li>API设计很难<ul>
<li>它不是一个单独的过程</li>
<li>完美是不存在的，但是可以持续改进</li>
</ul>
</li>
</ul>
<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ol>
<li><a href="/assets/posts/api-design/a.pdf">How to design a good API and why it matters</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2019/05/08/2019-04-21-Unit-Test/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Robinson">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Road To Excelsior">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/05/08/2019-04-21-Unit-Test/" class="post-title-link" itemprop="url">单元测试</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-05-08 15:53:10" itemprop="dateCreated datePublished" datetime="2019-05-08T15:53:10+08:00">2019-05-08</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-单元测试"><a href="#1-单元测试" class="headerlink" title="1.单元测试"></a>1.单元测试</h2><h3 id="1-1-什么是单元测试？"><a href="#1-1-什么是单元测试？" class="headerlink" title="1.1 什么是单元测试？"></a>1.1 什么是单元测试？</h3><p><strong>单元测试</strong>是开发者编写的一小段代码，用于检测被测代码的一个很小的、很明确的的功能是否正常。</p>
<h3 id="1-2-一般原则"><a href="#1-2-一般原则" class="headerlink" title="1.2 一般原则"></a>1.2 一般原则</h3><ol>
<li>测试任何可能失败的地方。</li>
<li>测试任何已经失败的地方。</li>
<li>对于新加的代码，在被证明正确之前，都可能是有问题的。</li>
<li>至少编写和产品代码一样多的测试代码。</li>
<li>针对每次编译都做局部测试。</li>
<li>签入代码之前做全局测试。</li>
</ol>
<h2 id="2-使用Junit来进行单元测试"><a href="#2-使用Junit来进行单元测试" class="headerlink" title="2.使用Junit来进行单元测试"></a>2.使用Junit来进行单元测试</h2><p>测试代码<code>必须</code>{:.error}要做以下这几件事情：</p>
<ul>
<li>准备测试所需要的各种条件（创建所有必须的对象，分配必要的资源等等）。</li>
<li>调用要测试的方法。</li>
<li>验证被测试方法的行为和期望是否一致。</li>
<li>完成后清理各种资源</li>
</ul>
<h2 id="3-测试哪些内容：Right-BICEP"><a href="#3-测试哪些内容：Right-BICEP" class="headerlink" title="3.测试哪些内容：Right-BICEP"></a>3.测试哪些内容：Right-BICEP</h2><h3 id="3-1-Right-结果是否正确？"><a href="#3-1-Right-结果是否正确？" class="headerlink" title="3.1 Right-结果是否正确？"></a>3.1 Right-结果是否正确？</h3><ul>
<li>如果代码能够运行正确，我要怎么才知道它是正确的呢？</li>
<li>使用数据文件。</li>
</ul>
<h3 id="3-2-B-是否所有的边界条件都是正确的？"><a href="#3-2-B-是否所有的边界条件都是正确的？" class="headerlink" title="3.2 B-是否所有的边界条件都是正确的？"></a>3.2 B-是否所有的边界条件都是正确的？</h3><p>一个想到可能得边界条件的简单办法是记住短语CORRECT。</p>
<ul>
<li>Conformance（一致性） – 值是否和预期一致。</li>
<li>Ordering（顺序性）– 值是否如应该的那样，是有序或者无序的。</li>
<li>Range（区间性） – 值是否位于合理的最小值和最大值之内。</li>
<li>Reference（依赖性）– 代码是否引用了一些不在代码本身控制范围之内的外部资源。</li>
<li>Existence（存在性） – 值是否存在（例如，是否是非null, 非0， 在一个集合中等等）。</li>
<li>Cardinatity(基数性) – 是否恰好有足够的值？</li>
<li>Time（相对或者绝对的时间性）– 所有事情的发生是否是有序的？是否是在正确的时刻？是否恰好及时？</li>
</ul>
<h3 id="3-3-I-能查一下反向关联吗？"><a href="#3-3-I-能查一下反向关联吗？" class="headerlink" title="3.3 I-能查一下反向关联吗？"></a>3.3 I-能查一下反向关联吗？</h3><p>对于一些方法，我们可以使用反向的逻辑关系来验证它们。<br>需要注意的是：当你同时编写原方法和它的反向测试时，一些bug可能会被在两个函数中都出现的错误所掩盖。在可能的情况下，应该使用不同的原理来编写反向测试。</p>
<h3 id="3-4-C-能用其他手段交叉检查一下结果吗？"><a href="#3-4-C-能用其他手段交叉检查一下结果吗？" class="headerlink" title="3.4 C-能用其他手段交叉检查一下结果吗？"></a>3.4 C-能用其他手段交叉检查一下结果吗？</h3><p>你同样可能使用其他的手段来交叉检查函数的结果。比如使用一些比较弱的版本来检查我们新写的新版本函数效果。</p>
<h3 id="3-5-E-你是否可以强制错误条件的发生？"><a href="#3-5-E-你是否可以强制错误条件的发生？" class="headerlink" title="3.5 E-你是否可以强制错误条件的发生？"></a>3.5 E-你是否可以强制<strong>错误条件</strong>的发生？</h3><p>使用Mock对象来模拟错误条件来产生各种条件：</p>
<ul>
<li>内存耗光</li>
<li>磁盘用满</li>
<li>时钟出问题</li>
<li>网络不可用或者有问题</li>
<li>系统过载</li>
<li>显示分辨率过高或过低</li>
</ul>
<h3 id="3-6-P-是否满足性能要求？"><a href="#3-6-P-是否满足性能要求？" class="headerlink" title="3.6 P-是否满足性能要求？"></a>3.6 P-是否满足性能要求？</h3><p>考虑使用JUnitPerf等工具来进行性能测试。</p>
<h2 id="4-使用mock来模拟对象"><a href="#4-使用mock来模拟对象" class="headerlink" title="4.使用mock来模拟对象"></a>4.使用mock来模拟对象</h2><p>参见文档: <a target="_blank" rel="noopener" href="http://www.importnew.com/24741.html">Junit mockito 解耦合测试</a></p>
<h2 id="5-好的测试所具有的品质"><a href="#5-好的测试所具有的品质" class="headerlink" title="5.好的测试所具有的品质"></a>5.好的测试所具有的品质</h2><p>好的测试应该具有如下的品质，合称为A-TRIP:</p>
<ul>
<li>自动化（Automatic)<ul>
<li>调用测试自动化</li>
<li>检查结果自动化</li>
</ul>
</li>
<li>彻底的（Thorough）<ul>
<li>完整度测试</li>
</ul>
</li>
<li>可重复（Repeatable）<ul>
<li>每个测试必须独立其他的测试，而且还必须独立于周围的环境。</li>
</ul>
</li>
<li>独立的（Independent）<ul>
<li>一次只测试了一样东西（一个测试函数应该专注于代码产品中的一个函数），或者组合起来并共同提供某个特性的一组函数</li>
<li>测试没有依赖于其他任何的测试; 这里可以使用<code>Mockito</code>{:.error}</li>
<li>每个测试方法的setUp 以及teardown函数，以及每个类的setup函数和teardown函数帮助实现了这个特性</li>
<li><code>每个测试都应该是一座孤岛</code>{:.error}</li>
</ul>
</li>
<li>专业的（Professional）</li>
</ul>
<h3 id="5-1-对测试进行测试"><a href="#5-1-对测试进行测试" class="headerlink" title="5.1 对测试进行测试"></a>5.1 对测试进行测试</h3><p>如何保证测试代码是正确的：</p>
<ul>
<li>在修正bug的同时改进测试。</li>
<li>通过引入bug来证明测试。</li>
</ul>
<p>步骤：</p>
<ol>
<li>验明 bug。</li>
<li>编写一个将失败的测试来证明 bug 的存在。</li>
<li>修正代码，让测试通过。</li>
<li>验证所有的测试依然可以通过。（也就是，你没有在修补的时候损坏其他的测试）</li>
<li>这种方法能够持续有效的增长测试覆盖率，而从已经存在的代码中逃脱到荒漠的bug的数目会同时下井。</li>
</ol>
<h2 id="6-开发者对单元测试的自我修养"><a href="#6-开发者对单元测试的自我修养" class="headerlink" title="6.开发者对单元测试的自我修养"></a>6.开发者对单元测试的自我修养</h2><h3 id="6-1-宗旨："><a href="#6-1-宗旨：" class="headerlink" title="6.1 宗旨："></a>6.1 宗旨：</h3><ol>
<li>需要避免养成<code>忽略</code>{:.error}”失败的测试结果”的习惯。</li>
<li><code>所有的测试应该在任何时刻都能通过</code>{:.error}</li>
</ol>
<h3 id="6-2-如何遵循这些宗旨呢？"><a href="#6-2-如何遵循这些宗旨呢？" class="headerlink" title="6.2 如何遵循这些宗旨呢？"></a>6.2 如何遵循这些宗旨呢？</h3><ol>
<li>不完整的代码（比如说，仅嵌入了一个类文件，而忘记了它所依赖的其他文件）。</li>
<li>不能编译的代码。</li>
<li>代码能编译，但是会破坏已经存在的代码，比如使得已经存在的代码编译失败。</li>
<li>没有相应单元测试的代码。</li>
<li>不能通过单元测试的代码。</li>
<li>通过了自己的测试，但是导致系统其他地方的其他测试失败的代码。</li>
</ol>
<h3 id="6-3-测试的频率的一般性原则："><a href="#6-3-测试的频率的一般性原则：" class="headerlink" title="6.3 测试的频率的一般性原则："></a>6.3 测试的频率的一般性原则：</h3><ol>
<li>编写新的函数。</li>
</ol>
<ul>
<li>编译并运行本地的单元测试。</li>
</ul>
<ol start="2">
<li>修正bug。</li>
</ol>
<ul>
<li>关于修正bug的单元测试的流程，见 <em>5.1</em>。</li>
</ul>
<ol start="3">
<li>每次成功编译之后。</li>
</ol>
<ul>
<li>运行本地的单元测试。</li>
</ul>
<ol start="4">
<li>每次对版本控制的签入。</li>
</ol>
<ul>
<li>运行所有的模块或者系统的单元的测试。</li>
</ul>
<ol start="5">
<li>通过持续构建工具来持续不断地测试。</li>
</ol>
<h3 id="6-4-测试与遗留代码"><a href="#6-4-测试与遗留代码" class="headerlink" title="6.4 测试与遗留代码"></a>6.4 测试与遗留代码</h3><h3 id="6-5-测试与评审"><a href="#6-5-测试与评审" class="headerlink" title="6.5 测试与评审"></a>6.5 测试与评审</h3><p>无论进行何种形式的代码评审，都要让<code>测试代码成为评审过程的一个组成部分</code>{:.error}。</p>
<h2 id="7-设计话题"><a href="#7-设计话题" class="headerlink" title="7.设计话题"></a>7.设计话题</h2><h3 id="7-1-测试驱动的设计"><a href="#7-1-测试驱动的设计" class="headerlink" title="7.1 测试驱动的设计"></a>7.1 测试驱动的设计</h3><p>如果你总是在编写实现代码之前，就先编写它们的测试代码，那么你就是在使用测试驱动的开发这么一种很有用的技术。这种编码方式的一个优点是，你可以享受到”测试驱动的设计”的好处，并且大大改善接口的设计。</p>
<p>因为总是自己亲自来调用这些接口，所以通常都能获得更好的接口设计。正如一句谚语所说 – 你总是能够利用这些反馈来改善接口的设计。</p>
<h3 id="7-2-测试无效的参数"><a href="#7-2-测试无效的参数" class="headerlink" title="7.2 测试无效的参数"></a>7.2 测试无效的参数</h3><p>原则：<code>别让野蛮人进门</code>{:.error}。</p>
<h2 id="8-个人经验总结"><a href="#8-个人经验总结" class="headerlink" title="8. 个人经验总结"></a>8. 个人经验总结</h2><ol>
<li><p>对于Java service程序，dao层可以通过事务自动回滚来保证对数据库的无侵犯性；其他层，如manager层，service层等，可以通过Mock工具来保证单元测试的独立性和可重复性。</p>
</li>
<li><p>对于web程序，可以通过Mockito, MockMVC, JUnit来配合使用进行controller层的定制化单元测试。</p>
</li>
</ol>
<p>歪个楼：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/633d83dd303b">Spring MVC @JsonView使用详解</a></p>
<h2 id="9-参考文献"><a href="#9-参考文献" class="headerlink" title="9.参考文献"></a>9.参考文献</h2><ul>
<li>《单元测试之道 Java版》</li>
<li>Mockito介绍:<ul>
<li><a target="_blank" rel="noopener" href="https://javacodehouse.com/blog/mockito-tutorial/">How to mock with Mockito (A comprehensive guide with examples)</a></li>
<li><a target="_blank" rel="noopener" href="http://youngfor.me/2017/07/30/mockito-spy/">Mockito Spy 用法</a></li>
<li><a target="_blank" rel="noopener" href="https://site.mockito.org/">Mockito官网</a></li>
<li><a target="_blank" rel="noopener" href="https://memorynotfound.com/unit-test-spring-mvc-rest-service-junit-mockito/">Unit Test Spring MVC Rest Service: MockMVC, JUnit, Mockito</a></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2019/05/08/2019-04-24-Java-Reflection/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Robinson">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Road To Excelsior">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/05/08/2019-04-24-Java-Reflection/" class="post-title-link" itemprop="url">Java Reflection</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-05-08 15:53:10" itemprop="dateCreated datePublished" datetime="2019-05-08T15:53:10+08:00">2019-05-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-12-18 00:46:50" itemprop="dateModified" datetime="2020-12-18T00:46:50+08:00">2020-12-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>反射是Java语言的一种特性。它被用来在<strong>运行时</strong>检查或者修改方法，类，接口的行为。</p>
<ul>
<li>反射所需要的类 reflection 在java.lang.reflect包中；</li>
<li>反射提供了一个对象所属的类信息以及可供运行的对象的方法的信息；</li>
<li>通过反射，可以在运行时调用指定的方法，而无视它们所用的访问限定符；</li>
</ul>
<h2 id="获取类，构造器，方法信息"><a href="#获取类，构造器，方法信息" class="headerlink" title="获取类，构造器，方法信息"></a>获取类，构造器，方法信息</h2><ul>
<li><code>Class</code>{:.error} getClass() 方法被用来获取某个对象所属类的名称</li>
<li><code>Constructors</code>{:.error} getConstructors方法可以被用来获取某个对象所属类的公有构造器信息</li>
<li><code>Methods</code>{:.error} getMethods() 方法被用来获取某个对象所属于类的公有方法信息</li>
</ul>
<p>例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo;</span><br><span class="line"></span><br><span class="line"><span class="comment">// class whose object is to be created</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="comment">// creating a private field</span></span><br><span class="line">    <span class="keyword">private</span> String s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// creating a public constructor</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">()</span>  </span>&#123;  s = <span class="string">&quot;GeeksforGeeks&quot;</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Creating a public method with no arguments</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;The string is &quot;</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Creating a public method with int as argument</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">(<span class="keyword">int</span> n)</span>  </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;The number is &quot;</span> + n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// creating a private method</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Private method invoked&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构建一个方法来为这个类生成对象;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Creating object whose property is to be checked</span></span><br><span class="line">        Test obj = <span class="keyword">new</span> Test();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Creating class object from the object using</span></span><br><span class="line">        <span class="comment">// getclass method</span></span><br><span class="line">        Class cls = obj.getClass();</span><br><span class="line">        System.out.println(<span class="string">&quot;The name of class is &quot;</span> +</span><br><span class="line">                cls.getName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Getting the constructor of the class through the</span></span><br><span class="line">        <span class="comment">// object of the class</span></span><br><span class="line">        Constructor constructor = cls.getConstructor();</span><br><span class="line">        System.out.println(<span class="string">&quot;The name of constructor is &quot;</span> +</span><br><span class="line">                constructor.getName());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;The public methods of class are : &quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Getting methods of the class through the object</span></span><br><span class="line">        <span class="comment">// of the class by using getMethods</span></span><br><span class="line">        Method[] methods = cls.getMethods();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Printing method names</span></span><br><span class="line">        <span class="keyword">for</span> (Method method : methods)</span><br><span class="line">            System.out.println(method.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">````</span><br><span class="line"></span><br><span class="line">观察结果可见：</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">The name of <span class="class"><span class="keyword">class</span> <span class="title">is</span> <span class="title">com</span>.<span class="title">example</span>.<span class="title">demo</span>.<span class="title">Test</span></span></span><br><span class="line"><span class="class"><span class="title">The</span> <span class="title">name</span> <span class="title">of</span> <span class="title">constructor</span> <span class="title">is</span> <span class="title">com</span>.<span class="title">example</span>.<span class="title">demo</span>.<span class="title">Test</span></span></span><br><span class="line">The public methods of class are : </span><br><span class="line">method1</span><br><span class="line">method2</span><br><span class="line">wait</span><br><span class="line">wait</span><br><span class="line">wait</span><br><span class="line">equals</span><br><span class="line">toString</span><br><span class="line">hashCode</span><br><span class="line">getClass</span><br><span class="line">notify</span><br><span class="line">notifyAll</span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>需要说明如下几点：</p>
<ol>
<li>因为Java中所有的类都继承Object，所以公有方法中有一些是Object类中的方法列表；</li>
<li>除了获取上面一些信息，还能获取类的成员变量信息，方法的参数列表信息，返回值信息，异常信息等</li>
</ol>
<h2 id="调用反射调用类，构造器，方法"><a href="#调用反射调用类，构造器，方法" class="headerlink" title="调用反射调用类，构造器，方法"></a>调用反射调用类，构造器，方法</h2><p>承接上个代码案例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: fuxi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2019/4/24</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Creating object whose property is to be checked</span></span><br><span class="line">        Test obj = <span class="keyword">new</span> Test();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Creating class object from the object using</span></span><br><span class="line">        <span class="comment">// getclass method</span></span><br><span class="line">        Class cls = obj.getClass();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// creates object of desired method by providing the</span></span><br><span class="line">        <span class="comment">// method name and parameter class as arguments to</span></span><br><span class="line">        <span class="comment">// the getDeclaredMethod</span></span><br><span class="line">        Method methodcall1 = cls.getDeclaredMethod(<span class="string">&quot;method2&quot;</span>,</span><br><span class="line">                <span class="keyword">int</span>.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// invokes the method at runtime</span></span><br><span class="line">        methodcall1.invoke(obj, <span class="number">19</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// creates object of the desired field by providing</span></span><br><span class="line">        <span class="comment">// the name of field as argument to the</span></span><br><span class="line">        <span class="comment">// getDeclaredField method</span></span><br><span class="line">        Field field = cls.getDeclaredField(<span class="string">&quot;s&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// allows the object to access the field irrespective</span></span><br><span class="line">        <span class="comment">// of the access specifier used with the field</span></span><br><span class="line">        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// takes object and the new value to be assigned</span></span><br><span class="line">        <span class="comment">// to the field as arguments</span></span><br><span class="line">        field.set(obj, <span class="string">&quot;JAVA&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Creates object of desired method by providing the</span></span><br><span class="line">        <span class="comment">// method name as argument to the getDeclaredMethod</span></span><br><span class="line">        Method methodcall2 = cls.getDeclaredMethod(<span class="string">&quot;method1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// invokes the method at runtime</span></span><br><span class="line">        methodcall2.invoke(obj);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Creates object of the desired method by providing</span></span><br><span class="line">        <span class="comment">// the name of method as argument to the</span></span><br><span class="line">        <span class="comment">// getDeclaredMethod method</span></span><br><span class="line">        Method methodcall3 = cls.getDeclaredMethod(<span class="string">&quot;method3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// allows the object to access the method irrespective</span></span><br><span class="line">        <span class="comment">// of the access specifier used with the method</span></span><br><span class="line">        methodcall3.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// invokes the method at runtime</span></span><br><span class="line">        methodcall3.invoke(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行查看代码的结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The number is <span class="number">19</span></span><br><span class="line">The string is JAVA</span><br><span class="line">Private method invoked</span><br></pre></td></tr></table></figure>

<p>通过代码，可以观察到一下几点：</p>
<ul>
<li>如果知道方法的名称和参数类型，可以通过反射来获取这个方法。可以使用getDeclaredMethod()，来创建一个待调用的方法对象。</li>
<li>可以通过invoke方法来在运行时调用指定类的方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 在具有指定参数的指定对象上调用此对象表示的基础方法。</span></span><br><span class="line"><span class="comment">* 各个参数自动解包以匹配原始形式参数，并且原始参数和引用参数都根据需要进行方法调用转换。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object obj, Object... args)</span></span>&#123;...&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>通过反射，可以获取私有变量和私有方法，并使用上诉方法来调用这些私有变量和私有方法。具体的话，使用以下两个步骤来达到目的：<ol>
<li><strong>Class.getDeclaredField(FieldName):</strong> 被用来获取私有成员。这个方法用来返回一个指定字段名称的Field类型的对象。</li>
<li><strong>Field.setAccessible(true):</strong> 无论字段使用的访问修饰符如何，都允许访问该字段。</li>
</ol>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>使用反射的优势在哪里：</p>
<ul>
<li><strong>可扩展性功能</strong>：应用程序可以通过使用完全限定名称创建可扩展性对象的实例来使用外部的用户定义类。</li>
<li><strong>调试和测试工具</strong>：调试器使用反射的一些性质来检查私有类和方法。</li>
</ul>
<p>使用反射的劣势在哪里：</p>
<ul>
<li><strong>性能损耗</strong>：反射操作的性能低于非反射操作，应避免使用在对性能敏感的应用程序中频繁调用的代码段中。</li>
<li><strong>封装暴露</strong>：反射代码打破了抽象，因此可能会通过升级平台来改变行为。</li>
</ul>
<p>关于对反射知识的总结，我是在阅读Java注解以及Spring AOP时，发现这些技术都使用了反射作为运行时代码信息获取执行的基础，所以就回过头来阅读相关的文档。具体关于注解方面的资源，可见：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/briblue/article/details/73824058">Java 注解 （Annotation）</a></p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ol>
<li><a target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/reflection-in-java/">Reflection in Java</a></li>
<li><a target="_blank" rel="noopener" href="https://www.oracle.com/technetwork/articles/java/javareflection-1536171.html">Using Java Reflection</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2019/05/08/2018-10-18-Spring-IOC-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Robinson">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Road To Excelsior">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/05/08/2018-10-18-Spring-IOC-2/" class="post-title-link" itemprop="url">Spring IOC(2) - 实例化</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-05-08 15:53:10" itemprop="dateCreated datePublished" datetime="2019-05-08T15:53:10+08:00">2019-05-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-12-18 00:43:53" itemprop="dateModified" datetime="2020-12-18T00:43:53+08:00">2020-12-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><p>Spring 为使用Java开发大型的应用程序提供了很好的模块化技术支持，极大的减小了耦合度。通过Spring IOC以及AOP，可以实现高度灵活的应用服务开发目的。</p>
<h2 id="1-实例化"><a href="#1-实例化" class="headerlink" title="1. 实例化"></a>1. 实例化</h2><h3 id="2-1-实例化入口"><a href="#2-1-实例化入口" class="headerlink" title="2.1 实例化入口"></a>2.1 实例化入口</h3><p>承接上文，Spring IOC在完成初始化之后，会继续进行相关的操作。其进行实例化的入口依然在AbstractApplicationContext中的refresh()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">	<span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">		<span class="comment">// 为刷新准备context;</span></span><br><span class="line">		prepareRefresh();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line">     <span class="comment">// 告诉子类去刷新内部的bean factory</span></span><br><span class="line">		ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">     <span class="comment">// 准备这个bean factory以待后用</span></span><br><span class="line">		prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">       <span class="comment">// 允许在context 的子类中进行后处理 bean factory</span></span><br><span class="line">			postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">       <span class="comment">// 调用 工厂处理方法</span></span><br><span class="line">			invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">       <span class="comment">// 注册bean 处理器用来拦截bean的创建</span></span><br><span class="line">			registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Initialize message source for this context.</span></span><br><span class="line">       <span class="comment">// 为这个context初始化消息源</span></span><br><span class="line">			initMessageSource();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">       <span class="comment">// 为这个 context 初始化事件多播</span></span><br><span class="line">			initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">       <span class="comment">// 在特定的context子类中 初始化其他特定的bean</span></span><br><span class="line">			onRefresh();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">       <span class="comment">// 检查监听器bean，并注册它们</span></span><br><span class="line">			registerListeners();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">       <span class="comment">// 实例化所有的(non-lazy-init)的单体bean</span></span><br><span class="line">			finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">			finishRefresh();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">			<span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">				logger.warn(<span class="string">&quot;Exception encountered during context initialization - &quot;</span> +</span><br><span class="line">						<span class="string">&quot;cancelling refresh attempt: &quot;</span> + ex);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">			destroyBeans();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Reset &#x27;active&#x27; flag.</span></span><br><span class="line">			cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Propagate exception to caller.</span></span><br><span class="line">			<span class="keyword">throw</span> ex;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="comment">// Reset common introspection caches in Spring&#x27;s core, since we</span></span><br><span class="line">			<span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">			resetCommonCaches();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在实例化入口，会实例化所有的非懒加载的bean，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Finish the initialization of this context&#x27;s bean factory,</span></span><br><span class="line"><span class="comment"> * initializing all remaining singleton beans.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finishBeanFactoryInitialization</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// Initialize conversion service for this context.</span></span><br><span class="line">	<span class="keyword">if</span> (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;</span><br><span class="line">			beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) &#123;</span><br><span class="line">		beanFactory.setConversionService(</span><br><span class="line">				beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Register a default embedded value resolver if no bean post-processor</span></span><br><span class="line">	<span class="comment">// (such as a PropertyPlaceholderConfigurer bean) registered any before:</span></span><br><span class="line">	<span class="comment">// at this point, primarily for resolution in annotation attribute values.</span></span><br><span class="line">	<span class="keyword">if</span> (!beanFactory.hasEmbeddedValueResolver()) &#123;</span><br><span class="line">		beanFactory.addEmbeddedValueResolver(strVal -&gt; getEnvironment().resolvePlaceholders(strVal));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Initialize LoadTimeWeaverAware beans early to allow for registering their transformers early.</span></span><br><span class="line">	String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">	<span class="keyword">for</span> (String weaverAwareName : weaverAwareNames) &#123;</span><br><span class="line">		getBean(weaverAwareName);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Stop using the temporary ClassLoader for type matching.</span></span><br><span class="line">	beanFactory.setTempClassLoader(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Allow for caching all bean definition metadata, not expecting further changes.</span></span><br><span class="line">	beanFactory.freezeConfiguration();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">	beanFactory.preInstantiateSingletons();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-预实例化单体"><a href="#2-2-预实例化单体" class="headerlink" title="2.2 预实例化单体"></a>2.2 预实例化单体</h3><p>承上，完成了一些入口的一些处理之后，开始进入beanFactory.preInstantiateSingletons()进行实例化的预处理操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preInstantiateSingletons</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line">		<span class="keyword">this</span>.logger.debug(<span class="string">&quot;Pre-instantiating singletons in &quot;</span> + <span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Iterate over a copy to allow for init methods which in turn register new bean definitions.</span></span><br><span class="line">	<span class="comment">// While this may not be part of the regular factory bootstrap, it does otherwise work fine.</span></span><br><span class="line">	List&lt;String&gt; beanNames = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Trigger initialization of all non-lazy singleton beans...</span></span><br><span class="line">	<span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">		RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">		<span class="keyword">if</span> (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;</span><br><span class="line">			<span class="keyword">if</span> (isFactoryBean(beanName)) &#123;</span><br><span class="line">				Object bean = getBean(FACTORY_BEAN_PREFIX + beanName);</span><br><span class="line">				<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> FactoryBean) &#123;</span><br><span class="line">					<span class="keyword">final</span> FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) bean;</span><br><span class="line">					<span class="keyword">boolean</span> isEagerInit;</span><br><span class="line">					<span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span> &amp;&amp; factory <span class="keyword">instanceof</span> SmartFactoryBean) &#123;</span><br><span class="line">						isEagerInit = AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;)</span><br><span class="line">										((SmartFactoryBean&lt;?&gt;) factory)::isEagerInit,</span><br><span class="line">								getAccessControlContext());</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span> &#123;</span><br><span class="line">						isEagerInit = (factory <span class="keyword">instanceof</span> SmartFactoryBean &amp;&amp;</span><br><span class="line">								((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">if</span> (isEagerInit) &#123;</span><br><span class="line">						getBean(beanName);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				getBean(beanName);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Trigger post-initialization callback for all applicable beans...</span></span><br><span class="line">   <span class="comment">// 到这里说明所有的非懒加载的 singleton beans 已经完成了初始化</span></span><br><span class="line">   <span class="comment">// 如果我们定义的 bean 是实现了 SmartInitializingSingleton 接口的，那么在这里得到回调，忽略</span></span><br><span class="line">	<span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">		Object singletonInstance = getSingleton(beanName);</span><br><span class="line">		<span class="keyword">if</span> (singletonInstance <span class="keyword">instanceof</span> SmartInitializingSingleton) &#123;</span><br><span class="line">			<span class="keyword">final</span> SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;</span><br><span class="line">			<span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">				AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">					smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">					<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">				&#125;, getAccessControlContext());</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-调用getBean来获取实例"><a href="#2-3-调用getBean来获取实例" class="headerlink" title="2.3 调用getBean来获取实例"></a>2.3 调用getBean来获取实例</h3><p>在上面进行若干项检查后，调用getBean方法来进行获取bean实例的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// Implementation of BeanFactory interface</span></span><br><span class="line"><span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> doGetBean(name, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> 	<span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return an instance, which may be shared or independent, of the specified bean.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name the name of the bean to retrieve</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> requiredType the required type of the bean to retrieve</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args arguments to use when creating a bean instance using explicit arguments</span></span><br><span class="line"><span class="comment"> * (only applied when creating a new instance as opposed to retrieving an existing one)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> typeCheckOnly whether the instance is obtained for a type check,</span></span><br><span class="line"><span class="comment"> * not for actual use</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> an instance of the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeansException if the bean could not be created</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doGetBean</span><span class="params">(<span class="keyword">final</span> String name, <span class="meta">@Nullable</span> <span class="keyword">final</span> Class&lt;T&gt; requiredType,</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="meta">@Nullable</span> <span class="keyword">final</span> Object[] args, <span class="keyword">boolean</span> typeCheckOnly)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">final</span> String beanName = transformedBeanName(name);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//这个是返回值</span></span><br><span class="line">	Object bean;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Eagerly check singleton cache for manually registered singletons.</span></span><br><span class="line">	Object sharedInstance = getSingleton(beanName);</span><br><span class="line">	<span class="keyword">if</span> (sharedInstance != <span class="keyword">null</span> &amp;&amp; args == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">			<span class="keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">				logger.debug(<span class="string">&quot;Returning eagerly cached instance of singleton bean &#x27;&quot;</span> + beanName +</span><br><span class="line">						<span class="string">&quot;&#x27; that is not fully initialized yet - a consequence of a circular reference&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				logger.debug(<span class="string">&quot;Returning cached instance of singleton bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="keyword">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// Fail if we&#x27;re already creating this bean instance:</span></span><br><span class="line">		<span class="comment">// We&#x27;re assumably within a circular reference.</span></span><br><span class="line">		<span class="keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Check if bean definition exists in this factory.</span></span><br><span class="line">		BeanFactory parentBeanFactory = getParentBeanFactory();</span><br><span class="line">		<span class="keyword">if</span> (parentBeanFactory != <span class="keyword">null</span> &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class="line">			<span class="comment">// Not found -&gt; check parent.</span></span><br><span class="line">			String nameToLookup = originalBeanName(name);</span><br><span class="line">			<span class="keyword">if</span> (parentBeanFactory <span class="keyword">instanceof</span> AbstractBeanFactory) &#123;</span><br><span class="line">				<span class="keyword">return</span> ((AbstractBeanFactory) parentBeanFactory).doGetBean(</span><br><span class="line">						nameToLookup, requiredType, args, typeCheckOnly);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (args != <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="comment">// Delegation to parent with explicit args.</span></span><br><span class="line">				<span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup, args);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// No args -&gt; delegate to standard getBean method.</span></span><br><span class="line">				<span class="keyword">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!typeCheckOnly) &#123;</span><br><span class="line">			markBeanAsCreated(beanName);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">final</span> RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">			checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Guarantee initialization of beans that the current bean depends on.</span></span><br><span class="line">			String[] dependsOn = mbd.getDependsOn();</span><br><span class="line">			<span class="keyword">if</span> (dependsOn != <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">for</span> (String dep : dependsOn) &#123;</span><br><span class="line">					<span class="keyword">if</span> (isDependent(beanName, dep)) &#123;</span><br><span class="line">						<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">								<span class="string">&quot;Circular depends-on relationship between &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; and &#x27;&quot;</span> + dep + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">					&#125;</span><br><span class="line">					registerDependentBean(dep, beanName);</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						getBean(dep);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line">						<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">								<span class="string">&quot;&#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; depends on missing bean &#x27;&quot;</span> + dep + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Create bean instance.</span></span><br><span class="line">			<span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">				sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						<span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">						<span class="comment">// Explicitly remove instance from singleton cache: It might have been put there</span></span><br><span class="line">						<span class="comment">// eagerly by the creation process, to allow for circular reference resolution.</span></span><br><span class="line">						<span class="comment">// Also remove any beans that received a temporary reference to the bean.</span></span><br><span class="line">						destroySingleton(beanName);</span><br><span class="line">						<span class="keyword">throw</span> ex;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;);</span><br><span class="line">				bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;</span><br><span class="line">				<span class="comment">// It&#x27;s a prototype -&gt; create a new instance.</span></span><br><span class="line">				Object prototypeInstance = <span class="keyword">null</span>;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					beforePrototypeCreation(beanName);</span><br><span class="line">					prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">finally</span> &#123;</span><br><span class="line">					afterPrototypeCreation(beanName);</span><br><span class="line">				&#125;</span><br><span class="line">				bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				String scopeName = mbd.getScope();</span><br><span class="line">				<span class="keyword">final</span> Scope scope = <span class="keyword">this</span>.scopes.get(scopeName);</span><br><span class="line">				<span class="keyword">if</span> (scope == <span class="keyword">null</span>) &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;No Scope registered for scope name &#x27;&quot;</span> + scopeName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					Object scopedInstance = scope.get(beanName, () -&gt; &#123;</span><br><span class="line">						beforePrototypeCreation(beanName);</span><br><span class="line">						<span class="keyword">try</span> &#123;</span><br><span class="line">							<span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">finally</span> &#123;</span><br><span class="line">							afterPrototypeCreation(beanName);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;);</span><br><span class="line">					bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName,</span><br><span class="line">							<span class="string">&quot;Scope &#x27;&quot;</span> + scopeName + <span class="string">&quot;&#x27; is not active for the current thread; consider &quot;</span> +</span><br><span class="line">							<span class="string">&quot;defining a scoped proxy for this bean if you intend to refer to it from a singleton&quot;</span>,</span><br><span class="line">							ex);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">			cleanupAfterBeanCreationFailure(beanName);</span><br><span class="line">			<span class="keyword">throw</span> ex;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Check if required type matches the type of the actual bean instance.</span></span><br><span class="line">	<span class="keyword">if</span> (requiredType != <span class="keyword">null</span> &amp;&amp; !requiredType.isInstance(bean)) &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			T convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType);</span><br><span class="line">			<span class="keyword">if</span> (convertedBean == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> convertedBean;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (TypeMismatchException ex) &#123;</span><br><span class="line">			<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">				logger.debug(<span class="string">&quot;Failed to convert bean &#x27;&quot;</span> + name + <span class="string">&quot;&#x27; to required type &#x27;&quot;</span> +</span><br><span class="line">						ClassUtils.getQualifiedName(requiredType) + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (T) bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，真正实例化的是父类（DefaultSingletonBeanRegistry）的getSingleton()方法，在这个方法中，调用了子类AbstractAutowireCapableBeanFactory 的doCreate的方法；在这个类中，最终调用了instantiateBean()方法来使用默认的构造器完成实例化构建的过程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Instantiate the given bean using its default constructor.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanName the name of the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mbd the bean definition for the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a BeanWrapper for the new instance</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> BeanWrapper <span class="title">instantiateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		Object beanInstance;</span><br><span class="line">		<span class="keyword">final</span> BeanFactory parent = <span class="keyword">this</span>;</span><br><span class="line">		<span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">			beanInstance = AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt;</span><br><span class="line">					getInstantiationStrategy().instantiate(mbd, beanName, parent),</span><br><span class="line">					getAccessControlContext());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent);</span><br><span class="line">		&#125;</span><br><span class="line">		BeanWrapper bw = <span class="keyword">new</span> BeanWrapperImpl(beanInstance);</span><br><span class="line">		initBeanWrapper(bw);</span><br><span class="line">		<span class="keyword">return</span> bw;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">				mbd.getResourceDescription(), beanName, <span class="string">&quot;Instantiation of bean failed&quot;</span>, ex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在方法中，其采用默认的策略来实例化这个bean，并进行了封装，返回。策略实例是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Strategy for creating bean instances */</span></span><br><span class="line"><span class="keyword">private</span> InstantiationStrategy instantiationStrategy = <span class="keyword">new</span> CglibSubclassingInstantiationStrategy();</span><br></pre></td></tr></table></figure>

<p>其继承层次如下：</p>
<p>![](/assets/posts/Spring IOC Instance/CglibSubclassingInstantiationStrategy.png)</p>
<h3 id="2-4-通过静态方法来进行实例化"><a href="#2-4-通过静态方法来进行实例化" class="headerlink" title="2.4 通过静态方法来进行实例化"></a>2.4 通过静态方法来进行实例化</h3><p>如下代码所示，其调用了静态类方法BeanUtils.instantiateClass(constructorToUse)来完成实例化；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">instantiate</span><span class="params">(RootBeanDefinition bd, <span class="meta">@Nullable</span> String beanName, BeanFactory owner)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// Don&#x27;t override the class with CGLIB if no overrides.</span></span><br><span class="line">	<span class="keyword">if</span> (!bd.hasMethodOverrides()) &#123;</span><br><span class="line">		Constructor&lt;?&gt; constructorToUse;</span><br><span class="line">		<span class="keyword">synchronized</span> (bd.constructorArgumentLock) &#123;</span><br><span class="line">			constructorToUse = (Constructor&lt;?&gt;) bd.resolvedConstructorOrFactoryMethod;</span><br><span class="line">			<span class="keyword">if</span> (constructorToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">final</span> Class&lt;?&gt; clazz = bd.getBeanClass();</span><br><span class="line">				<span class="keyword">if</span> (clazz.isInterface()) &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> BeanInstantiationException(clazz, <span class="string">&quot;Specified class is an interface&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					<span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">						constructorToUse = AccessController.doPrivileged(</span><br><span class="line">								(PrivilegedExceptionAction&lt;Constructor&lt;?&gt;&gt;) clazz::getDeclaredConstructor);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span> &#123;</span><br><span class="line">						constructorToUse =	clazz.getDeclaredConstructor();</span><br><span class="line">					&#125;</span><br><span class="line">					bd.resolvedConstructorOrFactoryMethod = constructorToUse;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> BeanInstantiationException(clazz, <span class="string">&quot;No default constructor found&quot;</span>, ex);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">     <span class="comment">//调用静态方法来进行实例化</span></span><br><span class="line">		<span class="keyword">return</span> BeanUtils.instantiateClass(constructorToUse);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// Must generate CGLIB subclass.</span></span><br><span class="line">		<span class="keyword">return</span> instantiateWithMethodInjection(bd, beanName, owner);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，真正实例化的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Convenience method to instantiate a class using the given constructor.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Note that this method tries to set the constructor accessible if given a</span></span><br><span class="line"><span class="comment"> * non-accessible (that is, non-public) constructor, and supports Kotlin classes</span></span><br><span class="line"><span class="comment"> * with optional parameters and default values.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ctor the constructor to instantiate</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args the constructor arguments to apply (use &#123;<span class="doctag">@code</span> null&#125; for an unspecified</span></span><br><span class="line"><span class="comment"> * parameter if needed for Kotlin classes with optional parameters and default values)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the new instance</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeanInstantiationException if the bean cannot be instantiated</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> Constructor#newInstance</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">instantiateClass</span><span class="params">(Constructor&lt;T&gt; ctor, Object... args)</span> <span class="keyword">throws</span> BeanInstantiationException </span>&#123;</span><br><span class="line">	Assert.notNull(ctor, <span class="string">&quot;Constructor must not be null&quot;</span>);</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		ReflectionUtils.makeAccessible(ctor);</span><br><span class="line">		<span class="keyword">return</span> (KotlinDetector.isKotlinType(ctor.getDeclaringClass()) ?</span><br><span class="line">				KotlinDelegate.instantiateClass(ctor, args) : ctor.newInstance(args));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (InstantiationException ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> BeanInstantiationException(ctor, <span class="string">&quot;Is it an abstract class?&quot;</span>, ex);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (IllegalAccessException ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> BeanInstantiationException(ctor, <span class="string">&quot;Is the constructor accessible?&quot;</span>, ex);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> BeanInstantiationException(ctor, <span class="string">&quot;Illegal arguments for constructor&quot;</span>, ex);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> BeanInstantiationException(ctor, <span class="string">&quot;Constructor threw exception&quot;</span>, ex.getTargetException());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h2><p>通过断点调试，打印调用堆栈信息如下:</p>
<p>![](/assets/posts/Spring IOC Instance/spring ioc instance.png)</p>
<h2 id="4-思考"><a href="#4-思考" class="headerlink" title="4.思考"></a>4.思考</h2><p>第一个问题，思考层次化的问题，即为何进行这样的分层？接口的设计逻辑是什么，类继承的逻辑是什么？<br>![](/assets/posts/Spring IOC Instance/DefaultListableBeanFactory01.png)</p>
<p>可以思考上面的类继承的逻辑，对照着调用堆栈信息来看分析么一个层类(虚类)之间的继承关系的逻辑。</p>
<h2 id="5-参考文档"><a href="#5-参考文档" class="headerlink" title="5.参考文档"></a>5.参考文档</h2><ol>
<li>Spring source code, version: 5.0.7.RELEASE</li>
<li><a target="_blank" rel="noopener" href="http://www.importnew.com/27469.html">Spring IOC 容器源码分析</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2019/05/08/2018-10-18-Spring-IOC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Robinson">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Road To Excelsior">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/05/08/2018-10-18-Spring-IOC/" class="post-title-link" itemprop="url">Spring IOC(1) - 初始化</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-05-08 15:53:10" itemprop="dateCreated datePublished" datetime="2019-05-08T15:53:10+08:00">2019-05-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-12-18 00:43:33" itemprop="dateModified" datetime="2020-12-18T00:43:33+08:00">2020-12-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><p>Spring 为使用Java开发大型的应用程序提供了很好的模块化技术支持，极大的减小了耦合度。通过Spring IOC以及AOP，可以实现高度灵活的应用服务开发目的。</p>
<h2 id="1-样例程序"><a href="#1-样例程序" class="headerlink" title="1. 样例程序"></a>1. 样例程序</h2><p>为了能探清spring ioc的逻辑，我实现了一个小的样例，其通过ClassPathXmlApplicationContext来读取配置中的bean，以实现bean的实例化，入口函数如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext context =  <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;spring-beans.xml&quot;</span>);</span><br><span class="line">        Person person = (Person)context.getBean(<span class="string">&quot;pson&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Name: &quot;</span> + person.getName() + <span class="string">&quot;; Age: &quot;</span> + person.getAge());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中关于Person类的定义以及bean的定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>spring-beans.xml的配置如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;pson&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.demo.Person&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;tony&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;18&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="2-单步分析"><a href="#2-单步分析" class="headerlink" title="2.单步分析"></a>2.单步分析</h2><p>通过对ClassPathXmlApplicationContext实现类的单步调试，首先进入其中，可以画出如下的uml类图：<br>![](/assets/posts/Spring ioc/ApplicationContextHieracy.png)</p>
<h3 id="2-1-保存位置，并刷新"><a href="#2-1-保存位置，并刷新" class="headerlink" title="2.1 保存位置，并刷新"></a>2.1 保存位置，并刷新</h3><p>继续单步调试，可见，ClassPathXmlApplicationContext首先会保存相关的配置信息，供后面解析使用，之后，会调用其基类之一AbstractApplicationContext的refresh方法来解析：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">		String[] configLocations, <span class="keyword">boolean</span> refresh, <span class="meta">@Nullable</span> ApplicationContext parent)</span></span></span><br><span class="line"><span class="function">		<span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">super</span>(parent);</span><br><span class="line">	setConfigLocations(configLocations);</span><br><span class="line">	<span class="keyword">if</span> (refresh) &#123;</span><br><span class="line">		refresh();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> 	<span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">	<span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">		<span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line">		prepareRefresh();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line">		ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">		prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">			postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">			invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">			registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Initialize message source for this context.</span></span><br><span class="line">			initMessageSource();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">			initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">			onRefresh();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">			registerListeners();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">			finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">			finishRefresh();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">			<span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">				logger.warn(<span class="string">&quot;Exception encountered during context initialization - &quot;</span> +</span><br><span class="line">						<span class="string">&quot;cancelling refresh attempt: &quot;</span> + ex);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">			destroyBeans();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Reset &#x27;active&#x27; flag.</span></span><br><span class="line">			cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Propagate exception to caller.</span></span><br><span class="line">			<span class="keyword">throw</span> ex;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="comment">// Reset common introspection caches in Spring&#x27;s core, since we</span></span><br><span class="line">			<span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">			resetCommonCaches();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-获取beanFactory"><a href="#2-2-获取beanFactory" class="headerlink" title="2.2 获取beanFactory"></a>2.2 获取beanFactory</h3><p>在refresh()中，通过调用obtainFreshBeanFactory()方法来获取告诉子类来刷新内部的bean factory。其代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the fresh BeanFactory instance</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #refreshBeanFactory()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #getBeanFactory()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ConfigurableListableBeanFactory <span class="title">obtainFreshBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	refreshBeanFactory();</span><br><span class="line">	ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line">	<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">		logger.debug(<span class="string">&quot;Bean factory for &quot;</span> + getDisplayName() + <span class="string">&quot;: &quot;</span> + beanFactory);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> beanFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于这个类，翻译如下：告诉子类来刷新内部的bean factory。这个方法是在AbstractApplicationContext中的定义的，其中refreshBeanFactory()是一个接口，在子类AbstractRefreshableApplicationContext中实现的。</p>
<p>这时，可见这个方法在基类中的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// Abstract methods that must be implemented by subclasses</span></span><br><span class="line"><span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Subclasses must implement this method to perform the actual configuration load.</span></span><br><span class="line"><span class="comment"> * The method is invoked by &#123;<span class="doctag">@link</span> #refresh()&#125; before any other initialization work.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;A subclass will either create a new bean factory and hold a reference to it,</span></span><br><span class="line"><span class="comment"> * or return a single BeanFactory instance that it holds. In the latter case, it will</span></span><br><span class="line"><span class="comment"> * usually throw an IllegalStateException if refreshing the context more than once.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeansException if initialization of the bean factory failed</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalStateException if already initialized and multiple refresh</span></span><br><span class="line"><span class="comment"> * attempts are not supported</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException</span>;</span><br></pre></td></tr></table></figure>

<p>关于Abstract method的使用，可见思考章节。</p>
<p>可见这里使用一个局部标量来保存了beanFactory，其中关于ConfigurableListableBeanFactory的类图hieracy如下：<br>![](/assets/posts/Spring ioc/DefaultListableBeanFactory.png)</p>
<p>其调用子类(AbstractRefreshableApplicationContext)的refreshBeanFactory()来进行执行context下的beanfactory的刷新；这个方法会关闭先前的bean factory并且为context的另一个生命周期初始化一个新鲜的bean factory。具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (hasBeanFactory()) &#123;</span><br><span class="line">		destroyBeans();</span><br><span class="line">		closeBeanFactory();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		DefaultListableBeanFactory beanFactory = createBeanFactory();</span><br><span class="line">		beanFactory.setSerializationId(getId());</span><br><span class="line">		customizeBeanFactory(beanFactory);</span><br><span class="line">     <span class="comment">/**这个方法进入下一个调用栈*/</span></span><br><span class="line">		loadBeanDefinitions(beanFactory);</span><br><span class="line">		<span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanFactoryMonitor) &#123;</span><br><span class="line">			<span class="keyword">this</span>.beanFactory = beanFactory;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">&quot;I/O error parsing bean definition source for &quot;</span> + getDisplayName(), ex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-加载bean-定义"><a href="#2-3-加载bean-定义" class="headerlink" title="2.3 加载bean 定义"></a>2.3 加载bean 定义</h3><p>在loadBeanDefinitions(beanFactory)方法中，其进入子类(AbstractXmlApplicationContext)调用loadBeanDefinitions来通过一个xmlBeanDefinitionReader来加载bean definitions。具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException, IOException </span>&#123;</span><br><span class="line">	<span class="comment">// Create a new XmlBeanDefinitionReader for the given BeanFactory.</span></span><br><span class="line">	XmlBeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(beanFactory);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Configure the bean definition reader with this context&#x27;s</span></span><br><span class="line">	<span class="comment">// resource loading environment.</span></span><br><span class="line">	beanDefinitionReader.setEnvironment(<span class="keyword">this</span>.getEnvironment());</span><br><span class="line">	beanDefinitionReader.setResourceLoader(<span class="keyword">this</span>);</span><br><span class="line">	beanDefinitionReader.setEntityResolver(<span class="keyword">new</span> ResourceEntityResolver(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Allow a subclass to provide custom initialization of the reader,</span></span><br><span class="line">	<span class="comment">// then proceed with actually loading the bean definitions.</span></span><br><span class="line">	initBeanDefinitionReader(beanDefinitionReader);</span><br><span class="line">	loadBeanDefinitions(beanDefinitionReader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，关于xmlBeanDefinitionReader的类图层级如下：<br>![](/assets/posts/Spring ioc/XmlBeanDefinitionReader.png)</p>
<h3 id="2-4-注册beans的定义"><a href="#2-4-注册beans的定义" class="headerlink" title="2.4 注册beans的定义"></a>2.4 注册beans的定义</h3><p>经过一个简短的链路，最终在xmlBeanDeifinitionReader中registerBeanDefinitions()方法中，在一个给定的DOM 文档中注册相应的bean definitions。具体的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**Creates a new instance of the parser class and invokes*/</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document doc, Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">	BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();</span><br><span class="line">	<span class="keyword">int</span> countBefore = getRegistry().getBeanDefinitionCount();</span><br><span class="line">	documentReader.registerBeanDefinitions(doc, createReaderContext(resource));</span><br><span class="line">	<span class="keyword">return</span> getRegistry().getBeanDefinitionCount() - countBefore;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，值得一提的是，BeanDefinitionDocumentReader实例是通过反射的方式来实现的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">protected</span> BeanDefinitionDocumentReader <span class="title">createBeanDefinitionDocumentReader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> BeanDefinitionDocumentReader.class.cast(BeanUtils.instantiateClass(<span class="keyword">this</span>.documentReaderClass));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>👌，现在进入BeanDefinitionDocumentReader中注册相关的bean definitions，在其实现类DefaultBeanDefinitionDocumentReader中，完成了对DOM元素的解析以及相关的beans的注册：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Register each bean definition within the given root &#123;<span class="doctag">@code</span> &lt;beans/&gt;&#125; element.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRegisterBeanDefinitions</span><span class="params">(Element root)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// Any nested &lt;beans&gt; elements will cause recursion in this method. In</span></span><br><span class="line">	<span class="comment">// order to propagate and preserve &lt;beans&gt; default-* attributes correctly,</span></span><br><span class="line">	<span class="comment">// keep track of the current (parent) delegate, which may be null. Create</span></span><br><span class="line">	<span class="comment">// the new (child) delegate with a reference to the parent for fallback purposes,</span></span><br><span class="line">	<span class="comment">// then ultimately reset this.delegate back to its original (parent) reference.</span></span><br><span class="line">	<span class="comment">// this behavior emulates a stack of delegates without actually necessitating one.</span></span><br><span class="line">	BeanDefinitionParserDelegate parent = <span class="keyword">this</span>.delegate;</span><br><span class="line">	<span class="keyword">this</span>.delegate = createDelegate(getReaderContext(), root, parent);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">		String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);</span><br><span class="line">		<span class="keyword">if</span> (StringUtils.hasText(profileSpec)) &#123;</span><br><span class="line">			String[] specifiedProfiles = StringUtils.tokenizeToStringArray(</span><br><span class="line">					profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">			<span class="keyword">if</span> (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) &#123;</span><br><span class="line">				<span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">					logger.info(<span class="string">&quot;Skipped XML bean definition file due to specified profiles [&quot;</span> + profileSpec +</span><br><span class="line">							<span class="string">&quot;] not matching: &quot;</span> + getReaderContext().getResource());</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	preProcessXml(root);</span><br><span class="line">	parseBeanDefinitions(root, <span class="keyword">this</span>.delegate);</span><br><span class="line">	postProcessXml(root);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">this</span>.delegate = parent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> BeanDefinitionParserDelegate <span class="title">createDelegate</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">		XmlReaderContext readerContext, Element root, <span class="meta">@Nullable</span> BeanDefinitionParserDelegate parentDelegate)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	BeanDefinitionParserDelegate delegate = <span class="keyword">new</span> BeanDefinitionParserDelegate(readerContext);</span><br><span class="line">	delegate.initDefaults(root, parentDelegate);</span><br><span class="line">	<span class="keyword">return</span> delegate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，其创建了代理对象BeanDefinitionParserDelegate来完成注册过程；👌，其中preProcessXml和postProcessXml在这个实现类中为空，所以只需要关注parseBeanDefinitions方法即可。其代码很简单，就是进行简单的DOM元素解析，并进行注册:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Parse the elements at the root level in the document:</span></span><br><span class="line"><span class="comment"> * &quot;import&quot;, &quot;alias&quot;, &quot;bean&quot;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root the DOM root element of the document</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">parseBeanDefinitions</span><span class="params">(Element root, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">		NodeList nl = root.getChildNodes();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">			Node node = nl.item(i);</span><br><span class="line">			<span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">				Element ele = (Element) node;</span><br><span class="line">				<span class="keyword">if</span> (delegate.isDefaultNamespace(ele)) &#123;</span><br><span class="line">					parseDefaultElement(ele, delegate);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					delegate.parseCustomElement(ele);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		delegate.parseCustomElement(root);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseDefaultElement</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) &#123;</span><br><span class="line">		importBeanDefinitionResource(ele);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) &#123;</span><br><span class="line">		processAliasRegistration(ele);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) &#123;</span><br><span class="line">		processBeanDefinition(ele, delegate);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) &#123;</span><br><span class="line">		<span class="comment">// recurse</span></span><br><span class="line">		doRegisterBeanDefinitions(ele);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在我们的例子中，我们的断点会走到 <strong>processBeanDefinitions</strong>方法处进行bean定义的处理。其实，默认的xml还可以进行“import, alias”元素的解析。在这个方法中，其通过一个静态方法来实现了DefaultListableBeanFactory来完成进行注册过程：</p>
<p>同时，这个静态方法的入参registry的是DefaultListableBeanFactory的成员变量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">  <span class="keyword">private</span> XmlReaderContext readerContext;</span><br></pre></td></tr></table></figure>

<p>在调用静态方法时，这个成员变量会被传入作为入参，完成实际的注册过程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Process the given bean element, parsing the bean definition</span></span><br><span class="line"><span class="comment"> * and registering it with the registry.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processBeanDefinition</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">	BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);</span><br><span class="line">	<span class="keyword">if</span> (bdHolder != <span class="keyword">null</span>) &#123;</span><br><span class="line">		bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// Register the final decorated instance.</span></span><br><span class="line">			BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">			getReaderContext().error(<span class="string">&quot;Failed to register bean definition with name &#x27;&quot;</span> +</span><br><span class="line">					bdHolder.getBeanName() + <span class="string">&quot;&#x27;&quot;</span>, ele, ex);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Send registration event.</span></span><br><span class="line">		getReaderContext().fireComponentRegistered(<span class="keyword">new</span> BeanComponentDefinition(bdHolder));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-5-通过DefaultListableBeanFactory完成注册"><a href="#2-5-通过DefaultListableBeanFactory完成注册" class="headerlink" title="2.5 通过DefaultListableBeanFactory完成注册"></a>2.5 通过DefaultListableBeanFactory完成注册</h3><p>这个时候可以再看看DefaultListableBeanFactory的类图层次:<br>![](/assets/posts/Spring ioc/DefaultListableBeanFactory.png)<br>如图所示，其实现了BeanDefinitioinRegistry接口，完成bean的注册，同时，在BeanDefinitionReaderUtils中可见代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Register the given bean definition with the given bean factory.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> definitionHolder the bean definition including name and aliases</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> registry the bean factory to register with</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeanDefinitionStoreException if registration failed</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">		BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)</span></span></span><br><span class="line"><span class="function">		<span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Register bean definition under primary name.</span></span><br><span class="line">	String beanName = definitionHolder.getBeanName();</span><br><span class="line">	registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Register aliases for bean name, if any.</span></span><br><span class="line">	String[] aliases = definitionHolder.getAliases();</span><br><span class="line">	<span class="keyword">if</span> (aliases != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> (String alias : aliases) &#123;</span><br><span class="line">			registry.registerAlias(beanName, alias);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，我们进入registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition())方法中观察其实现类的逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// Implementation of BeanDefinitionRegistry interface</span></span><br><span class="line"><span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span></span></span><br><span class="line"><span class="function">		<span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line">	Assert.hasText(beanName, <span class="string">&quot;Bean name must not be empty&quot;</span>);</span><br><span class="line">	Assert.notNull(beanDefinition, <span class="string">&quot;BeanDefinition must not be null&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (beanDefinition <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			((AbstractBeanDefinition) beanDefinition).validate();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,</span><br><span class="line">					<span class="string">&quot;Validation of bean definition failed&quot;</span>, ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	BeanDefinition oldBeanDefinition;</span><br><span class="line"></span><br><span class="line">	oldBeanDefinition = <span class="keyword">this</span>.beanDefinitionMap.get(beanName);</span><br><span class="line">	<span class="keyword">if</span> (oldBeanDefinition != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!isAllowBeanDefinitionOverriding()) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,</span><br><span class="line">					<span class="string">&quot;Cannot register bean definition [&quot;</span> + beanDefinition + <span class="string">&quot;] for bean &#x27;&quot;</span> + beanName +</span><br><span class="line">					<span class="string">&quot;&#x27;: There is already [&quot;</span> + oldBeanDefinition + <span class="string">&quot;] bound.&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (oldBeanDefinition.getRole() &lt; beanDefinition.getRole()) &#123;</span><br><span class="line">			<span class="comment">// e.g. was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE</span></span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.logger.isWarnEnabled()) &#123;</span><br><span class="line">				<span class="keyword">this</span>.logger.warn(<span class="string">&quot;Overriding user-defined bean definition for bean &#x27;&quot;</span> + beanName +</span><br><span class="line">						<span class="string">&quot;&#x27; with a framework-generated bean definition: replacing [&quot;</span> +</span><br><span class="line">						oldBeanDefinition + <span class="string">&quot;] with [&quot;</span> + beanDefinition + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (!beanDefinition.equals(oldBeanDefinition)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.logger.isInfoEnabled()) &#123;</span><br><span class="line">				<span class="keyword">this</span>.logger.info(<span class="string">&quot;Overriding bean definition for bean &#x27;&quot;</span> + beanName +</span><br><span class="line">						<span class="string">&quot;&#x27; with a different definition: replacing [&quot;</span> + oldBeanDefinition +</span><br><span class="line">						<span class="string">&quot;] with [&quot;</span> + beanDefinition + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line">				<span class="keyword">this</span>.logger.debug(<span class="string">&quot;Overriding bean definition for bean &#x27;&quot;</span> + beanName +</span><br><span class="line">						<span class="string">&quot;&#x27; with an equivalent definition: replacing [&quot;</span> + oldBeanDefinition +</span><br><span class="line">						<span class="string">&quot;] with [&quot;</span> + beanDefinition + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (hasBeanCreationStarted()) &#123;</span><br><span class="line">			<span class="comment">// Cannot modify startup-time collection elements anymore (for stable iteration)</span></span><br><span class="line">			<span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanDefinitionMap) &#123;</span><br><span class="line">				<span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">				List&lt;String&gt; updatedDefinitions = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.beanDefinitionNames.size() + <span class="number">1</span>);</span><br><span class="line">				updatedDefinitions.addAll(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line">				updatedDefinitions.add(beanName);</span><br><span class="line">				<span class="keyword">this</span>.beanDefinitionNames = updatedDefinitions;</span><br><span class="line">				<span class="keyword">if</span> (<span class="keyword">this</span>.manualSingletonNames.contains(beanName)) &#123;</span><br><span class="line">					Set&lt;String&gt; updatedSingletons = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="keyword">this</span>.manualSingletonNames);</span><br><span class="line">					updatedSingletons.remove(beanName);</span><br><span class="line">					<span class="keyword">this</span>.manualSingletonNames = updatedSingletons;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// Still in startup registration phase</span></span><br><span class="line">			<span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">			<span class="keyword">this</span>.beanDefinitionNames.add(beanName);</span><br><span class="line">			<span class="keyword">this</span>.manualSingletonNames.remove(beanName);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">this</span>.frozenBeanDefinitionNames = <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (oldBeanDefinition != <span class="keyword">null</span> || containsSingleton(beanName)) &#123;</span><br><span class="line">		resetBeanDefinition(beanName);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过观察，其是在一个Map中放入了相应的bean名称和定义，完成的初始化的过程。</p>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h2><p>通过上面的过程，ClassPathXmlApplicationContext完成了Spring IOC的初始化过程，通过设置断点来打印出调用堆栈如下所示：<br>![](/assets/posts/Spring ioc/callStack.png)</p>
<p>从下往上看其可以大概分为四个层次：</p>
<ol>
<li>AbstractXmlApplicationContext 来 <strong>调用</strong>加载Bean definitions的过程；</li>
<li>其通过实例化的局部变量xmlBeanDefinitionReader来 <strong>执行</strong>bean definition的加载过程；</li>
<li>其通过反射的方式实例化BeanDefinitionDocumentReader来完成注册过程；</li>
<li>其通过静态方法BeanDefinitionReaderUtils.registerBeanDefinition()来完成实际的注册。</li>
</ol>
<h2 id="4-思考"><a href="#4-思考" class="headerlink" title="4.思考"></a>4.思考</h2><p>第一个问题：DefaultListableBeanFactory是在哪儿进行实例化的？ 以及其是在哪里进行引入到BeanDefinitionReaderUtils作为入参的？</p>
<p>答：首先，我们分析静态方法的入参是“getReaderContext().getRegistry()”，也就是xmlReaderContext中的公开方法，也就是说需要找到这个成员变量是在哪儿实例化的。那么我们看到步骤中2中，其实例化的代码在AbstractXmlApplicationContext中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XmlBeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(beanFactory);</span><br></pre></td></tr></table></figure>
<p>其入参是一个beanFactory，所以我们就可以找到这个入参是何时实例化就行了。👌，现在我们往上捋，发现调用这个的是AbstractRefreshableApplicationContext的refreshBeanFactory()方法(见2.2)，在这里实例化一个beanFactory并传入其中，其中实例化BeanFactory的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Create an internal bean factory for this context.</span></span><br><span class="line"><span class="comment">	 * Called for each &#123;<span class="doctag">@link</span> #refresh()&#125; attempt.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;The default implementation creates a</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@link</span> org.springframework.beans.factory.support.DefaultListableBeanFactory&#125;</span></span><br><span class="line"><span class="comment">	 * with the &#123;<span class="doctag">@linkplain</span> #getInternalParentBeanFactory() internal bean factory&#125; of this</span></span><br><span class="line"><span class="comment">	 * context&#x27;s parent as parent bean factory. Can be overridden in subclasses,</span></span><br><span class="line"><span class="comment">	 * for example to customize DefaultListableBeanFactory&#x27;s settings.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> the bean factory for this context</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> org.springframework.beans.factory.support.DefaultListableBeanFactory#setAllowBeanDefinitionOverriding</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> org.springframework.beans.factory.support.DefaultListableBeanFactory#setAllowEagerClassLoading</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> org.springframework.beans.factory.support.DefaultListableBeanFactory#setAllowCircularReferences</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> org.springframework.beans.factory.support.DefaultListableBeanFactory#setAllowRawInjectionDespiteWrapping</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> DefaultListableBeanFactory <span class="title">createBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> DefaultListableBeanFactory(getInternalParentBeanFactory());</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>至此，这个问题就捋清楚了。</p>
<p>第二个问题，思考层次化的问题，即为何进行这样的分层？接口的设计逻辑是什么，类继承的逻辑是什么？</p>
<p>解答一：其中关于虚拟类，以及虚拟类方法的定义和设计，可见第三个问题的解释。<br>解答二：通过对 <strong>虚拟类方法</strong>的分析以及 <strong>面向接口编程</strong>的思想，可以看出ClassPathXmlApplicationContext是继承了AbstractXmlApplicationContext的实现类，如名字所示，这个类的主要功能是调用了xmlBeanDefinitionReader来完成加载bean defintions的目的；在往上走的话，可以看出，其中一个主要的虚拟类是AbstractApplicationContext，其定义了加载刷新context的框架refresh()，其中具体的实现及其实现的类层次如下：</p>
<ol>
<li>refreshBeanFactory()虚拟方法是在AbstractRefreshableApplicationContext <strong>虚拟子类</strong>中实现的，此实现执行此上下文的底下的bean工厂的实际刷新，关闭之前的bean factory(如果有的话)，并且为下一轮的上下文生命周期初始化一个崭新的工厂。</li>
<li>在refreshBeanFactory()方法中调用了虚拟方法loadBeanDefinitions()，在虚拟子类AbstractXmlApplicationContext中loadBeanDefinitions()被实现了，其是通过xmlBeanDefinitionReader局部变量来实现的；</li>
<li>xmlBeanDefinitionReader的继承关系如上所示，可以得出，其具体实现通过在方法registerBeanDefinitions()中生成一个BeanDefinitionDocumentReader局部变量来完成。</li>
<li>在BeanDefinitionDocumentReader的实现类中，doRegisterBeanDefinitions方法完成了最后的bean 注册工作。</li>
</ol>
<p>第三个问题，如上面提到的Abstract method的内容：</p>
<p>Rules of Abstract Method</p>
<ol>
<li>Abstract methods don’t have body, they just have method signature as shown above.</li>
<li>If a class has an abstract method it should be declared abstract, the vice versa is not true, which means an abstract class doesn’t need to have an abstract method compulsory.</li>
<li>If a regular class extends an abstract class, then the class must have to implement all the abstract methods of abstract parent class or it has to be declared abstract as well.</li>
</ol>
<p>翻译过来就是说：</p>
<ol>
<li>虚方法没有方法体，只有方法签名；</li>
<li>如果一个类有虚方法，它最好被声明为虚的，但是反过来则不一定，即一个虚的类不一定需要有一个虚方法的义务。</li>
<li>如果一个常规类继承了虚类，则这个类必须实现父类的所有的虚方法， 或则自己被声明为虚的。</li>
</ol>
<p>关于虚拟类方法的文档：<br><a target="_blank" rel="noopener" href="https://beginnersbook.com/2014/01/abstract-method-with-examples-in-java/">Abstract method in Java with examples</a><br><a target="_blank" rel="noopener" href="https://beginnersbook.com/2013/05/java-abstract-class-method/">Abstract Class in Java with example</a></p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ol>
<li>Spring source code, version: 5.0.7.RELEASE</li>
<li><a target="_blank" rel="noopener" href="https://yikun.github.io/2015/05/29/Spring-IOC%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/">Spring IOC核心源码学习</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Robinson</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">27</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Robinson</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
