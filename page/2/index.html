<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Road To Excelsior">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="Road To Excelsior">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Robinson">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Road To Excelsior</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Road To Excelsior</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2019/01/07/plans-in-2019/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Robinson">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Road To Excelsior">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/01/07/plans-in-2019/" class="post-title-link" itemprop="url">Plans in 2019</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-01-07 00:00:00" itemprop="dateCreated datePublished" datetime="2019-01-07T00:00:00+08:00">2019-01-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-05-08 15:53:10" itemprop="dateModified" datetime="2019-05-08T15:53:10+08:00">2019-05-08</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><p>读书，读完一本勾一本，觉得好的做标记再读。</p>
<h2 id="1-书单"><a href="#1-书单" class="headerlink" title="1. 书单"></a>1. 书单</h2><h3 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a>计算机基础</h3><ul>
<li>《计算机科学导论》</li>
<li>《计算机操作系统》</li>
<li>《操作系统原理及应用》</li>
</ul>
<h3 id="Java-基础和进阶"><a href="#Java-基础和进阶" class="headerlink" title="Java 基础和进阶"></a>Java 基础和进阶</h3><ul>
<li>《疯狂Java讲义》</li>
<li>《Java核心基础卷1/2》</li>
<li>《Java编程思想》</li>
<li>《Java 8实战》</li>
<li>《jls11》</li>
<li>《Effective Java》</li>
<li>《Java网络编程 第四版》</li>
<li>《Java性能优化权威指南》</li>
</ul>
<h3 id="Java-并发编程"><a href="#Java-并发编程" class="headerlink" title="Java 并发编程"></a>Java 并发编程</h3><ul>
<li>《Java多线程编程核心技术》</li>
<li>《Java多线程编程实战指南》</li>
<li>《实战Java高并发程序设计》</li>
<li>《Java并发编程实战》</li>
<li>《Java并发编程的艺术》</li>
</ul>
<h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><ul>
<li>《设计模式之禅》</li>
</ul>
<h3 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h3><ul>
<li>《深入理解Java虚拟机(第二版)》</li>
<li>《jvms11》</li>
<li>《hotspot》</li>
<li>《虚拟机参数》</li>
</ul>
<h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><ul>
<li>《Redis入门指南》</li>
<li>《Redis实战中文版》</li>
<li>《Redis设计与实现》</li>
<li>《深入分布式缓存，从原理到实践》</li>
<li>《Redis深度历险：核心原理和应用实践》</li>
<li>《redis设计与实现 第二版》</li>
</ul>
<h3 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h3><ul>
<li>《Mysql数据库应用从入门到精通》</li>
<li>《sql 学习指南》</li>
<li>《数据库索引设计与优化》</li>
<li>《高性能mysql》</li>
<li>《Mysql技术内幕- Innodb 存储引擎》</li>
<li>《分布式数据架构及企业实践-基于Mysql中间件》</li>
<li><a target="_blank" rel="noopener" href="https://www.mysql.com/">Mysql官网</a></li>
</ul>
<h3 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h3><ul>
<li>《Maven实战》</li>
</ul>
<h3 id="Shiro"><a href="#Shiro" class="headerlink" title="Shiro"></a>Shiro</h3><ul>
<li>《跟我学shiro教程》</li>
</ul>
<h3 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h3><ul>
<li>《MongoDB 权威指南（第二版）》</li>
</ul>
<h3 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h3><ul>
<li>《Elasticsearch大数据搜索引擎》</li>
<li>《Elasticsearch服务器开发（第二版）》</li>
<li>《Elasticsearch权威指南（中文版）》</li>
<li>《深入理解Elasticsearch 原书第二版》</li>
</ul>
<h3 id="消息中间件"><a href="#消息中间件" class="headerlink" title="消息中间件"></a>消息中间件</h3><ul>
<li>《分布式消息中间件实践》</li>
</ul>
<h3 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h3><ul>
<li>《RabbitMQ实战指南》</li>
<li>《RabbitMQ实战 高效部署分布式消息队列》</li>
<li>《RabbitMQ 官网》</li>
</ul>
<h3 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h3><ul>
<li>《RocketMQ技术内幕》</li>
<li>《RocketMQ实战与原理解析》</li>
</ul>
<h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><ul>
<li>《Linux命令行与Linux脚本编程大全》</li>
<li>《Unix环境高级编程》</li>
<li>《Unix网络编程》</li>
<li>《Linux系统编程手册》</li>
</ul>
<h3 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h3><ul>
<li>《Netty权威指南》</li>
</ul>
<h3 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h3><ul>
<li>《Nginx高性能Web服务器详解》</li>
<li>《Nginx高性能Web服务器实战教程》</li>
<li>《深入理解Nginx模块开发与架构解析第二版》</li>
</ul>
<h3 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h3><ul>
<li>《精通Spring 4.x++ 企业应用开发实战》</li>
<li>《Spring源码深度解析》</li>
<li>《Spring揭秘》</li>
</ul>
<h3 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a>Spring Boot</h3><ul>
<li>《Spring Boot 2 精髓》</li>
<li>《深入实践Spring Boot》</li>
<li>《Spring Boot 实战》</li>
</ul>
<h3 id="Spring-Cloud"><a href="#Spring-Cloud" class="headerlink" title="Spring Cloud"></a>Spring Cloud</h3><ul>
<li>《Spring Cloud 与 Docker 微服务架构实战》</li>
<li>《Spring Cloud 微服务实战》</li>
<li>《深入理解Spring Cloud 与微服务构建》</li>
<li>《Spring Cloud 微服务架构进阶》</li>
</ul>
<h3 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h3><ul>
<li>《Mybatis 从入门到精通》</li>
<li>《深入浅出Mybatis 技术原理与实战》</li>
</ul>
<h3 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h3><ul>
<li>《Zookeeper 分布式过程协同技术详解》</li>
</ul>
<h3 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a>Dubbo</h3><ul>
<li><a target="_blank" rel="noopener" href="https://dubbo.incubator.apache.org/zh-cn/">Dubbo官方文档</a></li>
</ul>
<h3 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h3><ul>
<li>《Tomcat 与Java Web开发技术详解》</li>
<li>《Tomcat 架构解析》</li>
<li>《tomcat 内核设计剖析》</li>
</ul>
<h3 id="数据结构和算法"><a href="#数据结构和算法" class="headerlink" title="数据结构和算法"></a>数据结构和算法</h3><ul>
<li>《Java 数据结构和算法》</li>
</ul>
<h3 id="Java-编程规范"><a href="#Java-编程规范" class="headerlink" title="Java 编程规范"></a>Java 编程规范</h3><ul>
<li>《阿里巴巴Java 开发手册》<ul>
<li>状态：<code>完成</code>{:.success}</li>
<li>点评：一个小册子，但非常有指导性，可以收藏，时不时浏览一次即可。</li>
</ul>
</li>
<li>《重构，改善既有代码的设计》</li>
<li>《敏捷软件开发》</li>
<li>《单元测试之道 Java版》<ul>
<li>状态：<code>完成</code>{:.success}</li>
<li>点评：对于单元测试非常全面的一本原则性指导的书籍，以较为清晰的逻辑叙述了单元测试的内容，如果有时间，可以再读一遍。</li>
</ul>
</li>
</ul>
<h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><ul>
<li>《图解HTTP》</li>
<li>《图解TCP/IP》</li>
<li>《TCP/IP详解》</li>
</ul>
<h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><ul>
<li>《Design Data Intensive Applications》<ul>
<li>状态：<code>在读</code>{:.info}</li>
<li>点评：非常好的一本书，但是对于无实际项目经验的人，不推荐，里面的一些知识，需要有着实际的项目经验才能把控的全面。</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/12/07/How-To-Read-Code/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Robinson">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Road To Excelsior">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/12/07/How-To-Read-Code/" class="post-title-link" itemprop="url">How To Read Code</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-12-07 00:00:00" itemprop="dateCreated datePublished" datetime="2018-12-07T00:00:00+08:00">2018-12-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-05-08 15:53:10" itemprop="dateModified" datetime="2019-05-08T15:53:10+08:00">2019-05-08</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><p>私以为写代码的最终目的都是为了更快更好的做出为用户服务的好产品，为了能够达到这个目的，就需要阅读前辈写出的好的代码，这样的过程主要有两个目的：1.阅读一些经典的框架代码能够让自己更加清楚的了解框架的作用，明白它的限制范围，同时在出现bug时知道问题具体出现哪里；2.阅读经典的代码可以让自己了解好的代码结构是怎么样的，以便培养出优秀的代码风格和代码框架设计。</p>
<p>那么怎样阅读这些huge, unstructured, maintained-by-dozens-of-people, internally-inconsistent, undocumented的代码呢？</p>
<h2 id="1-Build-and-Run-the-Program"><a href="#1-Build-and-Run-the-Program" class="headerlink" title="1. Build and Run the Program"></a>1. Build and Run the Program</h2><p>能够运行这个程序并且观察它的外部行为，在研究程序内在时是非常有用的。程序的文档同时也很有用，但是文档可能因为一些历史原因而不能保证足够的准确。</p>
<p>能够自行编译程序可以帮助你弄清楚哪些外部库是被调用的，哪个编译器以及链接器是有用的……等。并且，如果可以编译一个debug版本的程序，就可以进行单步调试。<a href="">Study the source with Debugger</a>。</p>
<p>同时，也可以添加或者扩展程序的日志，让它告诉你程序是怎么做的。</p>
<h2 id="2-Find-the-High-Level-Logic"><a href="#2-Find-the-High-Level-Logic" class="headerlink" title="2. Find the High-Level Logic"></a>2. Find the High-Level Logic</h2><p>找到程序的入口，观察程序是如何初始化，运行，并且终结停止的。</p>
<p>大多数的程序会有一个main loop，这一点很重要。（但是如果程序使用了外部框架，那么主循环可能在框架里，而不是在应用程序里）。</p>
<p>发现程序终止的条件。这个包括正常的exits，以及非正常的退出。</p>
<p><em>很多事件驱动，以及面向对象的设计没有”main”入口</em>。</p>
<h2 id="3-Draw-Some-Flowcharts"><a href="#3-Draw-Some-Flowcharts" class="headerlink" title="3. Draw Some Flowcharts"></a>3. Draw Some Flowcharts</h2><p>我们都知道流程图是一种糟糕的设计工具，但是他们被用在分析程序流时却十分有用；你不可能将所有的信息保存在脑袋里，所以，在阅读时，画出一些流程图或者状态图是非常有必要的。需要注意的是，注意关注所有的分支情况。</p>
<h2 id="4-Examine-Library-Calls"><a href="#4-Examine-Library-Calls" class="headerlink" title="4. Examine Library Calls"></a>4. Examine Library Calls</h2><p>如果程序使用了外部的库，检查外部的库调用，并且阅读关于这些调用的文档。（这可能是唯一可用的文档了，所以利用好它）。</p>
<h2 id="5-Search-for-Key-Words"><a href="#5-Search-for-Key-Words" class="headerlink" title="5. Search for Key Words"></a>5. Search for Key Words</h2><p>使用编辑器的查找特性来查找所有关联的关键字。</p>
<h2 id="6-Leverage-the-Power-of-Code-Comprehension-Tools"><a href="#6-Leverage-the-Power-of-Code-Comprehension-Tools" class="headerlink" title="6. Leverage the Power of Code Comprehension Tools"></a>6. Leverage the Power of Code Comprehension Tools</h2><p>一些很棒的技术可以被用来做搜索工具，更好的可以用来分析源代码，以及查找引用，生成流程图。这些东西可以被用来回答以下的问题，对于面向对象的代码：</p>
<ol>
<li>谁调用了这个方法？</li>
<li>谁实现了接口，或者这个类的子类？</li>
<li>哪个是这个类的父类？</li>
<li>在哪里这些类被创建，保存，作为参数或者返回来传递？</li>
<li>这个类覆盖了超类的哪些方法？</li>
<li>在哪里这个类的方法可能被多态调用，比如说，通过一个基类或者接口？</li>
</ol>
<p>这里有一个参考文档：<br>“Comprehension and Visualisation of Object-Oriented Code for Inspections” <a target="_blank" rel="noopener" href="http://www.cis.strath.ac.uk/research/efocs/abstracts.html#EFoCS-33-98">http://www.cis.strath.ac.uk/research/efocs/abstracts.html#EFoCS-33-98</a><br>第五节</p>
<h2 id="7-Print-the-code"><a href="#7-Print-the-code" class="headerlink" title="7. Print the code"></a>7. Print the code</h2><p>可以通过物理标记代码的方法，来加快对代码的理解。对关键的代码画上圈圈，或者重点标注重要的变量。</p>
<h2 id="8-Write-UnitTests"><a href="#8-Write-UnitTests" class="headerlink" title="8. Write UnitTests"></a>8. Write UnitTests</h2><p>通过编写测试<a target="_blank" rel="noopener" href="http://wiki.c2.com/?UnitTest">Unit Test</a>，可以验证你的想法，保证代码按照你的想法来运行，获得正确的答案。<br>如果没有足够的单元测试，那么你肯定需要在修改源代码时，编写足够的单元测试。</p>
<h2 id="9-Comment-the-Code"><a href="#9-Comment-the-Code" class="headerlink" title="9. Comment the Code"></a>9. Comment the Code</h2><p>将代码拷贝进一个个人的CVS或者RCS库中，并且根据你自己的理解来进行标注。当你理解了部分的代码，标记就会改变。这个步骤在你进行重构代码时是一个重要的过程。</p>
<p>对你非常不熟悉代码进行反向工程时一个最好的方式就是通过仔细检查得到 <a target="_blank" rel="noopener" href="http://wiki.c2.com/?HoareTriple">HoareTriples</a>，并且计算出一个流程的最弱的前置条件。了解过程的不变量通常会为其预期目的提供有价值的线索，从而让您从代码中获得理解，往往这些过程不能通过命名不佳的变量来猜测。</p>
<h2 id="10-Clean-Up-the-Code"><a href="#10-Clean-Up-the-Code" class="headerlink" title="10. Clean Up the Code"></a>10. Clean Up the Code</h2><p>一个旧的写作技巧，用于重新熟悉你很久以前写过但忘记了或者用于分析别人的文本的文本，就是随着你的进行编辑它。这就是主动阅读。通过以一种不同的方式或者更愉悦的方式来重写。您可能已经注意到Wiki在重构或重新编辑页面时，您会比阅读它更深入地理解这些材料。代码与写作没有太大区别。</p>
<p>因此，在阅读代码时，请在进行时重新格式化，重新调整空格模板，标注代码。修复拼写，保证代码和编码规范一致。 通常代码是稍微匆忙写的，所以让其他人稍后来使代码看起来更加专业也是另外一个好处。</p>
<p>但是，如果您进行了很多更改，请运行单元测试UnitTests。打破事情不一定是害怕的事情。通过找到系统的较为脆弱的部分和系统的相关依赖部分（通常是你没注意到的），你就可以了解系统。</p>
<p>一篇关于这项技术的文章是”Make bad code good”，在&lt;JavaWorld <a target="_blank" rel="noopener" href="http://www.javaworld.com/javaworld/jw-03-2001/jw-0323-badcode.html&gt;%E3%80%82">http://www.javaworld.com/javaworld/jw-03-2001/jw-0323-badcode.html&gt;。</a></p>
<h2 id="11-总结和思考"><a href="#11-总结和思考" class="headerlink" title="11. 总结和思考"></a>11. 总结和思考</h2><p>这篇文档觉得很有用，所以就翻译了。其主要的宗旨就是一些小技巧和工具来加速和简化大型工程代码的理解和分析过程。上面大多数的技巧我以前也使用过，但是没有形成系统化的思维，所以这次的总结正好弥补了我在总结这方面技巧的短板。同时，关于其对前置条件(路径)的解释，这个是我以前没有关注过的，觉得是一个不错的技巧，无论多么复杂的代码，最终的目的都是通过一个依次有序的步骤来解决一个问题。所以对于前置条件的分析可以很好的找到代码逻辑中的关键路径。也可以很好的描绘出流程图。</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ol>
<li><a target="_blank" rel="noopener" href="http://wiki.c2.com/?TipsForReadingCode">Tips For Reading Code</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/11/20/books%20and%20tasks/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Robinson">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Road To Excelsior">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/11/20/books%20and%20tasks/" class="post-title-link" itemprop="url">books and tasks in 2018</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-11-20 00:00:00" itemprop="dateCreated datePublished" datetime="2018-11-20T00:00:00+08:00">2018-11-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-05-08 15:53:10" itemprop="dateModified" datetime="2019-05-08T15:53:10+08:00">2019-05-08</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><h2 id="1-what-do-i-want-to-do-mostly"><a href="#1-what-do-i-want-to-do-mostly" class="headerlink" title="1. what do i want to do mostly"></a>1. what do i want to do mostly</h2><ol>
<li>to become an open minded and active person full of energy</li>
<li>to help my family to premote their business</li>
<li>to read, to think, to communicate, to work</li>
<li>to become a full stack engineer</li>
<li>to save money and increase the incomes</li>
</ol>
<h2 id="2-steps-to-achieve-all-of-these-fastly-and-solidly"><a href="#2-steps-to-achieve-all-of-these-fastly-and-solidly" class="headerlink" title="2. steps to achieve all of these fastly and solidly"></a>2. steps to achieve all of these fastly and solidly</h2><p>First, to become an open minded and active person full of energy, i need to do following things:</p>
<ol>
<li>execise, 每周至少保证有两天，两到三个小时的运动量，注意在运动时要科学，高效，不要讲时间和精力浪费在没有意义的动作上。</li>
<li>sleep，每天至少保证七个小时的睡眠，注意睡眠时的质量，睡前不要做影响睡眠的事情，注意保暖，卫生和整洁。</li>
<li>hygiene，注意自己衣物，床上用品，房间的整洁，每周不定时的打扫，清理。</li>
<li>food，注意荤素搭配，营养均衡，吃健康的事物，但不拒绝垃圾食品</li>
</ol>
<p>Second, to help my family to premote their business, i need to do following things:</p>
<ol>
<li>communicate with them, to understand their small business, to think how to use my ability to help them.</li>
<li>to iterate fast to show their solutions and revise frequently.</li>
</ol>
<p>Third, to read, to think, to communicate, to work, i need to do following things:</p>
<ol>
<li>books</li>
<li>1 技术类书籍</li>
<li>2 经济学书籍</li>
<li>3 心理学书籍</li>
<li>talk with many person, understand their thoughts, to think what i can to help them.</li>
</ol>
<h2 id="3-书单-实时更新，截止到目前"><a href="#3-书单-实时更新，截止到目前" class="headerlink" title="3 书单(实时更新，截止到目前)"></a>3 书单(实时更新，截止到目前)</h2><h3 id="3-1-技术类书籍-今年读的书籍"><a href="#3-1-技术类书籍-今年读的书籍" class="headerlink" title="3.1.技术类书籍(今年读的书籍)"></a>3.1.技术类书籍(今年读的书籍)</h3><ol>
<li>《web api的设计与开发》 评分：8 状态：在读 后续：读完</li>
<li>《图解http》 评分：6 状态：已读 后续：可再读</li>
<li>《DDD领域驱动设计精简版》 评分：5 状态：已读 后续：放弃</li>
<li>《JavaScript 权威指南(第六版)》 评分：8 状态：在读 后续：阅读最新版</li>
<li>《CSS 权威指南(第三版)》 评分：7 状态：已读完 后续：可再读</li>
<li>《Vue.js 实战》 评分：5 状态：放弃 后续：</li>
<li>《JavaScript DOM编程艺术(第二版)》 评分：8 状态：已读 后续：可再读</li>
<li>《领域驱动设计 软件核心复杂性应对之道》 评分：9 状态：已读第二遍 后续：可补充查阅阅读</li>
<li>《实现领域驱动设计》评分：9 状态：已读 后续：可择机再读</li>
</ol>
<h3 id="3-2-心理学书籍"><a href="#3-2-心理学书籍" class="headerlink" title="3.2.心理学书籍"></a>3.2.心理学书籍</h3><h3 id="3-3-经济学书籍"><a href="#3-3-经济学书籍" class="headerlink" title="3.3.经济学书籍"></a>3.3.经济学书籍</h3><ol>
<li>《经济学原理第五版(微观分册)》评分：8 状态：已读 后续：可再读</li>
<li>《经济学原理第五版(宏观分册)》评分：8 状态：已读 后续：可再读</li>
<li>《就业，利息和货币通论》评分： 状态： 后续：</li>
</ol>
<h3 id="3-4-好的博客文章"><a href="#3-4-好的博客文章" class="headerlink" title="3.4.好的博客文章"></a>3.4.好的博客文章</h3><ol>
<li><a target="_blank" rel="noopener" href="http://www.codeceo.com/article/habits-to-be-better-programmer.html">让你变成优秀程序员的几个小习惯</a></li>
</ol>
<h2 id="3-总结和思考"><a href="#3-总结和思考" class="headerlink" title="3. 总结和思考"></a>3. 总结和思考</h2><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/11/19/Spring-AOP(2)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Robinson">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Road To Excelsior">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/11/19/Spring-AOP(2)/" class="post-title-link" itemprop="url">Spring AOP(2) - 实例化</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-11-19 00:00:00" itemprop="dateCreated datePublished" datetime="2018-11-19T00:00:00+08:00">2018-11-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-12-18 00:44:41" itemprop="dateModified" datetime="2020-12-18T00:44:41+08:00">2020-12-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><p>承接一，在完成了对aop标签的bean的初始化之后，AbstractApplicationContext通过refresh()方法来中的finishBeanFactoryInitialization 来完成对beanFactory中的aop相关的RootBeanDefinition的实例化，其通过为不同的bean生成不同类型的代理（主要是JdkDynamicAopProxy或者ObjenesisCglibAopProxy代理)实现面向切面编程的目的。</p>
<h2 id="1-代理对象实例化"><a href="#1-代理对象实例化" class="headerlink" title="1. 代理对象实例化"></a>1. 代理对象实例化</h2><p>下图显示了通过断点调试的方法打印出了aop 代理对象实例化的过程：</p>
<p>![](/assets/posts/Spring aop instance/aop-instance.png)</p>
<p>通过分析如下，其主要包含了如下几个步骤：</p>
<ol>
<li>判断是否需要为bean生成代理；</li>
<li>创建AopProxy代理接口实现类；</li>
<li>通过接口实现类的getProxy方法来获取<bean>对应的代理；</li>
</ol>
<h3 id="1-1-判断是否为bean生成代理"><a href="#1-1-判断是否为bean生成代理" class="headerlink" title="1.1 判断是否为bean生成代理"></a>1.1 判断是否为bean生成代理</h3><p>在AbstractAutoProxyCreator中，wrapIfNecessary方法显示了什么时候为bean生成代理包装的过程，其主要通过拿到bean对应的Advisor数组，只要Advisor数组不为空，那么就会通过第17行的代码为<bean>创建代理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Wrap the given bean if necessary, i.e. if it is eligible for being proxied.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bean the raw bean instance</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanName the name of the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> cacheKey the cache key for metadata access</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a proxy wrapping the bean, or the raw bean instance as-is</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">wrapIfNecessary</span><span class="params">(Object bean, String beanName, Object cacheKey)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (StringUtils.hasLength(beanName) &amp;&amp; <span class="keyword">this</span>.targetSourcedBeans.contains(beanName)) &#123;</span><br><span class="line">		<span class="keyword">return</span> bean;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (Boolean.FALSE.equals(<span class="keyword">this</span>.advisedBeans.get(cacheKey))) &#123;</span><br><span class="line">		<span class="keyword">return</span> bean;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) &#123;</span><br><span class="line">		<span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">		<span class="keyword">return</span> bean;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Create proxy if we have advice.</span></span><br><span class="line">	Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, <span class="keyword">null</span>);</span><br><span class="line">	<span class="keyword">if</span> (specificInterceptors != DO_NOT_PROXY) &#123;</span><br><span class="line">		<span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.TRUE);</span><br><span class="line">		Object proxy = createProxy(</span><br><span class="line">				bean.getClass(), beanName, specificInterceptors, <span class="keyword">new</span> SingletonTargetSource(bean));</span><br><span class="line">		<span class="keyword">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line">		<span class="keyword">return</span> proxy;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">	<span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里面的AbstractAutoProxyCreator是如何引用在实例化bean中的呢？？在前面的ioc博客中显示，AbstractAutowireCapableBeanFactory作为功能最强大的bean factory，其在实例化bean的过程(initializeBean)中，调用了applyBeanPostProcessorsAfterInitialization()方法，在bean初始化之后进行了后处理。在这个方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">applyBeanPostProcessorsAfterInitialization</span><span class="params">(Object existingBean, String beanName)</span></span></span><br><span class="line"><span class="function">		<span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">	Object result = existingBean;</span><br><span class="line">	<span class="keyword">for</span> (BeanPostProcessor beanProcessor : getBeanPostProcessors()) &#123;</span><br><span class="line">		Object current = beanProcessor.postProcessAfterInitialization(result, beanName);</span><br><span class="line">		<span class="keyword">if</span> (current == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> result;</span><br><span class="line">		&#125;</span><br><span class="line">		result = current;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其调用了父虚拟类的getBeanPostProcessors的方法获得了BeanPostProcessor来完成了对bean的处理，这里AbstractAutoProxyCreator是BeanPostProcessor的一个实现(虚)类。也就是说，在bean factory中已经存在对应的BeanPostProcessor实例来完成对符合条件的bean进行代理对象的创建的。</p>
<p>其中关于AbstractAutoProxyCreator的类层次架构如下：<br>![](/assets/posts/Spring aop instance/AbstractAutoProxyCreator.png)</p>
<h3 id="1-2-创建AopProxy代理接口实现类"><a href="#1-2-创建AopProxy代理接口实现类" class="headerlink" title="1.2 创建AopProxy代理接口实现类"></a>1.2 创建AopProxy代理接口实现类</h3><p>在AbstractAutoProxyCreator中,createProxy方法用来为给定的bean创建AOP代理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create an AOP proxy for the given bean.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanClass the class of the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanName the name of the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> specificInterceptors the set of interceptors that is</span></span><br><span class="line"><span class="comment"> * specific to this bean (may be empty, but not null)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> targetSource the TargetSource for the proxy,</span></span><br><span class="line"><span class="comment"> * already pre-configured to access the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the AOP proxy for the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #buildAdvisors</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createProxy</span><span class="params">(Class&lt;?&gt; beanClass, <span class="meta">@Nullable</span> String beanName,</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="meta">@Nullable</span> Object[] specificInterceptors, TargetSource targetSource)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.beanFactory <span class="keyword">instanceof</span> ConfigurableListableBeanFactory) &#123;</span><br><span class="line">		AutoProxyUtils.exposeTargetClass((ConfigurableListableBeanFactory) <span class="keyword">this</span>.beanFactory, beanName, beanClass);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ProxyFactory proxyFactory = <span class="keyword">new</span> ProxyFactory();</span><br><span class="line">	proxyFactory.copyFrom(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!proxyFactory.isProxyTargetClass()) &#123;</span><br><span class="line">		<span class="keyword">if</span> (shouldProxyTargetClass(beanClass, beanName)) &#123;</span><br><span class="line">			proxyFactory.setProxyTargetClass(<span class="keyword">true</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			evaluateProxyInterfaces(beanClass, proxyFactory);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Advisor[] advisors = buildAdvisors(beanName, specificInterceptors);</span><br><span class="line">	proxyFactory.addAdvisors(advisors);</span><br><span class="line">	proxyFactory.setTargetSource(targetSource);</span><br><span class="line">	customizeProxyFactory(proxyFactory);</span><br><span class="line"></span><br><span class="line">	proxyFactory.setFrozen(<span class="keyword">this</span>.freezeProxy);</span><br><span class="line">	<span class="keyword">if</span> (advisorsPreFiltered()) &#123;</span><br><span class="line">		proxyFactory.setPreFiltered(<span class="keyword">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> proxyFactory.getProxy(getProxyClassLoader());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进入最后一行的工厂方法中，proxyFactory.getProxy()的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create a new proxy according to the settings in this factory.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Can be called repeatedly. Effect will vary if we&#x27;ve added</span></span><br><span class="line"><span class="comment"> * or removed interfaces. Can add and remove interceptors.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Uses the given class loader (if necessary for proxy creation).</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> classLoader the class loader to create the proxy with</span></span><br><span class="line"><span class="comment"> * (or &#123;<span class="doctag">@code</span> null&#125; for the low-level proxy facility&#x27;s default)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the proxy object</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(<span class="meta">@Nullable</span> ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> createAopProxy().getProxy(classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见，这个方法根据这个工厂的设定来创建一个新的代理。先看看，这个工厂类的继承层次：<br>![](/assets/posts/Spring aop instance/ProxyFactory.png)</p>
<p>进入方法可见，其调用ProxyCreatorSupport的方法来获取指定的AopProxy代理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Subclasses should call this to get a new AOP proxy. They should &lt;b&gt;not&lt;/b&gt;</span></span><br><span class="line"><span class="comment"> * create an AOP proxy with &#123;<span class="doctag">@code</span> this&#125; as an argument.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> AopProxy <span class="title">createAopProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!<span class="keyword">this</span>.active) &#123;</span><br><span class="line">		activate();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> getAopProxyFactory().createAopProxy(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>hold on。那么问题来了，哪里获取指定的proxy实例呢，答案在getAopProxyFactory方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> AopProxyFactory aopProxyFactory;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the AopProxyFactory that this ProxyConfig uses.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AopProxyFactory <span class="title">getAopProxyFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.aopProxyFactory;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>即，其通过AopProxyFactory的工厂实现类完成了对不同类型的bean选择不同的proxy的过程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultAopProxyFactory</span> <span class="keyword">implements</span> <span class="title">AopProxyFactory</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> AopProxy <span class="title">createAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class="line">			Class&lt;?&gt; targetClass = config.getTargetClass();</span><br><span class="line">			<span class="keyword">if</span> (targetClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">&quot;TargetSource cannot determine target class: &quot;</span> +</span><br><span class="line">						<span class="string">&quot;Either an interface or a target is required for proxy creation.&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> ObjenesisCglibAopProxy(config);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Determine whether the supplied &#123;<span class="doctag">@link</span> AdvisedSupport&#125; has only the</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@link</span> org.springframework.aop.SpringProxy&#125; interface specified</span></span><br><span class="line"><span class="comment">	 * (or no proxy interfaces specified at all).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">hasNoUserSuppliedProxyInterfaces</span><span class="params">(AdvisedSupport config)</span> </span>&#123;</span><br><span class="line">		Class&lt;?&gt;[] ifcs = config.getProxiedInterfaces();</span><br><span class="line">		<span class="keyword">return</span> (ifcs.length == <span class="number">0</span> || (ifcs.length == <span class="number">1</span> &amp;&amp; SpringProxy.class.isAssignableFrom(ifcs[<span class="number">0</span>])));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>平时我们说AOP原理三句话就能概括：</p>
<ol>
<li>对类生成代理使用CGLIB</li>
<li>对接口生成代理使用JDK原生的Proxy</li>
<li>可以通过配置文件指定对接口使用CGLIB生成代理</li>
</ol>
<p>其中，关于CGLIB的介绍，可见参考文档一，关于JDK PROXY可见参考文档二。</p>
<h3 id="1-3-通过getProxy方法来获取对应的代理"><a href="#1-3-通过getProxy方法来获取对应的代理" class="headerlink" title="1.3 通过getProxy方法来获取对应的代理"></a>1.3 通过getProxy方法来获取<bean>对应的代理</h3><p>关于AopProxy接口的定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.aop.framework;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.lang.Nullable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Delegate interface for a configured AOP proxy, allowing for the creation</span></span><br><span class="line"><span class="comment"> * of actual proxy objects.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Out-of-the-box implementations are available for JDK dynamic proxies</span></span><br><span class="line"><span class="comment"> * and for CGLIB proxies, as applied by &#123;<span class="doctag">@link</span> DefaultAopProxyFactory&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Rod Johnson</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Juergen Hoeller</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> DefaultAopProxyFactory</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AopProxy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Create a new proxy object.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Uses the AopProxy&#x27;s default class loader (if necessary for proxy creation):</span></span><br><span class="line"><span class="comment">	 * usually, the thread context class loader.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> the new proxy object (never &#123;<span class="doctag">@code</span> null&#125;)</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> Thread#getContextClassLoader()</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function">Object <span class="title">getProxy</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Create a new proxy object.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Uses the given class loader (if necessary for proxy creation).</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@code</span> null&#125; will simply be passed down and thus lead to the low-level</span></span><br><span class="line"><span class="comment">	 * proxy facility&#x27;s default, which is usually different from the default chosen</span></span><br><span class="line"><span class="comment">	 * by the AopProxy implementation&#x27;s &#123;<span class="doctag">@link</span> #getProxy()&#125; method.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> classLoader the class loader to create the proxy with</span></span><br><span class="line"><span class="comment">	 * (or &#123;<span class="doctag">@code</span> null&#125; for the low-level proxy facility&#x27;s default)</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> the new proxy object (never &#123;<span class="doctag">@code</span> null&#125;)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function">Object <span class="title">getProxy</span><span class="params">(<span class="meta">@Nullable</span> ClassLoader classLoader)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在我们的样例中，采用的是CglibAopProxy来获取代理，关于Cglib的相关介绍，可见参考文档一。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(<span class="meta">@Nullable</span> ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">		logger.debug(<span class="string">&quot;Creating CGLIB proxy: target source is &quot;</span> + <span class="keyword">this</span>.advised.getTargetSource());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		Class&lt;?&gt; rootClass = <span class="keyword">this</span>.advised.getTargetClass();</span><br><span class="line">		Assert.state(rootClass != <span class="keyword">null</span>, <span class="string">&quot;Target class must be available for creating a CGLIB proxy&quot;</span>);</span><br><span class="line"></span><br><span class="line">		Class&lt;?&gt; proxySuperClass = rootClass;</span><br><span class="line">		<span class="keyword">if</span> (ClassUtils.isCglibProxyClass(rootClass)) &#123;</span><br><span class="line">			proxySuperClass = rootClass.getSuperclass();</span><br><span class="line">			Class&lt;?&gt;[] additionalInterfaces = rootClass.getInterfaces();</span><br><span class="line">			<span class="keyword">for</span> (Class&lt;?&gt; additionalInterface : additionalInterfaces) &#123;</span><br><span class="line">				<span class="keyword">this</span>.advised.addInterface(additionalInterface);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Validate the class, writing log messages as necessary.</span></span><br><span class="line">		validateClassIfNecessary(proxySuperClass, classLoader);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Configure CGLIB Enhancer...</span></span><br><span class="line">		Enhancer enhancer = createEnhancer();</span><br><span class="line">		<span class="keyword">if</span> (classLoader != <span class="keyword">null</span>) &#123;</span><br><span class="line">			enhancer.setClassLoader(classLoader);</span><br><span class="line">			<span class="keyword">if</span> (classLoader <span class="keyword">instanceof</span> SmartClassLoader &amp;&amp;</span><br><span class="line">					((SmartClassLoader) classLoader).isClassReloadable(proxySuperClass)) &#123;</span><br><span class="line">				enhancer.setUseCache(<span class="keyword">false</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		enhancer.setSuperclass(proxySuperClass);</span><br><span class="line">		enhancer.setInterfaces(AopProxyUtils.completeProxiedInterfaces(<span class="keyword">this</span>.advised));</span><br><span class="line">		enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);</span><br><span class="line">		enhancer.setStrategy(<span class="keyword">new</span> ClassLoaderAwareUndeclaredThrowableStrategy(classLoader));</span><br><span class="line"></span><br><span class="line">		Callback[] callbacks = getCallbacks(rootClass);</span><br><span class="line">		Class&lt;?&gt;[] types = <span class="keyword">new</span> Class&lt;?&gt;[callbacks.length];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; types.length; x++) &#123;</span><br><span class="line">			types[x] = callbacks[x].getClass();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// fixedInterceptorMap only populated at this point, after getCallbacks call above</span></span><br><span class="line">		enhancer.setCallbackFilter(<span class="keyword">new</span> ProxyCallbackFilter(</span><br><span class="line">				<span class="keyword">this</span>.advised.getConfigurationOnlyCopy(), <span class="keyword">this</span>.fixedInterceptorMap, <span class="keyword">this</span>.fixedInterceptorOffset));</span><br><span class="line">		enhancer.setCallbackTypes(types);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Generate the proxy class and create a proxy instance.</span></span><br><span class="line">		<span class="keyword">return</span> createProxyClassAndInstance(enhancer, callbacks);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (CodeGenerationException | IllegalArgumentException ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">&quot;Could not generate CGLIB subclass of &quot;</span> + <span class="keyword">this</span>.advised.getTargetClass() +</span><br><span class="line">				<span class="string">&quot;: Common causes of this problem include using a final class or a non-visible class&quot;</span>,</span><br><span class="line">				ex);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">		<span class="comment">// TargetSource.getTarget() failed</span></span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">&quot;Unexpected AOP exception&quot;</span>, ex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码时CglibAopProxy的getProxy()方法，在这里面，通过设置合适的enhancer，以及callbacks，然后调用create方法来创建代理对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createProxyClassAndInstance</span><span class="params">(Enhancer enhancer, Callback[] callbacks)</span> </span>&#123;</span><br><span class="line">	enhancer.setInterceptDuringConstruction(<span class="keyword">false</span>);</span><br><span class="line">	enhancer.setCallbacks(callbacks);</span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">this</span>.constructorArgs != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.constructorArgTypes != <span class="keyword">null</span> ?</span><br><span class="line">			enhancer.create(<span class="keyword">this</span>.constructorArgTypes, <span class="keyword">this</span>.constructorArgs) :</span><br><span class="line">			enhancer.create());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结和思考"><a href="#总结和思考" class="headerlink" title="总结和思考"></a>总结和思考</h2><p>通过阅读spring aop的代码，可以发现，spring aop实现，主要是通过将 &lt;aop: advisor&gt; 标签来解析成 RootBeanDefinition 来完成对aop 代理对象的定义，然后在通过两种不同的代理生成方法，cglib以及jdk proxy的方法来完成对代理对象的生成。</p>
<p>那么，RootBeanDefinition的定义是如何的呢？他是如何表示不同的切点，通知等这些aop的概念的呢？这个问题值得深入探讨一下。</p>
<p>另外，cglib 以及 jdk proxy 是如何对RootBeanDefinition就行解析来完成代理对象的构建的呢？</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ol>
<li><a target="_blank" rel="noopener" href="https://ustccat.github.io/2018/10/18/CGLib.html">cglib</a></li>
<li><a target="_blank" rel="noopener" href="https://ustccat.github.io/2018/10/27/Java-Proxy.html">JDK Dynamic Proxy</a></li>
<li><a target="_blank" rel="noopener" href="http://www.importnew.com/24459.html">Spring源码分析：AOP源码解析（下篇）</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/10/27/Java-Proxy/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Robinson">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Road To Excelsior">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/10/27/Java-Proxy/" class="post-title-link" itemprop="url">JDK Dynamic Proxy</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-10-27 00:00:00" itemprop="dateCreated datePublished" datetime="2018-10-27T00:00:00+08:00">2018-10-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-05-08 15:53:10" itemprop="dateModified" datetime="2019-05-08T15:53:10+08:00">2019-05-08</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><p>代理是一种设计模式。当我们想增加或者修改一个已经存在类中的方法，我们可以通过创建并使用代理对象来实现。通常，代理对象具有与原始对象相同的方法，并且在Java代理类中通常会扩展原始类。代理有一个原始对象的句柄，可以调用该对象的方法。</p>
<h2 id="1-从一个简单的例子开始"><a href="#1-从一个简单的例子开始" class="headerlink" title="1.从一个简单的例子开始"></a>1.从一个简单的例子开始</h2><p>1.首先，新建一个需要进行动态代理的接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 需要动态代理的接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 你好</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">SayHello</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 再见</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">SayGoodBye</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.再创建需要代理的实际对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实际对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 你好</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">SayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello &quot;</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 再见</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">SayGoodBye</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot; good bye &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.调用处理器实现类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 调用处理器实现类</span></span><br><span class="line"><span class="comment"> * 每次生成动态代理类对象时都需要指定一个实现了该接口的调用处理器对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InvocationHandlerImpl</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个就是我们要代理的真实对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Object subject;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法，给我们要代理的真实对象赋初值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> subject</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InvocationHandlerImpl</span><span class="params">(Object subject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subject = subject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该方法负责集中处理动态代理类上的所有方法调用。</span></span><br><span class="line"><span class="comment">     * 调用处理器根据这三个参数进行预处理或分派到委托类实例上反射执行</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proxy  方法被调用的代理类实例</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method 被调用的方法对象；对应接口方法中的方法实例，其在代理对象中被调用。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args   调用参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">//在代理真实对象前我们可以添加一些自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;在调用之前，我要干点啥呢？&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Method:&quot;</span> + method);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当代理对象调用真实对象的方法时，其会自动的跳转到代理对象关联的handler对象的invoke方法来进行调用</span></span><br><span class="line">        Object returnValue = method.invoke(subject, args);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在代理真实对象后我们也可以添加一些自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;在调用之后，我要干点啥呢？&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> returnValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.测试结果如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 动态代理演示</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxyDemonstration</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//代理的真实对象</span></span><br><span class="line">        Subject realSubject = <span class="keyword">new</span> RealSubject();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * InvocationHandlerImpl 实现了 InvocationHandler 接口，并能实现方法调用从代理类到委托类的分派转发</span></span><br><span class="line"><span class="comment">         * 其内部通常包含指向委托类实例的引用，用于真正执行分派转发过来的方法调用.</span></span><br><span class="line"><span class="comment">         * 即：要代理哪个真实对象，就将该对象传进去，最后是通过该真实对象来调用其方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        InvocationHandler handler = <span class="keyword">new</span> InvocationHandlerImpl(realSubject);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        ClassLoader loader = realSubject.getClass().getClassLoader();</span><br><span class="line">        Class[] interfaces = realSubject.getClass().getInterfaces();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 该方法用于为指定类装载器、一组接口及调用处理器生成动态代理类实例，其中包括：</span></span><br><span class="line"><span class="comment">         * 1. 类加载器</span></span><br><span class="line"><span class="comment">         * 2. 一组代理将会实现的接口</span></span><br><span class="line"><span class="comment">         * 3. 调用处理器</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Subject subject = (Subject) Proxy.newProxyInstance(loader, interfaces, handler);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;动态代理对象的类型：&quot;</span>+subject.getClass().getName());</span><br><span class="line"></span><br><span class="line">        String hello = subject.SayHello(<span class="string">&quot;jiankunking&quot;</span>);</span><br><span class="line">        System.out.println(hello);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">动态代理对象的类型：com.sun.proxy.$Proxy0</span><br><span class="line">在调用之前，我要干点啥呢？</span><br><span class="line">Method:public abstract java.lang.String com.example.demo.Subject.SayHello(java.lang.String)</span><br><span class="line">在调用之后，我要干点啥呢？</span><br><span class="line">hello jiankunking</span><br></pre></td></tr></table></figure>

<h2 id="2-动态代理的实现"><a href="#2-动态代理的实现" class="headerlink" title="2.动态代理的实现"></a>2.动态代理的实现</h2><p>首先，通过Proxy.newProxyInstance()静态方法来为指定的接口生成代理类实例，其将方法调用分派给指定的调用句柄。其源代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      Class&lt;?&gt;[] interfaces,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      InvocationHandler h)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IllegalArgumentException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Objects.requireNonNull(h);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Class&lt;?&gt;[] intfs = interfaces.clone();</span><br><span class="line">    <span class="keyword">final</span> SecurityManager sm = System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">        checkProxyAccess(Reflection.getCallerClass(), loader, intfs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Look up or generate the designated proxy class.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Invoke its constructor with the designated invocation handler.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">            checkNewProxyPermission(Reflection.getCallerClass(), cl);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</span><br><span class="line">        <span class="keyword">final</span> InvocationHandler ih = h;</span><br><span class="line">        <span class="keyword">if</span> (!Modifier.isPublic(cl.getModifiers())) &#123;</span><br><span class="line">            AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    cons.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cons.newInstance(<span class="keyword">new</span> Object[]&#123;h&#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException|InstantiationException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e.toString(), e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">        Throwable t = e.getCause();</span><br><span class="line">        <span class="keyword">if</span> (t <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (RuntimeException) t;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(t.toString(), t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e.toString(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个静态类方法中，主要包含两个步骤：</p>
<ol>
<li>获取与指定类加载器和一组接口相关的代理类类型对象</li>
<li>通过反射获取构造函数对象并生成代理类实例</li>
</ol>
<h3 id="2-1-获取代理类类型对象"><a href="#2-1-获取代理类类型对象" class="headerlink" title="2.1 获取代理类类型对象"></a>2.1 获取代理类类型对象</h3><p>进入getProxyClass0()方法观察代理类对象的实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Generate a proxy class.  Must call the checkProxyAccess method</span></span><br><span class="line"><span class="comment"> * to perform permission checks before calling this.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Class&lt;?&gt; getProxyClass0(ClassLoader loader,</span><br><span class="line">                                       Class&lt;?&gt;... interfaces) &#123;</span><br><span class="line">    <span class="keyword">if</span> (interfaces.length &gt; <span class="number">65535</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;interface limit exceeded&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the proxy class defined by the given loader implementing</span></span><br><span class="line">    <span class="comment">// the given interfaces exists, this will simply return the cached copy;</span></span><br><span class="line">    <span class="comment">// otherwise, it will create the proxy class via the ProxyClassFactory</span></span><br><span class="line">    <span class="keyword">return</span> proxyClassCache.get(loader, interfaces);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代理类的缓存</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * a cache of proxy classes</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> WeakCache&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt;</span><br><span class="line">    proxyClassCache = <span class="keyword">new</span> WeakCache&lt;&gt;(<span class="keyword">new</span> KeyFactory(), <span class="keyword">new</span> ProxyClassFactory());</span><br><span class="line"></span><br><span class="line"><span class="comment">//WeakCache中的get方法的实现</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Look-up the value through the cache. This always evaluates the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> subKeyFactory&#125; function and optionally evaluates</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> valueFactory&#125; function if there is no entry in the cache for given</span></span><br><span class="line"><span class="comment"> * pair of (key, subKey) or the entry has already been cleared.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key       possibly null key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parameter parameter used together with key to create sub-key and</span></span><br><span class="line"><span class="comment"> *                  value (should not be null)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the cached value (never null)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if &#123;<span class="doctag">@code</span> parameter&#125; passed in or</span></span><br><span class="line"><span class="comment"> *                              &#123;<span class="doctag">@code</span> sub-key&#125; calculated by</span></span><br><span class="line"><span class="comment"> *                              &#123;<span class="doctag">@code</span> subKeyFactory&#125; or &#123;<span class="doctag">@code</span> value&#125;</span></span><br><span class="line"><span class="comment"> *                              calculated by &#123;<span class="doctag">@code</span> valueFactory&#125; is null.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key, P parameter)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(parameter);</span><br><span class="line"></span><br><span class="line">    expungeStaleEntries();</span><br><span class="line"></span><br><span class="line">    Object cacheKey = CacheKey.valueOf(key, refQueue);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// lazily install the 2nd level valuesMap for the particular cacheKey</span></span><br><span class="line">    ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; valuesMap = map.get(cacheKey);</span><br><span class="line">    <span class="keyword">if</span> (valuesMap == <span class="keyword">null</span>) &#123;</span><br><span class="line">        ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; oldValuesMap</span><br><span class="line">            = map.putIfAbsent(cacheKey,</span><br><span class="line">                              valuesMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;());</span><br><span class="line">        <span class="keyword">if</span> (oldValuesMap != <span class="keyword">null</span>) &#123;</span><br><span class="line">            valuesMap = oldValuesMap;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create subKey and retrieve the possible Supplier&lt;V&gt; stored by that</span></span><br><span class="line">    <span class="comment">// subKey from valuesMap</span></span><br><span class="line">    Object subKey = Objects.requireNonNull(subKeyFactory.apply(key, parameter));</span><br><span class="line">    Supplier&lt;V&gt; supplier = valuesMap.get(subKey);</span><br><span class="line">    Factory factory = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (supplier != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// supplier might be a Factory or a CacheValue&lt;V&gt; instance</span></span><br><span class="line">            V value = supplier.get();</span><br><span class="line">            <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// else no supplier in cache</span></span><br><span class="line">        <span class="comment">// or a supplier that returned null (could be a cleared CacheValue</span></span><br><span class="line">        <span class="comment">// or a Factory that wasn&#x27;t successful in installing the CacheValue)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// lazily construct a Factory</span></span><br><span class="line">        <span class="keyword">if</span> (factory == <span class="keyword">null</span>) &#123;</span><br><span class="line">            factory = <span class="keyword">new</span> Factory(key, parameter, subKey, valuesMap);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (supplier == <span class="keyword">null</span>) &#123;</span><br><span class="line">            supplier = valuesMap.putIfAbsent(subKey, factory);</span><br><span class="line">            <span class="keyword">if</span> (supplier == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// successfully installed Factory</span></span><br><span class="line">                supplier = factory;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// else retry with winning supplier</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (valuesMap.replace(subKey, supplier, factory)) &#123;</span><br><span class="line">                <span class="comment">// successfully replaced</span></span><br><span class="line">                <span class="comment">// cleared CacheEntry / unsuccessful Factory</span></span><br><span class="line">                <span class="comment">// with our Factory</span></span><br><span class="line">                supplier = factory;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// retry with current supplier</span></span><br><span class="line">                supplier = valuesMap.get(subKey);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其首先会判断：如果实现指定接口的类加载器的代理类存在，将会仅仅返回这个代理类的复制(clone)；否则，将会通过代理类工厂创建代理类。</p>
<p>在WeakCache的get方法中，其中一个重要的成员变量是map:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// the key type is Object for supporting null key</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;Object, ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt;&gt; map = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>看注释，其中key的类型为Object是为了支持null的key。可以看出，这个map有两级key，通过cacheKey和subKey可以得到想要的Supplier，关于Supplier的介绍，可见参考文档1。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">..........</span><br><span class="line">Object cacheKey = CacheKey.valueOf(key, refQueue);</span><br><span class="line"></span><br><span class="line"><span class="comment">// lazily install the 2nd level valuesMap for the particular cacheKey</span></span><br><span class="line">ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; valuesMap = map.get(cacheKey);</span><br><span class="line">.........</span><br><span class="line"></span><br><span class="line"><span class="comment">// create subKey and retrieve the possible Supplier&lt;V&gt; stored by that</span></span><br><span class="line"><span class="comment">// subKey from valuesMap</span></span><br><span class="line">Object subKey = Objects.requireNonNull(subKeyFactory.apply(key, parameter));</span><br><span class="line">Supplier&lt;V&gt; supplier = valuesMap.get(subKey);</span><br><span class="line"></span><br><span class="line">.........</span><br></pre></td></tr></table></figure>

<p>在完成对一级key，以及二级key的解析后，就是获取相应的Supplier的过程了，过程如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">.........</span><br><span class="line"><span class="comment">// create subKey and retrieve the possible Supplier&lt;V&gt; stored by that</span></span><br><span class="line"><span class="comment">// subKey from valuesMap</span></span><br><span class="line">Object subKey = Objects.requireNonNull(subKeyFactory.apply(key, parameter));</span><br><span class="line">Supplier&lt;V&gt; supplier = valuesMap.get(subKey);</span><br><span class="line">Factory factory = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (supplier != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// supplier might be a Factory or a CacheValue&lt;V&gt; instance</span></span><br><span class="line">        V value = supplier.get();</span><br><span class="line">        <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// else no supplier in cache</span></span><br><span class="line">    <span class="comment">// or a supplier that returned null (could be a cleared CacheValue</span></span><br><span class="line">    <span class="comment">// or a Factory that wasn&#x27;t successful in installing the CacheValue)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// lazily construct a Factory</span></span><br><span class="line">    <span class="keyword">if</span> (factory == <span class="keyword">null</span>) &#123;</span><br><span class="line">        factory = <span class="keyword">new</span> Factory(key, parameter, subKey, valuesMap);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (supplier == <span class="keyword">null</span>) &#123;</span><br><span class="line">        supplier = valuesMap.putIfAbsent(subKey, factory);</span><br><span class="line">        <span class="keyword">if</span> (supplier == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// successfully installed Factory</span></span><br><span class="line">            supplier = factory;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// else retry with winning supplier</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (valuesMap.replace(subKey, supplier, factory)) &#123;</span><br><span class="line">            <span class="comment">// successfully replaced</span></span><br><span class="line">            <span class="comment">// cleared CacheEntry / unsuccessful Factory</span></span><br><span class="line">            <span class="comment">// with our Factory</span></span><br><span class="line">            supplier = factory;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// retry with current supplier</span></span><br><span class="line">            supplier = valuesMap.get(subKey);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见这里会新建一个Factory实例，并通过Supplier.get()来获取工厂结果，进入Factory.get() 方法中如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A factory &#123;<span class="doctag">@link</span> Supplier&#125; that implements the lazy synchronized</span></span><br><span class="line"><span class="comment"> * construction of the value and installment of it into the cache.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> <span class="keyword">implements</span> <span class="title">Supplier</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">  .................</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="comment">// serialize access</span></span><br><span class="line">        <span class="comment">// re-check</span></span><br><span class="line">        Supplier&lt;V&gt; supplier = valuesMap.get(subKey);</span><br><span class="line">        <span class="keyword">if</span> (supplier != <span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">// something changed while we were waiting:</span></span><br><span class="line">            <span class="comment">// might be that we were replaced by a CacheValue</span></span><br><span class="line">            <span class="comment">// or were removed because of failure -&gt;</span></span><br><span class="line">            <span class="comment">// return null to signal WeakCache.get() to retry</span></span><br><span class="line">            <span class="comment">// the loop</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// else still us (supplier == this)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// create new value</span></span><br><span class="line">        V value = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            value = Objects.requireNonNull(valueFactory.apply(key, parameter));</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123; <span class="comment">// remove us on failure</span></span><br><span class="line">                valuesMap.remove(subKey, <span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// the only path to reach here is with non-null value</span></span><br><span class="line">        <span class="keyword">assert</span> value != <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// wrap value with CacheValue (WeakReference)</span></span><br><span class="line">        CacheValue&lt;V&gt; cacheValue = <span class="keyword">new</span> CacheValue&lt;&gt;(value);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// put into reverseMap</span></span><br><span class="line">        reverseMap.put(cacheValue, Boolean.TRUE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// try replacing us with CacheValue (this should always succeed)</span></span><br><span class="line">        <span class="keyword">if</span> (!valuesMap.replace(subKey, <span class="keyword">this</span>, cacheValue)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">&quot;Should not reach here&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// successfully replaced us with new CacheValue -&gt; return the value</span></span><br><span class="line">        <span class="comment">// wrapped by it</span></span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见，这是一个同步方法，首先其通过重检查，关于重新检查的原因，可以见上面注释，然后通过valueFactory.apply()来完成代理类的生成，现在进入valueFactory类中观察其实如何生成的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A factory function that generates, defines and returns the proxy class given</span></span><br><span class="line"><span class="comment"> * the ClassLoader and array of interfaces.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyClassFactory</span></span></span><br><span class="line">    implements BiFunction&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// prefix for all proxy class names</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String proxyClassNamePrefix = <span class="string">&quot;$Proxy&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// next number to use for generation of unique proxy class names</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicLong nextUniqueNumber = <span class="keyword">new</span> AtomicLong();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) &#123;</span><br><span class="line"></span><br><span class="line">        Map&lt;Class&lt;?&gt;, Boolean&gt; interfaceSet = <span class="keyword">new</span> IdentityHashMap&lt;&gt;(interfaces.length);</span><br><span class="line">        <span class="keyword">for</span> (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Verify that the class loader resolves the name of this</span></span><br><span class="line"><span class="comment">             * interface to the same Class object.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            Class&lt;?&gt; interfaceClass = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                interfaceClass = Class.forName(intf.getName(), <span class="keyword">false</span>, loader);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (interfaceClass != intf) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                    intf + <span class="string">&quot; is not visible from class loader&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Verify that the Class object actually represents an</span></span><br><span class="line"><span class="comment">             * interface.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (!interfaceClass.isInterface()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                    interfaceClass.getName() + <span class="string">&quot; is not an interface&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Verify that this interface is not a duplicate.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (interfaceSet.put(interfaceClass, Boolean.TRUE) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                    <span class="string">&quot;repeated interface: &quot;</span> + interfaceClass.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String proxyPkg = <span class="keyword">null</span>;     <span class="comment">// package to define proxy class in</span></span><br><span class="line">        <span class="keyword">int</span> accessFlags = Modifier.PUBLIC | Modifier.FINAL;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Record the package of a non-public proxy interface so that the</span></span><br><span class="line"><span class="comment">         * proxy class will be defined in the same package.  Verify that</span></span><br><span class="line"><span class="comment">         * all non-public proxy interfaces are in the same package.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class="line">            <span class="keyword">int</span> flags = intf.getModifiers();</span><br><span class="line">            <span class="keyword">if</span> (!Modifier.isPublic(flags)) &#123;</span><br><span class="line">                accessFlags = Modifier.FINAL;</span><br><span class="line">                String name = intf.getName();</span><br><span class="line">                <span class="keyword">int</span> n = name.lastIndexOf(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">                String pkg = ((n == -<span class="number">1</span>) ? <span class="string">&quot;&quot;</span> : name.substring(<span class="number">0</span>, n + <span class="number">1</span>));</span><br><span class="line">                <span class="keyword">if</span> (proxyPkg == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    proxyPkg = pkg;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!pkg.equals(proxyPkg)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                        <span class="string">&quot;non-public interfaces from different packages&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (proxyPkg == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// if no non-public proxy interfaces, use com.sun.proxy package</span></span><br><span class="line">            proxyPkg = ReflectUtil.PROXY_PACKAGE + <span class="string">&quot;.&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Choose a name for the proxy class to generate.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">long</span> num = nextUniqueNumber.getAndIncrement();</span><br><span class="line">        String proxyName = proxyPkg + proxyClassNamePrefix + num;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Generate the specified proxy class.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">byte</span>[] proxyClassFile = ProxyGenerator.generateProxyClass(</span><br><span class="line">            proxyName, interfaces, accessFlags);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> defineClass0(loader, proxyName,</span><br><span class="line">                                proxyClassFile, <span class="number">0</span>, proxyClassFile.length);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassFormatError e) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * A ClassFormatError here means that (barring bugs in the</span></span><br><span class="line"><span class="comment">             * proxy class generation code) there was some other</span></span><br><span class="line"><span class="comment">             * invalid aspect of the arguments supplied to the proxy</span></span><br><span class="line"><span class="comment">             * class creation (such as virtual machine limitations</span></span><br><span class="line"><span class="comment">             * exceeded).</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(e.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见，其可以通过下面的代码生成字节码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Generate the specified proxy class.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">byte</span>[] proxyClassFile = ProxyGenerator.generateProxyClass(proxyName, interfaces, accessFlags);</span><br></pre></td></tr></table></figure>

<p>其中关于ProxyGenerator.generateProxyClass 的用法可见参考文档2。</p>
<h3 id="2-2-通过反射获取构造函数对象并生成代理类实例"><a href="#2-2-通过反射获取构造函数对象并生成代理类实例" class="headerlink" title="2.2 通过反射获取构造函数对象并生成代理类实例"></a>2.2 通过反射获取构造函数对象并生成代理类实例</h3><p>在完成了生成代理类的过程之后，可以往下看，其首先调用了类的构造函数getConstructor()方法来完成工作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</span><br></pre></td></tr></table></figure>

<p>在获得构造器之后，通过调用用构造器方法完成了代理类实例的创建过程，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.....</span><br><span class="line"><span class="keyword">final</span> InvocationHandler ih = h;</span><br><span class="line"><span class="keyword">if</span> (!Modifier.isPublic(cl.getModifiers())) &#123;</span><br><span class="line">    AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                cons.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cons.newInstance(<span class="keyword">new</span> Object[]&#123;h&#125;);</span><br></pre></td></tr></table></figure>

<p>至此，就完成了代理类实例的构建。</p>
<h2 id="3-观察其反编译字节码"><a href="#3-观察其反编译字节码" class="headerlink" title="3.观察其反编译字节码"></a>3.观察其反编译字节码</h2><p>通过保存字节码文件，并通过IDE中Fernflower decompiler插件来观察代理类实例是怎么样子的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Source code recreated from a .class file by IntelliJ IDEA</span></span><br><span class="line"><span class="comment">// (powered by Fernflower decompiler)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.demo.Subject;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.UndeclaredThrowableException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxySubject</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m4;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxySubject</span><span class="params">(InvocationHandler var1)</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object var1)</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Boolean)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m1, <span class="keyword">new</span> Object[]&#123;var1&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var3;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">SayGoodBye</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (String)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m4, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">SayHello</span><span class="params">(String var1)</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (String)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m3, <span class="keyword">new</span> Object[]&#123;var1&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var3;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (String)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m2, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Integer)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m0, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            m1 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;equals&quot;</span>, Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>));</span><br><span class="line">            m4 = Class.forName(<span class="string">&quot;com.example.demo.Subject&quot;</span>).getMethod(<span class="string">&quot;SayGoodBye&quot;</span>);</span><br><span class="line">            m3 = Class.forName(<span class="string">&quot;com.example.demo.Subject&quot;</span>).getMethod(<span class="string">&quot;SayHello&quot;</span>, Class.forName(<span class="string">&quot;java.lang.String&quot;</span>));</span><br><span class="line">            m2 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;toString&quot;</span>);</span><br><span class="line">            m0 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;hashCode&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodError(var2.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoClassDefFoundError(var3.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再见父类Proxy中的有参构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Constructs a new &#123;<span class="doctag">@code</span> Proxy&#125; instance from a subclass</span></span><br><span class="line"><span class="comment">   * (typically, a dynamic proxy class) with the specified value</span></span><br><span class="line"><span class="comment">   * for its invocation handler.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span>  h the invocation handler for this proxy instance</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> NullPointerException if the given invocation handler, &#123;<span class="doctag">@code</span> h&#125;,</span></span><br><span class="line"><span class="comment">   *         is &#123;<span class="doctag">@code</span> null&#125;.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="title">Proxy</span><span class="params">(InvocationHandler h)</span> </span>&#123;</span><br><span class="line">      Objects.requireNonNull(h);</span><br><span class="line">      <span class="keyword">this</span>.h = h;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>由此可见其调用时是调用父类的成员变量InvokeHandler h来完成指定方法的调用，而这个成员变量是在代理类生成时传入的，即实际的方法调用代理给了我们自定义的InvokeHandler的方法。</p>
<h2 id="4-总结和思考"><a href="#4-总结和思考" class="headerlink" title="4.总结和思考"></a>4.总结和思考</h2><p>1.第一个问题，两级缓存的意义在哪里？</p>
<p>2.自己对Java的反射机制还不是很清楚，需要时间来加深理解，毕竟这是写系统代码时必须知道的知识之一。</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ol>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/5b35158a0365">Function、Predicate、Consumer、Supplier接口</a></li>
<li><a target="_blank" rel="noopener" href="https://my.oschina.net/u/2474629/blog/703611">使用ProxyGenerator类生成字节码</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.jobbole.com/104433/">Java JDK 动态代理使用及实现原理分析</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/10/22/Spring-AOP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Robinson">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Road To Excelsior">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/10/22/Spring-AOP/" class="post-title-link" itemprop="url">Spring AOP(1) - 初始化</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-10-22 00:00:00" itemprop="dateCreated datePublished" datetime="2018-10-22T00:00:00+08:00">2018-10-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-12-18 00:44:14" itemprop="dateModified" datetime="2020-12-18T00:44:14+08:00">2020-12-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><p>AOP为面向对象编程提供了另外一种程序结构。在OOP中，最重要的模块化是类，但是在AOP中最重要的模块化单位是切面(Aspect)。在使用面向切面编程时， 我们仍然在一个地方定义通用功能， 但是可以通过声明的方式定义这个功能要以何种方式在何处应用， 而无需修改受影响的类。 横切关注点可以被模块化为特殊的类，这些类被称为切面（ aspect）。</p>
<h2 id="1-专业术语"><a href="#1-专业术语" class="headerlink" title="1.专业术语"></a>1.专业术语</h2><p>与大多数技术相似，AOP已经形成了自己的术语。这些术语不仅限于Spring：</p>
<ol>
<li>Aspect(切面)： 跨越多个类别的关注点的模块化。事务管理是J2EE应用程序中的一个典型跨越多个关注点的切面样例。在Spring AOP中，aspects通常使用常规的类来实现(scheme based approach)，或者在常规类上加注解的方式实现(@AspectJ的方法)。</li>
<li>Joint Point(连接点)：连接点是在 <strong>应用程序执行过程中</strong>能够插入切面的一个点。这个点可以是在调用方法时，抛出异常时，甚至是修改一个字段时。切面代码可以利用这些点插入到应用的正常流程之中， 并添加新的行为。在Spring AOP中，一个连接点总是表示一个 <strong>方法</strong>的执行。</li>
<li>Advice(通知)：在特定连接点处被切面执行的动作。Different types of advice include “around,” “before” and “after” advice. (Advice types are discussed below.) Many AOP frameworks, including Spring, model an advice as an interceptor, maintaining a chain of interceptors around the join point.</li>
<li>Pointcut(切点)： 一个切面并不需要通知应用的所有连接点。 切点有助于缩小切面所通知的连接点的范围。切点的定义会匹配通知所要织入的一个或多个连接点。由 <strong>切入点表达式</strong>匹配的连接点的概念是AOP的核心，而Spring默认使用 <strong>AspectJ切入点表达式语言</strong>。</li>
<li>Introduction(引入)： 引入允许我们向现有的类添加新方法或属性。</li>
<li>Target object(目标对象)：被一个或者多个切面通知的对象。也可以被称为advised object，因为Spring aop是通过运行时代理实现的，这个对象也通常是代理对象。</li>
<li>AOP proxy：被AOP框架创建的对象，用于实现切面合同（通知方法执行等）。在Spring aop中，一个aop代理将会是一个JDK 动态代理或者一个cglib 代理。</li>
<li>Weaving(织入)：织入是把切面应用到目标对象并创建新的代理对象的 <strong>过程</strong>。 切面在指定的连接点被织入到目标对象中。 这可以在编译时（例如使用AspectJ编译器），加载时间或在运行时完成。 与其他纯Java AOP框架一样，Spring AOP在运行时执行编织。</li>
</ol>
<p>Type of Advice:</p>
<ul>
<li>Before advice: 那种在连接点之前执行的通知，但是其没有能力阻止连接点的执行动作的进行。</li>
<li>After returing advice: 那种在连接点正常完成之后执行的通知：例如，一个没有抛出异常的方法返回。</li>
<li>After throwing advice: 如果一个方法存在抛出异常，则这个通知被执行。</li>
<li>After finally advice: 不论连接点的方法是如何退出的（正常退出或者异常退出），这个通知将会被执行。</li>
<li>Around advice: 环绕一个连接点（例如一个方法的调用）的通知。这是最强大的的通知类型。环绕型通知可以在方法调用前或调用后执行定制化的行为。它同时负责选择是否处理连接点或者短路至通知方法执行，通过放回其自己的返回值或者抛出异常。</li>
</ul>
<p>对通知类型的选择的原则是采用最简单明确的方式来完成需求。比如说虽然环绕型通知能够完成前面的所有的类型的工作，但是如果需可以使用简单的通知类型，则使用简单通知类型。</p>
<p>通过 <strong>切入点</strong>匹配的 <strong>连接点</strong>的概念是Spring AOP区别于其他的仅提供拦截的技术。 切入点能够使通知独立的挂载到OO的层次中。例如，一个环绕型的通知提供的声明式的事务管理，能够被应用到横跨多个对象的多个方法中。</p>
<h2 id="2-样例程序"><a href="#2-样例程序" class="headerlink" title="2.样例程序"></a>2.样例程序</h2><p>首先，我们先定一个目标对象Target object类如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleAdder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a , <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在定义一个通知类Advice，这个Advice通过JointPoint，以及PointCut来织入到目标对象中，其定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdderAfterReturnAspect</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">afterReturn</span><span class="params">(Object returnValue)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;value return was: &quot;</span> + returnValue + <span class="string">&quot;;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了简洁以及便于追踪的目的，通过xml配置的方法来进行配置AOP切面：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sampleAdder&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.demo.SampleAdder&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;doAfterReturnAspect&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.demo.AdderAfterReturnAspect&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">&quot;aspects&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;doAfterReturnAspect&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pointCutAfterReturing&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.example.demo.SampleAdder+.*(..))&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">method</span>=<span class="string">&quot;afterReturn&quot;</span> <span class="attr">returning</span>=<span class="string">&quot;returnValue&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pointCutAfterReturing&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value return was: 3;</span><br></pre></td></tr></table></figure>

<h2 id="3-AOP定义的初始化"><a href="#3-AOP定义的初始化" class="headerlink" title="3. AOP定义的初始化"></a>3. AOP定义的初始化</h2><p>关于bean 定义的加载，其中前大部分过程都是类似于Spring bean定义的加载过程，通过设置断点来观察调用堆栈如下：<br>![](/assets/posts/Spring aop/Spring-aop-1.png)</p>
<p>我们同构这个机会着重分析各个独立的类是如何组合起来的：</p>
<ol>
<li>其中AbstractXmlApplicationContext通过成员方法loadBeanDefinitions中生成一个局部变量 XmlBeanDefinitionReader来将工作转交给它完成定义的加载；</li>
<li>XmlBeanDefinitionReader的继承层次可以在前面的Spring ioc章节中看到，其中其通过父抽象类AbstractBeanDefinitionReader做了一些初始化的逻辑，然后自己的成员方法registerBeanDefinitions中初始化一个BeanDefinitionDocumentReader局部对象来完成后续工作；</li>
<li>BeanDefinitionDocumentReader的继承层次也可以从前面的Spring ioc章节中看到，这个类来根据“Spring-beans” DTO以及XSD格式来完成读取bean格式的目的。</li>
<li>BeanDefinitionDocumentReader通过委托的方式，将读取的细致工作移交给BeanDefinitionParserDelegate成员变量来完成。</li>
<li>在BeanDefinitionParserDelegate中，成员方法parseCustomElement() 针对不同的xml元素，生成了不同的NamespaceHandler来完成具体的元素解析的工作。</li>
<li>对应aop的xml元素标签，通过实例化的AopNamespaceHandler来完成完成解析定义的工作。</li>
</ol>
<p>👌，现在来着重观察AopNamespaceHandler对aop定义初始化的过程。</p>
<h3 id="3-1开始解析-lt-aop-gt-标签中的aop-config及其子标签"><a href="#3-1开始解析-lt-aop-gt-标签中的aop-config及其子标签" class="headerlink" title="3.1开始解析&lt;aop&gt;标签中的aop:config及其子标签"></a>3.1开始解析&lt;aop&gt;标签中的aop:config及其子标签</h3><p>其中关于AopNamespaceHandler的继承层次如下：<br>![](/assets/posts/Spring aop/AopNamespaceHandler.png)</p>
<p>在AopNamespaceHandler中，有几个parser，是用于具体便签转换的，分别为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AopNamespaceHandler</span> <span class="keyword">extends</span> <span class="title">NamespaceHandlerSupport</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Register the &#123;<span class="doctag">@link</span> BeanDefinitionParser BeanDefinitionParsers&#125; for the</span></span><br><span class="line"><span class="comment">	 * &#x27;&#123;<span class="doctag">@code</span> config&#125;&#x27;, &#x27;&#123;<span class="doctag">@code</span> spring-configured&#125;&#x27;, &#x27;&#123;<span class="doctag">@code</span> aspectj-autoproxy&#125;&#x27;</span></span><br><span class="line"><span class="comment">	 * and &#x27;&#123;<span class="doctag">@code</span> scoped-proxy&#125;&#x27; tags.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// In 2.0 XSD as well as in 2.1 XSD.</span></span><br><span class="line">		registerBeanDefinitionParser(<span class="string">&quot;config&quot;</span>, <span class="keyword">new</span> ConfigBeanDefinitionParser());</span><br><span class="line">		registerBeanDefinitionParser(<span class="string">&quot;aspectj-autoproxy&quot;</span>, <span class="keyword">new</span> AspectJAutoProxyBeanDefinitionParser());</span><br><span class="line">		registerBeanDefinitionDecorator(<span class="string">&quot;scoped-proxy&quot;</span>, <span class="keyword">new</span> ScopedProxyBeanDefinitionDecorator());</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Only in 2.0 XSD: moved to context namespace as of 2.1</span></span><br><span class="line">		registerBeanDefinitionParser(<span class="string">&quot;spring-configured&quot;</span>, <span class="keyword">new</span> SpringConfiguredBeanDefinitionParser());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在我们的样例中个，因为是config标签，所以使用ConfigBeanDefinitionParser来进行解析，进入ConfigBeanDefinitionParser查看其parse方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">		CompositeComponentDefinition compositeDef =</span><br><span class="line">				<span class="keyword">new</span> CompositeComponentDefinition(element.getTagName(), parserContext.extractSource(element));</span><br><span class="line">		parserContext.pushContainingComponent(compositeDef);</span><br><span class="line"></span><br><span class="line">		configureAutoProxyCreator(parserContext, element);</span><br><span class="line"></span><br><span class="line">		List&lt;Element&gt; childElts = DomUtils.getChildElements(element);</span><br><span class="line">		<span class="keyword">for</span> (Element elt: childElts) &#123;</span><br><span class="line">			String localName = parserContext.getDelegate().getLocalName(elt);</span><br><span class="line">			<span class="keyword">if</span> (POINTCUT.equals(localName)) &#123;</span><br><span class="line">				parsePointcut(elt, parserContext);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (ADVISOR.equals(localName)) &#123;</span><br><span class="line">				parseAdvisor(elt, parserContext);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (ASPECT.equals(localName)) &#123;</span><br><span class="line">				parseAspect(elt, parserContext);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		parserContext.popAndRegisterContainingComponent();</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>因为我们的子元素是aspect，所以进入最后一个分支来执行子元素的解析，其中在parseAspect()中，存在一段代码用来解析aspect标签下面的元素：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// We have to parse &quot;advice&quot; and all the advice kinds in one loop, to get the</span></span><br><span class="line"><span class="comment">// ordering semantics right.</span></span><br><span class="line">NodeList nodeList = aspectElement.getChildNodes();</span><br><span class="line"><span class="keyword">boolean</span> adviceFoundAlready = <span class="keyword">false</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中对aspect元素下面的子标签的判断如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return &#123;<span class="doctag">@code</span> true&#125; if the supplied node describes an advice type. May be one of:</span></span><br><span class="line"><span class="comment"> * &#x27;&#123;<span class="doctag">@code</span> before&#125;&#x27;, &#x27;&#123;<span class="doctag">@code</span> after&#125;&#x27;, &#x27;&#123;<span class="doctag">@code</span> after-returning&#125;&#x27;,</span></span><br><span class="line"><span class="comment"> * &#x27;&#123;<span class="doctag">@code</span> after-throwing&#125;&#x27; or &#x27;&#123;<span class="doctag">@code</span> around&#125;&#x27;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isAdviceNode</span><span class="params">(Node aNode, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!(aNode <span class="keyword">instanceof</span> Element)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		String name = parserContext.getDelegate().getLocalName(aNode);</span><br><span class="line">		<span class="keyword">return</span> (BEFORE.equals(name) || AFTER.equals(name) || AFTER_RETURNING_ELEMENT.equals(name) ||</span><br><span class="line">				AFTER_THROWING_ELEMENT.equals(name) || AROUND.equals(name));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上所示，这个方法用来判断该元素节点下面子节点是不是通知(Advice)节点，其中，可以处理处理&lt; aop:aspect&gt;标签下的&lt; aop:before&gt;、&lt; aop:after&gt;、&lt; aop:after-returning&gt;、&lt; aop:after-throwing method=””&gt;、&lt; aop:around method=””&gt;这五个标签。</p>
<p>在样例中，&lt;aop:after-returning&gt;通过筛选，进入parseAdvice()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用代码如下：</span></span><br><span class="line">AbstractBeanDefinition advisorDefinition = parseAdvice(aspectName, i, aspectElement, (Element) node, parserContext, beanDefinitions, beanReferences);</span><br><span class="line">beanDefinitions.add(advisorDefinition);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//定义的方法如下：</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Parses one of &#x27;&#123;<span class="doctag">@code</span> before&#125;&#x27;, &#x27;&#123;<span class="doctag">@code</span> after&#125;&#x27;, &#x27;&#123;<span class="doctag">@code</span> after-returning&#125;&#x27;,</span></span><br><span class="line"><span class="comment">	 * &#x27;&#123;<span class="doctag">@code</span> after-throwing&#125;&#x27; or &#x27;&#123;<span class="doctag">@code</span> around&#125;&#x27; and registers the resulting</span></span><br><span class="line"><span class="comment">	 * BeanDefinition with the supplied BeanDefinitionRegistry.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> the generated advice RootBeanDefinition</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> AbstractBeanDefinition <span class="title">parseAdvice</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			String aspectName, <span class="keyword">int</span> order, Element aspectElement, Element adviceElement, ParserContext parserContext,</span></span></span><br><span class="line"><span class="function"><span class="params">			List&lt;BeanDefinition&gt; beanDefinitions, List&lt;BeanReference&gt; beanReferences)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">this</span>.parseState.push(<span class="keyword">new</span> AdviceEntry(parserContext.getDelegate().getLocalName(adviceElement)));</span><br><span class="line"></span><br><span class="line">			<span class="comment">// create the method factory bean</span></span><br><span class="line">      <span class="comment">// 创建方法工厂bean</span></span><br><span class="line">			RootBeanDefinition methodDefinition = <span class="keyword">new</span> RootBeanDefinition(MethodLocatingFactoryBean.class);</span><br><span class="line">			methodDefinition.getPropertyValues().add(<span class="string">&quot;targetBeanName&quot;</span>, aspectName);</span><br><span class="line">			methodDefinition.getPropertyValues().add(<span class="string">&quot;methodName&quot;</span>, adviceElement.getAttribute(<span class="string">&quot;method&quot;</span>));</span><br><span class="line">			methodDefinition.setSynthetic(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// create instance factory definition</span></span><br><span class="line">      <span class="comment">// 创建实例工厂定义</span></span><br><span class="line">			RootBeanDefinition aspectFactoryDef =</span><br><span class="line">					<span class="keyword">new</span> RootBeanDefinition(SimpleBeanFactoryAwareAspectInstanceFactory.class);</span><br><span class="line">			aspectFactoryDef.getPropertyValues().add(<span class="string">&quot;aspectBeanName&quot;</span>, aspectName);</span><br><span class="line">			aspectFactoryDef.setSynthetic(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// register the pointcut</span></span><br><span class="line">      <span class="comment">// 注册切入点</span></span><br><span class="line">			AbstractBeanDefinition adviceDef = createAdviceDefinition(</span><br><span class="line">					adviceElement, parserContext, aspectName, order, methodDefinition, aspectFactoryDef,</span><br><span class="line">					beanDefinitions, beanReferences);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// configure the advisor</span></span><br><span class="line">      <span class="comment">// 配置advisor</span></span><br><span class="line">			RootBeanDefinition advisorDefinition = <span class="keyword">new</span> RootBeanDefinition(AspectJPointcutAdvisor.class);</span><br><span class="line">			advisorDefinition.setSource(parserContext.extractSource(adviceElement));</span><br><span class="line">			advisorDefinition.getConstructorArgumentValues().addGenericArgumentValue(adviceDef);</span><br><span class="line">			<span class="keyword">if</span> (aspectElement.hasAttribute(ORDER_PROPERTY)) &#123;</span><br><span class="line">				advisorDefinition.getPropertyValues().add(</span><br><span class="line">						ORDER_PROPERTY, aspectElement.getAttribute(ORDER_PROPERTY));</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// register the final advisor</span></span><br><span class="line">      <span class="comment">// 注册最终的advisor</span></span><br><span class="line">			parserContext.getReaderContext().registerWithGeneratedName(advisorDefinition);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> advisorDefinition;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="keyword">this</span>.parseState.pop();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>在这个方法中，主要做了三件事：</p>
<ol>
<li>根据织入方式（before、after这些）创建RootBeanDefinition，名为adviceDef即advice定义</li>
<li>将上一步创建的RootBeanDefinition写入一个新的RootBeanDefinition，构造一个新的对象，名为advisorDefinition，即advisor定义</li>
<li>将advisorDefinition注册到DefaultListableBeanFactory中</li>
</ol>
<p>进入创建通知定义的方法createAdviceDefinition()中，可以看到如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates the RootBeanDefinition for a POJO advice bean. Also causes pointcut</span></span><br><span class="line"><span class="comment"> * parsing to occur so that the pointcut may be associate with the advice bean.</span></span><br><span class="line"><span class="comment"> * This same pointcut is also configured as the pointcut for the enclosing</span></span><br><span class="line"><span class="comment"> * Advisor definition using the supplied MutablePropertyValues.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> AbstractBeanDefinition <span class="title">createAdviceDefinition</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">		Element adviceElement, ParserContext parserContext, String aspectName, <span class="keyword">int</span> order,</span></span></span><br><span class="line"><span class="function"><span class="params">		RootBeanDefinition methodDef, RootBeanDefinition aspectFactoryDef,</span></span></span><br><span class="line"><span class="function"><span class="params">		List&lt;BeanDefinition&gt; beanDefinitions, List&lt;BeanReference&gt; beanReferences)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	RootBeanDefinition adviceDefinition = <span class="keyword">new</span> RootBeanDefinition(getAdviceClass(adviceElement, parserContext));</span><br><span class="line">	adviceDefinition.setSource(parserContext.extractSource(adviceElement));</span><br><span class="line"></span><br><span class="line">	adviceDefinition.getPropertyValues().add(ASPECT_NAME_PROPERTY, aspectName);</span><br><span class="line">	adviceDefinition.getPropertyValues().add(DECLARATION_ORDER_PROPERTY, order);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (adviceElement.hasAttribute(RETURNING)) &#123;</span><br><span class="line">		adviceDefinition.getPropertyValues().add(</span><br><span class="line">				RETURNING_PROPERTY, adviceElement.getAttribute(RETURNING));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (adviceElement.hasAttribute(THROWING)) &#123;</span><br><span class="line">		adviceDefinition.getPropertyValues().add(</span><br><span class="line">				THROWING_PROPERTY, adviceElement.getAttribute(THROWING));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (adviceElement.hasAttribute(ARG_NAMES)) &#123;</span><br><span class="line">		adviceDefinition.getPropertyValues().add(</span><br><span class="line">				ARG_NAMES_PROPERTY, adviceElement.getAttribute(ARG_NAMES));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ConstructorArgumentValues cav = adviceDefinition.getConstructorArgumentValues();</span><br><span class="line">	cav.addIndexedArgumentValue(METHOD_INDEX, methodDef);</span><br><span class="line"></span><br><span class="line">	Object pointcut = parsePointcutProperty(adviceElement, parserContext);</span><br><span class="line">	<span class="keyword">if</span> (pointcut <span class="keyword">instanceof</span> BeanDefinition) &#123;</span><br><span class="line">		cav.addIndexedArgumentValue(POINTCUT_INDEX, pointcut);</span><br><span class="line">		beanDefinitions.add((BeanDefinition) pointcut);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (pointcut <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">		RuntimeBeanReference pointcutRef = <span class="keyword">new</span> RuntimeBeanReference((String) pointcut);</span><br><span class="line">		cav.addIndexedArgumentValue(POINTCUT_INDEX, pointcutRef);</span><br><span class="line">		beanReferences.add(pointcutRef);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cav.addIndexedArgumentValue(ASPECT_INSTANCE_FACTORY_INDEX, aspectFactoryDef);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> adviceDefinition;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中可见创建的AbstractBeanDefinition实例是RootBeanDefinition，这个和普通bean创建的实例为GenericBeanDefinition不同。进入内部的getAdviceClass看一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Gets the advice implementation class corresponding to the supplied &#123;<span class="doctag">@link</span> Element&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Class&lt;?&gt; getAdviceClass(Element adviceElement, ParserContext parserContext) &#123;</span><br><span class="line">	String elementName = parserContext.getDelegate().getLocalName(adviceElement);</span><br><span class="line">	<span class="keyword">if</span> (BEFORE.equals(elementName)) &#123;</span><br><span class="line">		<span class="keyword">return</span> AspectJMethodBeforeAdvice.class;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (AFTER.equals(elementName)) &#123;</span><br><span class="line">		<span class="keyword">return</span> AspectJAfterAdvice.class;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (AFTER_RETURNING_ELEMENT.equals(elementName)) &#123;</span><br><span class="line">		<span class="keyword">return</span> AspectJAfterReturningAdvice.class;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (AFTER_THROWING_ELEMENT.equals(elementName)) &#123;</span><br><span class="line">		<span class="keyword">return</span> AspectJAfterThrowingAdvice.class;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (AROUND.equals(elementName)) &#123;</span><br><span class="line">		<span class="keyword">return</span> AspectJAroundAdvice.class;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Unknown advice kind [&quot;</span> + elementName + <span class="string">&quot;].&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如图所示，创建adviceBean定义，其中不同的切入方式对应不同的Class:</p>
<ul>
<li>before对应AspectJMethodBeforeAdvice</li>
<li>after对应AspectJAfterAdvice</li>
<li>after-returning对应AspectJAfterReturningAdvice</li>
<li>after-throwing对应AspectJAfterThrowingAdvice</li>
<li>around对应AspectJAroundAdvice</li>
</ul>
<p>所以，至此&lt;aop: after-returning&gt;这个便签对应的AbstractBeanDefinition就创建出来了。👌👌</p>
<h3 id="3-2配置AdvisorDefiniton"><a href="#3-2配置AdvisorDefiniton" class="headerlink" title="3.2配置AdvisorDefiniton"></a>3.2配置AdvisorDefiniton</h3><p>在完成了这一步骤之后，则将名为adviceDef的RootBeanDefition转换成名为advisorDefinition的RootBeanDefinition，跟一下上面一部分ConfigBeanDefinitionParser类parseAdvice方法的第26行~32行的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// configure the advisor</span></span><br><span class="line">RootBeanDefinition advisorDefinition = <span class="keyword">new</span> RootBeanDefinition(AspectJPointcutAdvisor.class);</span><br><span class="line">advisorDefinition.setSource(parserContext.extractSource(adviceElement));</span><br><span class="line">advisorDefinition.getConstructorArgumentValues().addGenericArgumentValue(adviceDef);</span><br><span class="line"><span class="keyword">if</span> (aspectElement.hasAttribute(ORDER_PROPERTY)) &#123;</span><br><span class="line">	advisorDefinition.getPropertyValues().add(</span><br><span class="line">			ORDER_PROPERTY, aspectElement.getAttribute(ORDER_PROPERTY));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里相当于将上一步生成的RootBeanDefinition包装了一下，new一个新的RootBeanDefinition出来，Class类型是org.springframework.aop.aspectj.AspectJPointcutAdvisor。</p>
<p>第4行~第7行的代码是用于判断<a href="aop:aspect">aop:aspect</a>标签中有没有”order”属性的，有就设置一下，”order”属性是用来控制切入方法优先级的。</p>
<h3 id="3-3-注册advisorDefition"><a href="#3-3-注册advisorDefition" class="headerlink" title="3.3 注册advisorDefition"></a>3.3 注册advisorDefition</h3><p>最后一步就是将BeanDefition注册到DefaultListableBeanFactory中，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// register the final advisor</span></span><br><span class="line">parserContext.getReaderContext().registerWithGeneratedName(advisorDefinition);</span><br></pre></td></tr></table></figure>

<p>进入到registerWithGeneratedName方法中，可见细节：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Call the bean name generator for the given bean definition</span></span><br><span class="line"><span class="comment"> * and register the bean definition under the generated name.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> XmlBeanDefinitionReader#getBeanNameGenerator()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.beans.factory.support.BeanNameGenerator#generateBeanName</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> BeanDefinitionRegistry#registerBeanDefinition</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">registerWithGeneratedName</span><span class="params">(BeanDefinition beanDefinition)</span> </span>&#123;</span><br><span class="line">	String generatedName = generateBeanName(beanDefinition);</span><br><span class="line">	getRegistry().registerBeanDefinition(generatedName, beanDefinition);</span><br><span class="line">	<span class="keyword">return</span> generatedName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第2行获取注册的名字BeanName，和&lt;bean&gt;的注册差不多，使用的是Class全路径+”#”+全局计数器的方式，其中的Class全路径为org.springframework.aop.aspectj.AspectJPointcutAdvisor，依次类推，每一个BeanName应当为org.springframework.aop.aspectj.AspectJPointcutAdvisor#0、org.springframework.aop.aspectj.AspectJPointcutAdvisor#1、org.springframework.aop.aspectj.AspectJPointcutAdvisor#2这样下去。</p>
<p>现在BeanName已经有了，剩下就是Bean定义了，Bean定义的解析流程之前在Spring IOC中已经说过。</p>
<h3 id="3-4-AopNamespaceHandler处理-lt-aop-pointcut-gt-流程"><a href="#3-4-AopNamespaceHandler处理-lt-aop-pointcut-gt-流程" class="headerlink" title="3.4 AopNamespaceHandler处理 &lt;aop:pointcut &gt;流程"></a>3.4 AopNamespaceHandler处理 &lt;aop:pointcut &gt;流程</h3><p>在完成了&lt;aop: before &gt;, &lt;aop: after-returing &gt;等标签的解析之后，ConfigBeanDefinitionParser 的parseAspect中就开始进行&lt;aop: pointcut &gt;的标签。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseAspect</span><span class="params">(Element aspectElement, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">	  .........</span><br><span class="line"></span><br><span class="line">		AspectComponentDefinition aspectComponentDefinition = createAspectComponentDefinition(</span><br><span class="line">				aspectElement, aspectId, beanDefinitions, beanReferences, parserContext);</span><br><span class="line">		parserContext.pushContainingComponent(aspectComponentDefinition);</span><br><span class="line"></span><br><span class="line">		List&lt;Element&gt; pointcuts = DomUtils.getChildElementsByTagName(aspectElement, POINTCUT);</span><br><span class="line">		<span class="keyword">for</span> (Element pointcutElement : pointcuts) &#123;</span><br><span class="line">			parsePointcut(pointcutElement, parserContext);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		parserContext.popAndRegisterContainingComponent();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">finally</span> &#123;</span><br><span class="line">		<span class="keyword">this</span>.parseState.pop();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>显而易见，可见对于pointcut标签的解析是进入parsePointcut()方法中进行的，其代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Parses the supplied &#123;<span class="doctag">@code</span> &lt;pointcut&gt;&#125; and registers the resulting</span></span><br><span class="line"><span class="comment"> * Pointcut with the BeanDefinitionRegistry.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> AbstractBeanDefinition <span class="title">parsePointcut</span><span class="params">(Element pointcutElement, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">	String id = pointcutElement.getAttribute(ID);</span><br><span class="line">	String expression = pointcutElement.getAttribute(EXPRESSION);</span><br><span class="line"></span><br><span class="line">	AbstractBeanDefinition pointcutDefinition = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">this</span>.parseState.push(<span class="keyword">new</span> PointcutEntry(id));</span><br><span class="line">		pointcutDefinition = createPointcutDefinition(expression);</span><br><span class="line">		pointcutDefinition.setSource(parserContext.extractSource(pointcutElement));</span><br><span class="line"></span><br><span class="line">		String pointcutBeanName = id;</span><br><span class="line">		<span class="keyword">if</span> (StringUtils.hasText(pointcutBeanName)) &#123;</span><br><span class="line">			parserContext.getRegistry().registerBeanDefinition(pointcutBeanName, pointcutDefinition);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			pointcutBeanName = parserContext.getReaderContext().registerWithGeneratedName(pointcutDefinition);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		parserContext.registerComponent(</span><br><span class="line">				<span class="keyword">new</span> PointcutComponentDefinition(pointcutBeanName, pointcutDefinition, expression));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">finally</span> &#123;</span><br><span class="line">		<span class="keyword">this</span>.parseState.pop();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> pointcutDefinition;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第2行~第3行的代码获取&lt;aop:pointcut&gt;标签下的”id”属性与”expression”属性。</p>
<p>第8行的代码推送一个PointcutEntry，表示当前Spring上下文正在解析Pointcut标签。</p>
<p>第9行的代码创建Pointcut的Bean定义，之后再看，先把其他方法都看一下。</p>
<p>第10行的代码不管它，最终从NullSourceExtractor的extractSource方法获取Source，就是个null。</p>
<p>第12行~第18行的代码用于注册获取到的Bean定义，默认pointcutBeanName为&lt;aop:pointcut&gt;标签中定义的id属性：</p>
<ul>
<li>如果&lt;aop:pointcut&gt;标签中配置了id属性就执行的是第13行~第15行的代码，pointcutBeanName=id</li>
<li>如果&lt;aop:pointcut&gt;标签中没有配置id属性就执行的是第16行~第18行的代码，和Bean不配置id属性一样的规则，pointcutBeanName= <strong>org.springframework.aop.aspectj.AspectJExpressionPointcut#序号（从0开始累加）</strong></li>
</ul>
<p>第20行~第21行的代码向解析工具上下文中注册一个Pointcut组件定义</p>
<p>第23行~第25行的代码，finally块在&lt;aop:pointcut&gt;标签解析完毕后，让之前推送至栈顶的PointcutEntry出栈，表示此次&lt;aop:pointcut&gt;标签解析完毕。</p>
<p>最后回头来一下第9行代码createPointcutDefinition的实现，比较简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a &#123;<span class="doctag">@link</span> BeanDefinition&#125; for the &#123;<span class="doctag">@link</span> AspectJExpressionPointcut&#125; class using</span></span><br><span class="line"><span class="comment"> * the supplied pointcut expression.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> AbstractBeanDefinition <span class="title">createPointcutDefinition</span><span class="params">(String expression)</span> </span>&#123;</span><br><span class="line">	RootBeanDefinition beanDefinition = <span class="keyword">new</span> RootBeanDefinition(AspectJExpressionPointcut.class);</span><br><span class="line">	beanDefinition.setScope(BeanDefinition.SCOPE_PROTOTYPE);</span><br><span class="line">	beanDefinition.setSynthetic(<span class="keyword">true</span>);</span><br><span class="line">	beanDefinition.getPropertyValues().add(EXPRESSION, expression);</span><br><span class="line">	<span class="keyword">return</span> beanDefinition;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关键就是注意一下两点：</p>
<ol>
<li><a href="aop:pointcut">aop:pointcut</a>标签对应解析出来的BeanDefinition是RootBeanDefinition，且RootBenaDefinitoin中的Class是org.springframework.aop.aspectj.AspectJExpressionPointcut。</li>
<li><a href="aop:pointcut">aop:pointcut</a>标签对应的Bean是prototype即原型的</li>
</ol>
<p>这样一个流程下来，就解析了<a href="aop:pointcut">aop:pointcut</a>标签中的内容并将之转换为RootBeanDefintion存储在Spring容器中。</p>
<h2 id="3-总结和思考"><a href="#3-总结和思考" class="headerlink" title="3. 总结和思考"></a>3. 总结和思考</h2><ol>
<li>需要仔细观察，并思考AOP中的bean的定义与普通的bean定义的不同之处。</li>
</ol>
<p>解决方式：通过样例代码来观察spring IOC对aop: advisor标签的解析是如何完成的，特别需要注意的是其实如何生成RootBeanDefinition的。</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ol>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/2.5.x/reference/aop.html">Chapter 6. Aspect Oriented Programming with Spring</a></li>
<li><a target="_blank" rel="noopener" href="http://www.importnew.com/24430.html">Spring源码分析：AOP源码解析（上篇）</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/10/18/CGLib/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Robinson">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Road To Excelsior">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/10/18/CGLib/" class="post-title-link" itemprop="url">cglib</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-10-18 00:00:00" itemprop="dateCreated datePublished" datetime="2018-10-18T00:00:00+08:00">2018-10-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-05-08 15:53:10" itemprop="dateModified" datetime="2019-05-08T15:53:10+08:00">2019-05-08</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><blockquote>
<p>cglib - Byte Code Generation Library is high level API to generate and transform Java byte code. It is used by AOP, testing, data access frameworks to generate dynamic proxy objects and intercept field access.</p>
</blockquote>
<p>简单来说，cglib是一个Java 字节码生成器。其可以被用在AOP，测试，数据获取框架中去生成 <strong>动态代理对象</strong> 以及拦截获取字段。</p>
<h2 id="1-Toast"><a href="#1-Toast" class="headerlink" title="1. Toast"></a>1. Toast</h2><p>一如以前，从一个实际的例子出发，我们定义了一个简单的Cglib的demo，来观察其外在的表现。<br>首先定义了一个要代理的类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Object Dao update&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Dao object select&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后为其创建一个代理，通过实现MethodInterceptor接口，为其在方法调用前后记录一些东西：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DaoProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before method invoke&quot;</span>);</span><br><span class="line">        methodProxy.invokeSuper(o, objects);</span><br><span class="line">        System.out.println(<span class="string">&quot;After method invoke&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在写一个简单的测试类，来打印AOP拦截的输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DaoTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCglib</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DaoProxy daoProxy = <span class="keyword">new</span> DaoProxy();</span><br><span class="line"></span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setSuperclass(Dao.class);</span><br><span class="line">        enhancer.setCallback(daoProxy);</span><br><span class="line"></span><br><span class="line">        Dao dao = (Dao) enhancer.create();</span><br><span class="line">        dao.update();</span><br><span class="line">        dao.select();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其结果打印如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">before method invoke</span><br><span class="line">Object Dao update</span><br><span class="line">After method invoke</span><br><span class="line">before method invoke</span><br><span class="line">Dao object select</span><br><span class="line">After method invoke</span><br></pre></td></tr></table></figure>

<h2 id="2-初识"><a href="#2-初识" class="headerlink" title="2.初识"></a>2.初识</h2><p>现在，来观察方法拦截器接口的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * General-purpose &#123;<span class="doctag">@link</span> Enhancer&#125; callback which provides for &quot;around advice&quot;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Juozas Baliuka &lt;a href=&quot;mailto:baliuka@mwm.lt&quot;&gt;baliuka@mwm.lt&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> $Id: MethodInterceptor.java,v 1.8 2004/06/24 21:15:20 herbyderby Exp $</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MethodInterceptor</span></span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">Callback</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * All generated proxied methods call this method instead of the original method.</span></span><br><span class="line"><span class="comment">     * The original method may either be invoked by normal reflection using the Method object,</span></span><br><span class="line"><span class="comment">     * or by using the MethodProxy (faster).</span></span><br><span class="line"><span class="comment">     * 所有生成的代理方法会调用这个方法，而不是原始的方法。原始的方法可能会通过使用方法对象进行正常的反射操作；或者使用方法代理对象（这样更快些）。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> obj &quot;this&quot;, the enhanced object：增强的对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method intercepted Method：拦截的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args argument array; primitive types are wrapped：参数数组，原始类型需要被封装</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proxy used to invoke super (non-intercepted method); may be called</span></span><br><span class="line"><span class="comment">     * as many times as needed：被用来调用父（没有拦截的方法）；可能会被调用多次</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable any exception may be thrown; if so, super method will not be invoked</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> any value compatible with the signature of the proxied method. Method returning void will ignore this value.</span></span><br><span class="line"><span class="comment">     * 返回：任何与代理方法签名兼容的值。方法返回void则会忽略这个值。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> MethodProxy</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, java.lang.reflect.Method method, Object[] args,</span></span></span><br><span class="line"><span class="function"><span class="params">                               MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，Cglib还是提供了若干个其他的回调类型（见Callback的注释）。如：</p>
<ol>
<li>@see MethodInterceptor</li>
<li>@see NoOp</li>
<li>@see LazyLoader</li>
<li>@see Dispatcher</li>
<li>@see InvocationHandler</li>
<li>@see FixedValue</li>
</ol>
<p>在完成了对方法的拦截之后，Demo在测试中调用了Enhancer对象来完成代理类的创建。至于创建一个代理，至少需要一个 <strong>被代理类</strong>。在Demo中，新建了一个Enhancer对象，然后分别设置了代理类和回调。分别看一下各自的源代码及其注释：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Set the class which the generated class will extend. As a convenience,</span></span><br><span class="line"><span class="comment">     * if the supplied superclass is actually an interface, &lt;code&gt;setInterfaces&lt;/code&gt;</span></span><br><span class="line"><span class="comment">     * will be called with the appropriate argument instead.</span></span><br><span class="line"><span class="comment">     * A non-interface argument must not be declared as final, and must have an</span></span><br><span class="line"><span class="comment">     * accessible constructor.</span></span><br><span class="line"><span class="comment">     * 设置将被扩展的已产生类的类。为方便起见，如果提供的超类是一个借口，setInterfaces将会被调用。</span></span><br><span class="line"><span class="comment">     * 一个非接口参数（类）不能被声明为final，而且必须有可访问的构造器。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> superclass class to extend or interface to implement</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #setInterfaces(Class[])</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSuperclass</span><span class="params">(Class superclass)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (superclass != <span class="keyword">null</span> &amp;&amp; superclass.isInterface()) &#123;</span><br><span class="line">            setInterfaces(<span class="keyword">new</span> Class[]&#123; superclass &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (superclass != <span class="keyword">null</span> &amp;&amp; superclass.equals(Object.class)) &#123;</span><br><span class="line">            <span class="comment">// affects choice of ClassLoader</span></span><br><span class="line">            <span class="keyword">this</span>.superclass = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.superclass = superclass;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>如注释所示：这个方法设置将被扩展的已产生类的类。为方便起见，如果提供的超类是一个接口，setInterfaces将会被调用。一个非接口参数（类）不能被声明为final，而且必须有可访问的构造器。</p>
<p>在来看设置回调的方法setCallback, Callback可以理解成生成的代理类的方法被调用时（比如说调用person.sayHello()时），会执行的逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Set the array of callbacks to use.</span></span><br><span class="line"><span class="comment"> * Ignored if you use &#123;<span class="doctag">@link</span> #createClass&#125;.</span></span><br><span class="line"><span class="comment"> * You must use a &#123;<span class="doctag">@link</span> CallbackFilter&#125; to specify the index into this</span></span><br><span class="line"><span class="comment"> * array for each method in the proxied class.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> callbacks the callback array</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #setCallbackFilter</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #setCallback</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCallbacks</span><span class="params">(Callback[] callbacks)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (callbacks != <span class="keyword">null</span> &amp;&amp; callbacks.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Array cannot be empty&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.callbacks = callbacks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>翻译一下注释，即设置要使用的callbacks数组，必须使用一个CallbackFilter来指定进入数据的索引，为每一个代理类中的方法。</p>
<p>为了验证Filter功能，新建一个filter类，来进行方法的分门别类的过滤。首先，先新建一个拦截器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DaoAnotherProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;call time: &quot;</span> + System.currentTimeMillis());</span><br><span class="line">        <span class="comment">//method.invoke(obj, args);</span></span><br><span class="line">        proxy.invokeSuper(obj, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;end call time: &quot;</span> + System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我使用反射方式来进行调用时，出现了问题，但是不是我这次的重点，暂搁置。然后，创建了一个Callback的过滤器来对callback进行过滤：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodFilter</span> <span class="keyword">implements</span> <span class="title">CallbackFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UPDATE = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SELECT = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">accept</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">        String name = method.getName();</span><br><span class="line">        <span class="keyword">if</span>(name.equals(<span class="string">&quot;update&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> UPDATE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> SELECT;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时，修改enhancer实例，设置过滤器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DaoTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCglib</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DaoProxy daoProxy = <span class="keyword">new</span> DaoProxy();</span><br><span class="line">        DaoAnotherProxy daoAnotherProxy = <span class="keyword">new</span> DaoAnotherProxy();</span><br><span class="line">        MethodFilter methodFilter = <span class="keyword">new</span> MethodFilter();</span><br><span class="line"></span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setSuperclass(Dao.class);</span><br><span class="line">        enhancer.setCallbacks(<span class="keyword">new</span> Callback[]&#123;daoProxy, daoAnotherProxy&#125;);</span><br><span class="line">        enhancer.setCallbackFilter(methodFilter);</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">before method invoke</span><br><span class="line">Object Dao update</span><br><span class="line">After method invoke</span><br><span class="line">call time: 1539921398539</span><br><span class="line">Dao object select</span><br><span class="line">end call time: 1539921398539</span><br></pre></td></tr></table></figure>

<p>如结果所示，通过过滤器，实现了对同一个类中不同方法的不同拦截。</p>
<h2 id="3-cglib功能总结"><a href="#3-cglib功能总结" class="headerlink" title="3.cglib功能总结"></a>3.cglib功能总结</h2><p>因为我目前对Java 动态代理不是很熟悉，所以不好对比两种技术的差别在哪里。从目前的样例分析来看，cglib作为一种代码生成库，其可以通过Enhencer这个类来完成生成 <strong>动态的子类</strong>，以达到方法级别拦截的目的。</p>
<p>这个类是作为标准动态代理（其允许代理继承一个实体基类，也允许实现接口）的替代品从jdk1.3开始支持的。动态生成的子类重写了超类中non-final的方法，同时有钩子回调用户定义的拦截器实现。</p>
<p>其中关于MethodInterceptor回调功能为：</p>
<blockquote>
<p>The original and most general callback type is the {@link MethodInterceptor}, which<br> in AOP terms enables “around advice”–that is, you can invoke custom code both before<br> and after the invocation of the “super” method. In addition you can modify the<br> arguments before calling the super method, or not call it at all.</p>
</blockquote>
<p>同时为了支持同一个代理类中多个回调的功能，提供了CallbackFilter：</p>
<blockquote>
<p>Although <code>MethodInterceptor</code> is generic enough to meet any<br>interception need, it is often overkill. For simplicity and performance, additional<br>specialized callback types, such as {@link LazyLoader} are also available.<br>Often a single callback will be used per enhanced class, but you can control<br>which callback is used on a per-method basis with a {@link CallbackFilter}.</p>
</blockquote>
<p>同时，需要注意一下Enhencer的另外一个特性Factory: </p>
<blockquote>
<p>All enhanced objects implement the {@link Factory} interface, unless {@link #setUseFactory} is<br>used to explicitly disable this feature. The <code>Factory</code> interface provides an API<br>to change the callbacks of an existing object, as well as a faster and easier way to create<br>new instances of the same type.</p>
</blockquote>
<p>上面的意思是，除非显示的关掉这个Factory特性，否则这个借口提供了API去改变存在的对象的回调行为，同时也提供了一种更快，更简单创建实例的方式。</p>
<h2 id="4-总结和思考"><a href="#4-总结和思考" class="headerlink" title="4.总结和思考"></a>4.总结和思考</h2><p>CGLIB是一个强大的高性能的代码生成库。作为JDK动态代理的互补，它对于那些没有实现接口的类提供了代理方案。在底层，它使用ASM字节码操纵框架。本质上来说，CGLIB通过产生子类覆盖非final方法来进行代理。它比使用Java反射的JDK动态代理方法更快。CGLIB不能代理一个final类或者final方法。通常来说，你可以使用JDK动态代理方法来创建代理，对于没有接口的情况或者性能因素，CGLIB是一个很好的选择。</p>
<p>第一个问题：cglib代码生成库在Spring AOP的应用是怎么样的？分别应用在哪些点，以及其实如何完成这个过程的。</p>
<h2 id="5-参考文档"><a href="#5-参考文档" class="headerlink" title="5.参考文档"></a>5.参考文档</h2><ol>
<li>cglib source code;</li>
<li><a target="_blank" rel="noopener" href="http://ifeve.com/cglib-desc/">CGLIB动态代理介绍</a></li>
<li><a target="_blank" rel="noopener" href="https://dzone.com/articles/cglib-missing-manual">CGLib: The Missing Manual</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/10/18/Spring-IOC(2)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Robinson">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Road To Excelsior">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/10/18/Spring-IOC(2)/" class="post-title-link" itemprop="url">Spring IOC(2) - 实例化</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-10-18 00:00:00" itemprop="dateCreated datePublished" datetime="2018-10-18T00:00:00+08:00">2018-10-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-12-18 00:43:53" itemprop="dateModified" datetime="2020-12-18T00:43:53+08:00">2020-12-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><p>Spring 为使用Java开发大型的应用程序提供了很好的模块化技术支持，极大的减小了耦合度。通过Spring IOC以及AOP，可以实现高度灵活的应用服务开发目的。</p>
<h2 id="1-实例化"><a href="#1-实例化" class="headerlink" title="1. 实例化"></a>1. 实例化</h2><h3 id="2-1-实例化入口"><a href="#2-1-实例化入口" class="headerlink" title="2.1 实例化入口"></a>2.1 实例化入口</h3><p>承接上文，Spring IOC在完成初始化之后，会继续进行相关的操作。其进行实例化的入口依然在AbstractApplicationContext中的refresh()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">	<span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">		<span class="comment">// 为刷新准备context;</span></span><br><span class="line">		prepareRefresh();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line">     <span class="comment">// 告诉子类去刷新内部的bean factory</span></span><br><span class="line">		ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">     <span class="comment">// 准备这个bean factory以待后用</span></span><br><span class="line">		prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">       <span class="comment">// 允许在context 的子类中进行后处理 bean factory</span></span><br><span class="line">			postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">       <span class="comment">// 调用 工厂处理方法</span></span><br><span class="line">			invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">       <span class="comment">// 注册bean 处理器用来拦截bean的创建</span></span><br><span class="line">			registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Initialize message source for this context.</span></span><br><span class="line">       <span class="comment">// 为这个context初始化消息源</span></span><br><span class="line">			initMessageSource();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">       <span class="comment">// 为这个 context 初始化事件多播</span></span><br><span class="line">			initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">       <span class="comment">// 在特定的context子类中 初始化其他特定的bean</span></span><br><span class="line">			onRefresh();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">       <span class="comment">// 检查监听器bean，并注册它们</span></span><br><span class="line">			registerListeners();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">       <span class="comment">// 实例化所有的(non-lazy-init)的单体bean</span></span><br><span class="line">			finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">			finishRefresh();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">			<span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">				logger.warn(<span class="string">&quot;Exception encountered during context initialization - &quot;</span> +</span><br><span class="line">						<span class="string">&quot;cancelling refresh attempt: &quot;</span> + ex);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">			destroyBeans();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Reset &#x27;active&#x27; flag.</span></span><br><span class="line">			cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Propagate exception to caller.</span></span><br><span class="line">			<span class="keyword">throw</span> ex;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="comment">// Reset common introspection caches in Spring&#x27;s core, since we</span></span><br><span class="line">			<span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">			resetCommonCaches();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在实例化入口，会实例化所有的非懒加载的bean，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Finish the initialization of this context&#x27;s bean factory,</span></span><br><span class="line"><span class="comment"> * initializing all remaining singleton beans.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finishBeanFactoryInitialization</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// Initialize conversion service for this context.</span></span><br><span class="line">	<span class="keyword">if</span> (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;</span><br><span class="line">			beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) &#123;</span><br><span class="line">		beanFactory.setConversionService(</span><br><span class="line">				beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Register a default embedded value resolver if no bean post-processor</span></span><br><span class="line">	<span class="comment">// (such as a PropertyPlaceholderConfigurer bean) registered any before:</span></span><br><span class="line">	<span class="comment">// at this point, primarily for resolution in annotation attribute values.</span></span><br><span class="line">	<span class="keyword">if</span> (!beanFactory.hasEmbeddedValueResolver()) &#123;</span><br><span class="line">		beanFactory.addEmbeddedValueResolver(strVal -&gt; getEnvironment().resolvePlaceholders(strVal));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Initialize LoadTimeWeaverAware beans early to allow for registering their transformers early.</span></span><br><span class="line">	String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">	<span class="keyword">for</span> (String weaverAwareName : weaverAwareNames) &#123;</span><br><span class="line">		getBean(weaverAwareName);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Stop using the temporary ClassLoader for type matching.</span></span><br><span class="line">	beanFactory.setTempClassLoader(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Allow for caching all bean definition metadata, not expecting further changes.</span></span><br><span class="line">	beanFactory.freezeConfiguration();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">	beanFactory.preInstantiateSingletons();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-预实例化单体"><a href="#2-2-预实例化单体" class="headerlink" title="2.2 预实例化单体"></a>2.2 预实例化单体</h3><p>承上，完成了一些入口的一些处理之后，开始进入beanFactory.preInstantiateSingletons()进行实例化的预处理操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preInstantiateSingletons</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line">		<span class="keyword">this</span>.logger.debug(<span class="string">&quot;Pre-instantiating singletons in &quot;</span> + <span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Iterate over a copy to allow for init methods which in turn register new bean definitions.</span></span><br><span class="line">	<span class="comment">// While this may not be part of the regular factory bootstrap, it does otherwise work fine.</span></span><br><span class="line">	List&lt;String&gt; beanNames = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Trigger initialization of all non-lazy singleton beans...</span></span><br><span class="line">	<span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">		RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">		<span class="keyword">if</span> (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;</span><br><span class="line">			<span class="keyword">if</span> (isFactoryBean(beanName)) &#123;</span><br><span class="line">				Object bean = getBean(FACTORY_BEAN_PREFIX + beanName);</span><br><span class="line">				<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> FactoryBean) &#123;</span><br><span class="line">					<span class="keyword">final</span> FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) bean;</span><br><span class="line">					<span class="keyword">boolean</span> isEagerInit;</span><br><span class="line">					<span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span> &amp;&amp; factory <span class="keyword">instanceof</span> SmartFactoryBean) &#123;</span><br><span class="line">						isEagerInit = AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;)</span><br><span class="line">										((SmartFactoryBean&lt;?&gt;) factory)::isEagerInit,</span><br><span class="line">								getAccessControlContext());</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span> &#123;</span><br><span class="line">						isEagerInit = (factory <span class="keyword">instanceof</span> SmartFactoryBean &amp;&amp;</span><br><span class="line">								((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">if</span> (isEagerInit) &#123;</span><br><span class="line">						getBean(beanName);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				getBean(beanName);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Trigger post-initialization callback for all applicable beans...</span></span><br><span class="line">   <span class="comment">// 到这里说明所有的非懒加载的 singleton beans 已经完成了初始化</span></span><br><span class="line">   <span class="comment">// 如果我们定义的 bean 是实现了 SmartInitializingSingleton 接口的，那么在这里得到回调，忽略</span></span><br><span class="line">	<span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">		Object singletonInstance = getSingleton(beanName);</span><br><span class="line">		<span class="keyword">if</span> (singletonInstance <span class="keyword">instanceof</span> SmartInitializingSingleton) &#123;</span><br><span class="line">			<span class="keyword">final</span> SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;</span><br><span class="line">			<span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">				AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">					smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">					<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">				&#125;, getAccessControlContext());</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-调用getBean来获取实例"><a href="#2-3-调用getBean来获取实例" class="headerlink" title="2.3 调用getBean来获取实例"></a>2.3 调用getBean来获取实例</h3><p>在上面进行若干项检查后，调用getBean方法来进行获取bean实例的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// Implementation of BeanFactory interface</span></span><br><span class="line"><span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> doGetBean(name, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> 	<span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return an instance, which may be shared or independent, of the specified bean.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name the name of the bean to retrieve</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> requiredType the required type of the bean to retrieve</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args arguments to use when creating a bean instance using explicit arguments</span></span><br><span class="line"><span class="comment"> * (only applied when creating a new instance as opposed to retrieving an existing one)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> typeCheckOnly whether the instance is obtained for a type check,</span></span><br><span class="line"><span class="comment"> * not for actual use</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> an instance of the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeansException if the bean could not be created</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doGetBean</span><span class="params">(<span class="keyword">final</span> String name, <span class="meta">@Nullable</span> <span class="keyword">final</span> Class&lt;T&gt; requiredType,</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="meta">@Nullable</span> <span class="keyword">final</span> Object[] args, <span class="keyword">boolean</span> typeCheckOnly)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">final</span> String beanName = transformedBeanName(name);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//这个是返回值</span></span><br><span class="line">	Object bean;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Eagerly check singleton cache for manually registered singletons.</span></span><br><span class="line">	Object sharedInstance = getSingleton(beanName);</span><br><span class="line">	<span class="keyword">if</span> (sharedInstance != <span class="keyword">null</span> &amp;&amp; args == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">			<span class="keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">				logger.debug(<span class="string">&quot;Returning eagerly cached instance of singleton bean &#x27;&quot;</span> + beanName +</span><br><span class="line">						<span class="string">&quot;&#x27; that is not fully initialized yet - a consequence of a circular reference&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				logger.debug(<span class="string">&quot;Returning cached instance of singleton bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="keyword">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// Fail if we&#x27;re already creating this bean instance:</span></span><br><span class="line">		<span class="comment">// We&#x27;re assumably within a circular reference.</span></span><br><span class="line">		<span class="keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Check if bean definition exists in this factory.</span></span><br><span class="line">		BeanFactory parentBeanFactory = getParentBeanFactory();</span><br><span class="line">		<span class="keyword">if</span> (parentBeanFactory != <span class="keyword">null</span> &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class="line">			<span class="comment">// Not found -&gt; check parent.</span></span><br><span class="line">			String nameToLookup = originalBeanName(name);</span><br><span class="line">			<span class="keyword">if</span> (parentBeanFactory <span class="keyword">instanceof</span> AbstractBeanFactory) &#123;</span><br><span class="line">				<span class="keyword">return</span> ((AbstractBeanFactory) parentBeanFactory).doGetBean(</span><br><span class="line">						nameToLookup, requiredType, args, typeCheckOnly);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (args != <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="comment">// Delegation to parent with explicit args.</span></span><br><span class="line">				<span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup, args);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// No args -&gt; delegate to standard getBean method.</span></span><br><span class="line">				<span class="keyword">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!typeCheckOnly) &#123;</span><br><span class="line">			markBeanAsCreated(beanName);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">final</span> RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">			checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Guarantee initialization of beans that the current bean depends on.</span></span><br><span class="line">			String[] dependsOn = mbd.getDependsOn();</span><br><span class="line">			<span class="keyword">if</span> (dependsOn != <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">for</span> (String dep : dependsOn) &#123;</span><br><span class="line">					<span class="keyword">if</span> (isDependent(beanName, dep)) &#123;</span><br><span class="line">						<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">								<span class="string">&quot;Circular depends-on relationship between &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; and &#x27;&quot;</span> + dep + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">					&#125;</span><br><span class="line">					registerDependentBean(dep, beanName);</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						getBean(dep);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line">						<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">								<span class="string">&quot;&#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; depends on missing bean &#x27;&quot;</span> + dep + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Create bean instance.</span></span><br><span class="line">			<span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">				sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						<span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">						<span class="comment">// Explicitly remove instance from singleton cache: It might have been put there</span></span><br><span class="line">						<span class="comment">// eagerly by the creation process, to allow for circular reference resolution.</span></span><br><span class="line">						<span class="comment">// Also remove any beans that received a temporary reference to the bean.</span></span><br><span class="line">						destroySingleton(beanName);</span><br><span class="line">						<span class="keyword">throw</span> ex;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;);</span><br><span class="line">				bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;</span><br><span class="line">				<span class="comment">// It&#x27;s a prototype -&gt; create a new instance.</span></span><br><span class="line">				Object prototypeInstance = <span class="keyword">null</span>;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					beforePrototypeCreation(beanName);</span><br><span class="line">					prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">finally</span> &#123;</span><br><span class="line">					afterPrototypeCreation(beanName);</span><br><span class="line">				&#125;</span><br><span class="line">				bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				String scopeName = mbd.getScope();</span><br><span class="line">				<span class="keyword">final</span> Scope scope = <span class="keyword">this</span>.scopes.get(scopeName);</span><br><span class="line">				<span class="keyword">if</span> (scope == <span class="keyword">null</span>) &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;No Scope registered for scope name &#x27;&quot;</span> + scopeName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					Object scopedInstance = scope.get(beanName, () -&gt; &#123;</span><br><span class="line">						beforePrototypeCreation(beanName);</span><br><span class="line">						<span class="keyword">try</span> &#123;</span><br><span class="line">							<span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">finally</span> &#123;</span><br><span class="line">							afterPrototypeCreation(beanName);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;);</span><br><span class="line">					bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName,</span><br><span class="line">							<span class="string">&quot;Scope &#x27;&quot;</span> + scopeName + <span class="string">&quot;&#x27; is not active for the current thread; consider &quot;</span> +</span><br><span class="line">							<span class="string">&quot;defining a scoped proxy for this bean if you intend to refer to it from a singleton&quot;</span>,</span><br><span class="line">							ex);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">			cleanupAfterBeanCreationFailure(beanName);</span><br><span class="line">			<span class="keyword">throw</span> ex;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Check if required type matches the type of the actual bean instance.</span></span><br><span class="line">	<span class="keyword">if</span> (requiredType != <span class="keyword">null</span> &amp;&amp; !requiredType.isInstance(bean)) &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			T convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType);</span><br><span class="line">			<span class="keyword">if</span> (convertedBean == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> convertedBean;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (TypeMismatchException ex) &#123;</span><br><span class="line">			<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">				logger.debug(<span class="string">&quot;Failed to convert bean &#x27;&quot;</span> + name + <span class="string">&quot;&#x27; to required type &#x27;&quot;</span> +</span><br><span class="line">						ClassUtils.getQualifiedName(requiredType) + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (T) bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，真正实例化的是父类（DefaultSingletonBeanRegistry）的getSingleton()方法，在这个方法中，调用了子类AbstractAutowireCapableBeanFactory 的doCreate的方法；在这个类中，最终调用了instantiateBean()方法来使用默认的构造器完成实例化构建的过程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Instantiate the given bean using its default constructor.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanName the name of the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mbd the bean definition for the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a BeanWrapper for the new instance</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> BeanWrapper <span class="title">instantiateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		Object beanInstance;</span><br><span class="line">		<span class="keyword">final</span> BeanFactory parent = <span class="keyword">this</span>;</span><br><span class="line">		<span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">			beanInstance = AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt;</span><br><span class="line">					getInstantiationStrategy().instantiate(mbd, beanName, parent),</span><br><span class="line">					getAccessControlContext());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent);</span><br><span class="line">		&#125;</span><br><span class="line">		BeanWrapper bw = <span class="keyword">new</span> BeanWrapperImpl(beanInstance);</span><br><span class="line">		initBeanWrapper(bw);</span><br><span class="line">		<span class="keyword">return</span> bw;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">				mbd.getResourceDescription(), beanName, <span class="string">&quot;Instantiation of bean failed&quot;</span>, ex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在方法中，其采用默认的策略来实例化这个bean，并进行了封装，返回。策略实例是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Strategy for creating bean instances */</span></span><br><span class="line"><span class="keyword">private</span> InstantiationStrategy instantiationStrategy = <span class="keyword">new</span> CglibSubclassingInstantiationStrategy();</span><br></pre></td></tr></table></figure>

<p>其继承层次如下：</p>
<p>![](/assets/posts/Spring IOC Instance/CglibSubclassingInstantiationStrategy.png)</p>
<h3 id="2-4-通过静态方法来进行实例化"><a href="#2-4-通过静态方法来进行实例化" class="headerlink" title="2.4 通过静态方法来进行实例化"></a>2.4 通过静态方法来进行实例化</h3><p>如下代码所示，其调用了静态类方法BeanUtils.instantiateClass(constructorToUse)来完成实例化；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">instantiate</span><span class="params">(RootBeanDefinition bd, <span class="meta">@Nullable</span> String beanName, BeanFactory owner)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// Don&#x27;t override the class with CGLIB if no overrides.</span></span><br><span class="line">	<span class="keyword">if</span> (!bd.hasMethodOverrides()) &#123;</span><br><span class="line">		Constructor&lt;?&gt; constructorToUse;</span><br><span class="line">		<span class="keyword">synchronized</span> (bd.constructorArgumentLock) &#123;</span><br><span class="line">			constructorToUse = (Constructor&lt;?&gt;) bd.resolvedConstructorOrFactoryMethod;</span><br><span class="line">			<span class="keyword">if</span> (constructorToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">final</span> Class&lt;?&gt; clazz = bd.getBeanClass();</span><br><span class="line">				<span class="keyword">if</span> (clazz.isInterface()) &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> BeanInstantiationException(clazz, <span class="string">&quot;Specified class is an interface&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					<span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">						constructorToUse = AccessController.doPrivileged(</span><br><span class="line">								(PrivilegedExceptionAction&lt;Constructor&lt;?&gt;&gt;) clazz::getDeclaredConstructor);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span> &#123;</span><br><span class="line">						constructorToUse =	clazz.getDeclaredConstructor();</span><br><span class="line">					&#125;</span><br><span class="line">					bd.resolvedConstructorOrFactoryMethod = constructorToUse;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> BeanInstantiationException(clazz, <span class="string">&quot;No default constructor found&quot;</span>, ex);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">     <span class="comment">//调用静态方法来进行实例化</span></span><br><span class="line">		<span class="keyword">return</span> BeanUtils.instantiateClass(constructorToUse);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// Must generate CGLIB subclass.</span></span><br><span class="line">		<span class="keyword">return</span> instantiateWithMethodInjection(bd, beanName, owner);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，真正实例化的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Convenience method to instantiate a class using the given constructor.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Note that this method tries to set the constructor accessible if given a</span></span><br><span class="line"><span class="comment"> * non-accessible (that is, non-public) constructor, and supports Kotlin classes</span></span><br><span class="line"><span class="comment"> * with optional parameters and default values.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ctor the constructor to instantiate</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args the constructor arguments to apply (use &#123;<span class="doctag">@code</span> null&#125; for an unspecified</span></span><br><span class="line"><span class="comment"> * parameter if needed for Kotlin classes with optional parameters and default values)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the new instance</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeanInstantiationException if the bean cannot be instantiated</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> Constructor#newInstance</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">instantiateClass</span><span class="params">(Constructor&lt;T&gt; ctor, Object... args)</span> <span class="keyword">throws</span> BeanInstantiationException </span>&#123;</span><br><span class="line">	Assert.notNull(ctor, <span class="string">&quot;Constructor must not be null&quot;</span>);</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		ReflectionUtils.makeAccessible(ctor);</span><br><span class="line">		<span class="keyword">return</span> (KotlinDetector.isKotlinType(ctor.getDeclaringClass()) ?</span><br><span class="line">				KotlinDelegate.instantiateClass(ctor, args) : ctor.newInstance(args));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (InstantiationException ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> BeanInstantiationException(ctor, <span class="string">&quot;Is it an abstract class?&quot;</span>, ex);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (IllegalAccessException ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> BeanInstantiationException(ctor, <span class="string">&quot;Is the constructor accessible?&quot;</span>, ex);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> BeanInstantiationException(ctor, <span class="string">&quot;Illegal arguments for constructor&quot;</span>, ex);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> BeanInstantiationException(ctor, <span class="string">&quot;Constructor threw exception&quot;</span>, ex.getTargetException());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h2><p>通过断点调试，打印调用堆栈信息如下:</p>
<p>![](/assets/posts/Spring IOC Instance/spring ioc instance.png)</p>
<h2 id="4-思考"><a href="#4-思考" class="headerlink" title="4.思考"></a>4.思考</h2><p>第一个问题，思考层次化的问题，即为何进行这样的分层？接口的设计逻辑是什么，类继承的逻辑是什么？<br>![](/assets/posts/Spring IOC Instance/DefaultListableBeanFactory01.png)</p>
<p>可以思考上面的类继承的逻辑，对照着调用堆栈信息来看分析么一个层类(虚类)之间的继承关系的逻辑。</p>
<h2 id="5-参考文档"><a href="#5-参考文档" class="headerlink" title="5.参考文档"></a>5.参考文档</h2><ol>
<li>Spring source code, version: 5.0.7.RELEASE</li>
<li><a target="_blank" rel="noopener" href="http://www.importnew.com/27469.html">Spring IOC 容器源码分析</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/10/18/Spring-IOC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Robinson">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Road To Excelsior">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/10/18/Spring-IOC/" class="post-title-link" itemprop="url">Spring IOC(1) - 初始化</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-10-18 00:00:00" itemprop="dateCreated datePublished" datetime="2018-10-18T00:00:00+08:00">2018-10-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-12-18 00:43:33" itemprop="dateModified" datetime="2020-12-18T00:43:33+08:00">2020-12-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><p>Spring 为使用Java开发大型的应用程序提供了很好的模块化技术支持，极大的减小了耦合度。通过Spring IOC以及AOP，可以实现高度灵活的应用服务开发目的。</p>
<h2 id="1-样例程序"><a href="#1-样例程序" class="headerlink" title="1. 样例程序"></a>1. 样例程序</h2><p>为了能探清spring ioc的逻辑，我实现了一个小的样例，其通过ClassPathXmlApplicationContext来读取配置中的bean，以实现bean的实例化，入口函数如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext context =  <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;spring-beans.xml&quot;</span>);</span><br><span class="line">        Person person = (Person)context.getBean(<span class="string">&quot;pson&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Name: &quot;</span> + person.getName() + <span class="string">&quot;; Age: &quot;</span> + person.getAge());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中关于Person类的定义以及bean的定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>spring-beans.xml的配置如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;pson&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.demo.Person&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;tony&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;18&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="2-单步分析"><a href="#2-单步分析" class="headerlink" title="2.单步分析"></a>2.单步分析</h2><p>通过对ClassPathXmlApplicationContext实现类的单步调试，首先进入其中，可以画出如下的uml类图：<br>![](/assets/posts/Spring ioc/ApplicationContextHieracy.png)</p>
<h3 id="2-1-保存位置，并刷新"><a href="#2-1-保存位置，并刷新" class="headerlink" title="2.1 保存位置，并刷新"></a>2.1 保存位置，并刷新</h3><p>继续单步调试，可见，ClassPathXmlApplicationContext首先会保存相关的配置信息，供后面解析使用，之后，会调用其基类之一AbstractApplicationContext的refresh方法来解析：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">		String[] configLocations, <span class="keyword">boolean</span> refresh, <span class="meta">@Nullable</span> ApplicationContext parent)</span></span></span><br><span class="line"><span class="function">		<span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">super</span>(parent);</span><br><span class="line">	setConfigLocations(configLocations);</span><br><span class="line">	<span class="keyword">if</span> (refresh) &#123;</span><br><span class="line">		refresh();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> 	<span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">	<span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">		<span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line">		prepareRefresh();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line">		ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">		prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">			postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">			invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">			registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Initialize message source for this context.</span></span><br><span class="line">			initMessageSource();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">			initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">			onRefresh();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">			registerListeners();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">			finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">			finishRefresh();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">			<span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">				logger.warn(<span class="string">&quot;Exception encountered during context initialization - &quot;</span> +</span><br><span class="line">						<span class="string">&quot;cancelling refresh attempt: &quot;</span> + ex);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">			destroyBeans();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Reset &#x27;active&#x27; flag.</span></span><br><span class="line">			cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Propagate exception to caller.</span></span><br><span class="line">			<span class="keyword">throw</span> ex;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="comment">// Reset common introspection caches in Spring&#x27;s core, since we</span></span><br><span class="line">			<span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">			resetCommonCaches();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-获取beanFactory"><a href="#2-2-获取beanFactory" class="headerlink" title="2.2 获取beanFactory"></a>2.2 获取beanFactory</h3><p>在refresh()中，通过调用obtainFreshBeanFactory()方法来获取告诉子类来刷新内部的bean factory。其代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the fresh BeanFactory instance</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #refreshBeanFactory()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #getBeanFactory()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ConfigurableListableBeanFactory <span class="title">obtainFreshBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	refreshBeanFactory();</span><br><span class="line">	ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line">	<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">		logger.debug(<span class="string">&quot;Bean factory for &quot;</span> + getDisplayName() + <span class="string">&quot;: &quot;</span> + beanFactory);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> beanFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于这个类，翻译如下：告诉子类来刷新内部的bean factory。这个方法是在AbstractApplicationContext中的定义的，其中refreshBeanFactory()是一个接口，在子类AbstractRefreshableApplicationContext中实现的。</p>
<p>这时，可见这个方法在基类中的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// Abstract methods that must be implemented by subclasses</span></span><br><span class="line"><span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Subclasses must implement this method to perform the actual configuration load.</span></span><br><span class="line"><span class="comment"> * The method is invoked by &#123;<span class="doctag">@link</span> #refresh()&#125; before any other initialization work.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;A subclass will either create a new bean factory and hold a reference to it,</span></span><br><span class="line"><span class="comment"> * or return a single BeanFactory instance that it holds. In the latter case, it will</span></span><br><span class="line"><span class="comment"> * usually throw an IllegalStateException if refreshing the context more than once.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeansException if initialization of the bean factory failed</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalStateException if already initialized and multiple refresh</span></span><br><span class="line"><span class="comment"> * attempts are not supported</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException</span>;</span><br></pre></td></tr></table></figure>

<p>关于Abstract method的使用，可见思考章节。</p>
<p>可见这里使用一个局部标量来保存了beanFactory，其中关于ConfigurableListableBeanFactory的类图hieracy如下：<br>![](/assets/posts/Spring ioc/DefaultListableBeanFactory.png)</p>
<p>其调用子类(AbstractRefreshableApplicationContext)的refreshBeanFactory()来进行执行context下的beanfactory的刷新；这个方法会关闭先前的bean factory并且为context的另一个生命周期初始化一个新鲜的bean factory。具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (hasBeanFactory()) &#123;</span><br><span class="line">		destroyBeans();</span><br><span class="line">		closeBeanFactory();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		DefaultListableBeanFactory beanFactory = createBeanFactory();</span><br><span class="line">		beanFactory.setSerializationId(getId());</span><br><span class="line">		customizeBeanFactory(beanFactory);</span><br><span class="line">     <span class="comment">/**这个方法进入下一个调用栈*/</span></span><br><span class="line">		loadBeanDefinitions(beanFactory);</span><br><span class="line">		<span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanFactoryMonitor) &#123;</span><br><span class="line">			<span class="keyword">this</span>.beanFactory = beanFactory;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">&quot;I/O error parsing bean definition source for &quot;</span> + getDisplayName(), ex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-加载bean-定义"><a href="#2-3-加载bean-定义" class="headerlink" title="2.3 加载bean 定义"></a>2.3 加载bean 定义</h3><p>在loadBeanDefinitions(beanFactory)方法中，其进入子类(AbstractXmlApplicationContext)调用loadBeanDefinitions来通过一个xmlBeanDefinitionReader来加载bean definitions。具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException, IOException </span>&#123;</span><br><span class="line">	<span class="comment">// Create a new XmlBeanDefinitionReader for the given BeanFactory.</span></span><br><span class="line">	XmlBeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(beanFactory);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Configure the bean definition reader with this context&#x27;s</span></span><br><span class="line">	<span class="comment">// resource loading environment.</span></span><br><span class="line">	beanDefinitionReader.setEnvironment(<span class="keyword">this</span>.getEnvironment());</span><br><span class="line">	beanDefinitionReader.setResourceLoader(<span class="keyword">this</span>);</span><br><span class="line">	beanDefinitionReader.setEntityResolver(<span class="keyword">new</span> ResourceEntityResolver(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Allow a subclass to provide custom initialization of the reader,</span></span><br><span class="line">	<span class="comment">// then proceed with actually loading the bean definitions.</span></span><br><span class="line">	initBeanDefinitionReader(beanDefinitionReader);</span><br><span class="line">	loadBeanDefinitions(beanDefinitionReader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，关于xmlBeanDefinitionReader的类图层级如下：<br>![](/assets/posts/Spring ioc/XmlBeanDefinitionReader.png)</p>
<h3 id="2-4-注册beans的定义"><a href="#2-4-注册beans的定义" class="headerlink" title="2.4 注册beans的定义"></a>2.4 注册beans的定义</h3><p>经过一个简短的链路，最终在xmlBeanDeifinitionReader中registerBeanDefinitions()方法中，在一个给定的DOM 文档中注册相应的bean definitions。具体的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**Creates a new instance of the parser class and invokes*/</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document doc, Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">	BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();</span><br><span class="line">	<span class="keyword">int</span> countBefore = getRegistry().getBeanDefinitionCount();</span><br><span class="line">	documentReader.registerBeanDefinitions(doc, createReaderContext(resource));</span><br><span class="line">	<span class="keyword">return</span> getRegistry().getBeanDefinitionCount() - countBefore;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，值得一提的是，BeanDefinitionDocumentReader实例是通过反射的方式来实现的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">protected</span> BeanDefinitionDocumentReader <span class="title">createBeanDefinitionDocumentReader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> BeanDefinitionDocumentReader.class.cast(BeanUtils.instantiateClass(<span class="keyword">this</span>.documentReaderClass));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>👌，现在进入BeanDefinitionDocumentReader中注册相关的bean definitions，在其实现类DefaultBeanDefinitionDocumentReader中，完成了对DOM元素的解析以及相关的beans的注册：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Register each bean definition within the given root &#123;<span class="doctag">@code</span> &lt;beans/&gt;&#125; element.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRegisterBeanDefinitions</span><span class="params">(Element root)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// Any nested &lt;beans&gt; elements will cause recursion in this method. In</span></span><br><span class="line">	<span class="comment">// order to propagate and preserve &lt;beans&gt; default-* attributes correctly,</span></span><br><span class="line">	<span class="comment">// keep track of the current (parent) delegate, which may be null. Create</span></span><br><span class="line">	<span class="comment">// the new (child) delegate with a reference to the parent for fallback purposes,</span></span><br><span class="line">	<span class="comment">// then ultimately reset this.delegate back to its original (parent) reference.</span></span><br><span class="line">	<span class="comment">// this behavior emulates a stack of delegates without actually necessitating one.</span></span><br><span class="line">	BeanDefinitionParserDelegate parent = <span class="keyword">this</span>.delegate;</span><br><span class="line">	<span class="keyword">this</span>.delegate = createDelegate(getReaderContext(), root, parent);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">		String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);</span><br><span class="line">		<span class="keyword">if</span> (StringUtils.hasText(profileSpec)) &#123;</span><br><span class="line">			String[] specifiedProfiles = StringUtils.tokenizeToStringArray(</span><br><span class="line">					profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">			<span class="keyword">if</span> (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) &#123;</span><br><span class="line">				<span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">					logger.info(<span class="string">&quot;Skipped XML bean definition file due to specified profiles [&quot;</span> + profileSpec +</span><br><span class="line">							<span class="string">&quot;] not matching: &quot;</span> + getReaderContext().getResource());</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	preProcessXml(root);</span><br><span class="line">	parseBeanDefinitions(root, <span class="keyword">this</span>.delegate);</span><br><span class="line">	postProcessXml(root);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">this</span>.delegate = parent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> BeanDefinitionParserDelegate <span class="title">createDelegate</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">		XmlReaderContext readerContext, Element root, <span class="meta">@Nullable</span> BeanDefinitionParserDelegate parentDelegate)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	BeanDefinitionParserDelegate delegate = <span class="keyword">new</span> BeanDefinitionParserDelegate(readerContext);</span><br><span class="line">	delegate.initDefaults(root, parentDelegate);</span><br><span class="line">	<span class="keyword">return</span> delegate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，其创建了代理对象BeanDefinitionParserDelegate来完成注册过程；👌，其中preProcessXml和postProcessXml在这个实现类中为空，所以只需要关注parseBeanDefinitions方法即可。其代码很简单，就是进行简单的DOM元素解析，并进行注册:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Parse the elements at the root level in the document:</span></span><br><span class="line"><span class="comment"> * &quot;import&quot;, &quot;alias&quot;, &quot;bean&quot;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root the DOM root element of the document</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">parseBeanDefinitions</span><span class="params">(Element root, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">		NodeList nl = root.getChildNodes();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">			Node node = nl.item(i);</span><br><span class="line">			<span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">				Element ele = (Element) node;</span><br><span class="line">				<span class="keyword">if</span> (delegate.isDefaultNamespace(ele)) &#123;</span><br><span class="line">					parseDefaultElement(ele, delegate);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					delegate.parseCustomElement(ele);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		delegate.parseCustomElement(root);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseDefaultElement</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) &#123;</span><br><span class="line">		importBeanDefinitionResource(ele);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) &#123;</span><br><span class="line">		processAliasRegistration(ele);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) &#123;</span><br><span class="line">		processBeanDefinition(ele, delegate);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) &#123;</span><br><span class="line">		<span class="comment">// recurse</span></span><br><span class="line">		doRegisterBeanDefinitions(ele);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在我们的例子中，我们的断点会走到 <strong>processBeanDefinitions</strong>方法处进行bean定义的处理。其实，默认的xml还可以进行“import, alias”元素的解析。在这个方法中，其通过一个静态方法来实现了DefaultListableBeanFactory来完成进行注册过程：</p>
<p>同时，这个静态方法的入参registry的是DefaultListableBeanFactory的成员变量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">  <span class="keyword">private</span> XmlReaderContext readerContext;</span><br></pre></td></tr></table></figure>

<p>在调用静态方法时，这个成员变量会被传入作为入参，完成实际的注册过程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Process the given bean element, parsing the bean definition</span></span><br><span class="line"><span class="comment"> * and registering it with the registry.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processBeanDefinition</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">	BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);</span><br><span class="line">	<span class="keyword">if</span> (bdHolder != <span class="keyword">null</span>) &#123;</span><br><span class="line">		bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// Register the final decorated instance.</span></span><br><span class="line">			BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">			getReaderContext().error(<span class="string">&quot;Failed to register bean definition with name &#x27;&quot;</span> +</span><br><span class="line">					bdHolder.getBeanName() + <span class="string">&quot;&#x27;&quot;</span>, ele, ex);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Send registration event.</span></span><br><span class="line">		getReaderContext().fireComponentRegistered(<span class="keyword">new</span> BeanComponentDefinition(bdHolder));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-5-通过DefaultListableBeanFactory完成注册"><a href="#2-5-通过DefaultListableBeanFactory完成注册" class="headerlink" title="2.5 通过DefaultListableBeanFactory完成注册"></a>2.5 通过DefaultListableBeanFactory完成注册</h3><p>这个时候可以再看看DefaultListableBeanFactory的类图层次:<br>![](/assets/posts/Spring ioc/DefaultListableBeanFactory.png)<br>如图所示，其实现了BeanDefinitioinRegistry接口，完成bean的注册，同时，在BeanDefinitionReaderUtils中可见代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Register the given bean definition with the given bean factory.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> definitionHolder the bean definition including name and aliases</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> registry the bean factory to register with</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeanDefinitionStoreException if registration failed</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">		BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)</span></span></span><br><span class="line"><span class="function">		<span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Register bean definition under primary name.</span></span><br><span class="line">	String beanName = definitionHolder.getBeanName();</span><br><span class="line">	registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Register aliases for bean name, if any.</span></span><br><span class="line">	String[] aliases = definitionHolder.getAliases();</span><br><span class="line">	<span class="keyword">if</span> (aliases != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> (String alias : aliases) &#123;</span><br><span class="line">			registry.registerAlias(beanName, alias);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，我们进入registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition())方法中观察其实现类的逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// Implementation of BeanDefinitionRegistry interface</span></span><br><span class="line"><span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span></span></span><br><span class="line"><span class="function">		<span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line">	Assert.hasText(beanName, <span class="string">&quot;Bean name must not be empty&quot;</span>);</span><br><span class="line">	Assert.notNull(beanDefinition, <span class="string">&quot;BeanDefinition must not be null&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (beanDefinition <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			((AbstractBeanDefinition) beanDefinition).validate();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,</span><br><span class="line">					<span class="string">&quot;Validation of bean definition failed&quot;</span>, ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	BeanDefinition oldBeanDefinition;</span><br><span class="line"></span><br><span class="line">	oldBeanDefinition = <span class="keyword">this</span>.beanDefinitionMap.get(beanName);</span><br><span class="line">	<span class="keyword">if</span> (oldBeanDefinition != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!isAllowBeanDefinitionOverriding()) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,</span><br><span class="line">					<span class="string">&quot;Cannot register bean definition [&quot;</span> + beanDefinition + <span class="string">&quot;] for bean &#x27;&quot;</span> + beanName +</span><br><span class="line">					<span class="string">&quot;&#x27;: There is already [&quot;</span> + oldBeanDefinition + <span class="string">&quot;] bound.&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (oldBeanDefinition.getRole() &lt; beanDefinition.getRole()) &#123;</span><br><span class="line">			<span class="comment">// e.g. was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE</span></span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.logger.isWarnEnabled()) &#123;</span><br><span class="line">				<span class="keyword">this</span>.logger.warn(<span class="string">&quot;Overriding user-defined bean definition for bean &#x27;&quot;</span> + beanName +</span><br><span class="line">						<span class="string">&quot;&#x27; with a framework-generated bean definition: replacing [&quot;</span> +</span><br><span class="line">						oldBeanDefinition + <span class="string">&quot;] with [&quot;</span> + beanDefinition + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (!beanDefinition.equals(oldBeanDefinition)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.logger.isInfoEnabled()) &#123;</span><br><span class="line">				<span class="keyword">this</span>.logger.info(<span class="string">&quot;Overriding bean definition for bean &#x27;&quot;</span> + beanName +</span><br><span class="line">						<span class="string">&quot;&#x27; with a different definition: replacing [&quot;</span> + oldBeanDefinition +</span><br><span class="line">						<span class="string">&quot;] with [&quot;</span> + beanDefinition + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line">				<span class="keyword">this</span>.logger.debug(<span class="string">&quot;Overriding bean definition for bean &#x27;&quot;</span> + beanName +</span><br><span class="line">						<span class="string">&quot;&#x27; with an equivalent definition: replacing [&quot;</span> + oldBeanDefinition +</span><br><span class="line">						<span class="string">&quot;] with [&quot;</span> + beanDefinition + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (hasBeanCreationStarted()) &#123;</span><br><span class="line">			<span class="comment">// Cannot modify startup-time collection elements anymore (for stable iteration)</span></span><br><span class="line">			<span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanDefinitionMap) &#123;</span><br><span class="line">				<span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">				List&lt;String&gt; updatedDefinitions = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.beanDefinitionNames.size() + <span class="number">1</span>);</span><br><span class="line">				updatedDefinitions.addAll(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line">				updatedDefinitions.add(beanName);</span><br><span class="line">				<span class="keyword">this</span>.beanDefinitionNames = updatedDefinitions;</span><br><span class="line">				<span class="keyword">if</span> (<span class="keyword">this</span>.manualSingletonNames.contains(beanName)) &#123;</span><br><span class="line">					Set&lt;String&gt; updatedSingletons = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="keyword">this</span>.manualSingletonNames);</span><br><span class="line">					updatedSingletons.remove(beanName);</span><br><span class="line">					<span class="keyword">this</span>.manualSingletonNames = updatedSingletons;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// Still in startup registration phase</span></span><br><span class="line">			<span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">			<span class="keyword">this</span>.beanDefinitionNames.add(beanName);</span><br><span class="line">			<span class="keyword">this</span>.manualSingletonNames.remove(beanName);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">this</span>.frozenBeanDefinitionNames = <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (oldBeanDefinition != <span class="keyword">null</span> || containsSingleton(beanName)) &#123;</span><br><span class="line">		resetBeanDefinition(beanName);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过观察，其是在一个Map中放入了相应的bean名称和定义，完成的初始化的过程。</p>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h2><p>通过上面的过程，ClassPathXmlApplicationContext完成了Spring IOC的初始化过程，通过设置断点来打印出调用堆栈如下所示：<br>![](/assets/posts/Spring ioc/callStack.png)</p>
<p>从下往上看其可以大概分为四个层次：</p>
<ol>
<li>AbstractXmlApplicationContext 来 <strong>调用</strong>加载Bean definitions的过程；</li>
<li>其通过实例化的局部变量xmlBeanDefinitionReader来 <strong>执行</strong>bean definition的加载过程；</li>
<li>其通过反射的方式实例化BeanDefinitionDocumentReader来完成注册过程；</li>
<li>其通过静态方法BeanDefinitionReaderUtils.registerBeanDefinition()来完成实际的注册。</li>
</ol>
<h2 id="4-思考"><a href="#4-思考" class="headerlink" title="4.思考"></a>4.思考</h2><p>第一个问题：DefaultListableBeanFactory是在哪儿进行实例化的？ 以及其是在哪里进行引入到BeanDefinitionReaderUtils作为入参的？</p>
<p>答：首先，我们分析静态方法的入参是“getReaderContext().getRegistry()”，也就是xmlReaderContext中的公开方法，也就是说需要找到这个成员变量是在哪儿实例化的。那么我们看到步骤中2中，其实例化的代码在AbstractXmlApplicationContext中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XmlBeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(beanFactory);</span><br></pre></td></tr></table></figure>
<p>其入参是一个beanFactory，所以我们就可以找到这个入参是何时实例化就行了。👌，现在我们往上捋，发现调用这个的是AbstractRefreshableApplicationContext的refreshBeanFactory()方法(见2.2)，在这里实例化一个beanFactory并传入其中，其中实例化BeanFactory的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Create an internal bean factory for this context.</span></span><br><span class="line"><span class="comment">	 * Called for each &#123;<span class="doctag">@link</span> #refresh()&#125; attempt.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;The default implementation creates a</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@link</span> org.springframework.beans.factory.support.DefaultListableBeanFactory&#125;</span></span><br><span class="line"><span class="comment">	 * with the &#123;<span class="doctag">@linkplain</span> #getInternalParentBeanFactory() internal bean factory&#125; of this</span></span><br><span class="line"><span class="comment">	 * context&#x27;s parent as parent bean factory. Can be overridden in subclasses,</span></span><br><span class="line"><span class="comment">	 * for example to customize DefaultListableBeanFactory&#x27;s settings.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> the bean factory for this context</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> org.springframework.beans.factory.support.DefaultListableBeanFactory#setAllowBeanDefinitionOverriding</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> org.springframework.beans.factory.support.DefaultListableBeanFactory#setAllowEagerClassLoading</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> org.springframework.beans.factory.support.DefaultListableBeanFactory#setAllowCircularReferences</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> org.springframework.beans.factory.support.DefaultListableBeanFactory#setAllowRawInjectionDespiteWrapping</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> DefaultListableBeanFactory <span class="title">createBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> DefaultListableBeanFactory(getInternalParentBeanFactory());</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>至此，这个问题就捋清楚了。</p>
<p>第二个问题，思考层次化的问题，即为何进行这样的分层？接口的设计逻辑是什么，类继承的逻辑是什么？</p>
<p>解答一：其中关于虚拟类，以及虚拟类方法的定义和设计，可见第三个问题的解释。<br>解答二：通过对 <strong>虚拟类方法</strong>的分析以及 <strong>面向接口编程</strong>的思想，可以看出ClassPathXmlApplicationContext是继承了AbstractXmlApplicationContext的实现类，如名字所示，这个类的主要功能是调用了xmlBeanDefinitionReader来完成加载bean defintions的目的；在往上走的话，可以看出，其中一个主要的虚拟类是AbstractApplicationContext，其定义了加载刷新context的框架refresh()，其中具体的实现及其实现的类层次如下：</p>
<ol>
<li>refreshBeanFactory()虚拟方法是在AbstractRefreshableApplicationContext <strong>虚拟子类</strong>中实现的，此实现执行此上下文的底下的bean工厂的实际刷新，关闭之前的bean factory(如果有的话)，并且为下一轮的上下文生命周期初始化一个崭新的工厂。</li>
<li>在refreshBeanFactory()方法中调用了虚拟方法loadBeanDefinitions()，在虚拟子类AbstractXmlApplicationContext中loadBeanDefinitions()被实现了，其是通过xmlBeanDefinitionReader局部变量来实现的；</li>
<li>xmlBeanDefinitionReader的继承关系如上所示，可以得出，其具体实现通过在方法registerBeanDefinitions()中生成一个BeanDefinitionDocumentReader局部变量来完成。</li>
<li>在BeanDefinitionDocumentReader的实现类中，doRegisterBeanDefinitions方法完成了最后的bean 注册工作。</li>
</ol>
<p>第三个问题，如上面提到的Abstract method的内容：</p>
<p>Rules of Abstract Method</p>
<ol>
<li>Abstract methods don’t have body, they just have method signature as shown above.</li>
<li>If a class has an abstract method it should be declared abstract, the vice versa is not true, which means an abstract class doesn’t need to have an abstract method compulsory.</li>
<li>If a regular class extends an abstract class, then the class must have to implement all the abstract methods of abstract parent class or it has to be declared abstract as well.</li>
</ol>
<p>翻译过来就是说：</p>
<ol>
<li>虚方法没有方法体，只有方法签名；</li>
<li>如果一个类有虚方法，它最好被声明为虚的，但是反过来则不一定，即一个虚的类不一定需要有一个虚方法的义务。</li>
<li>如果一个常规类继承了虚类，则这个类必须实现父类的所有的虚方法， 或则自己被声明为虚的。</li>
</ol>
<p>关于虚拟类方法的文档：<br><a target="_blank" rel="noopener" href="https://beginnersbook.com/2014/01/abstract-method-with-examples-in-java/">Abstract method in Java with examples</a><br><a target="_blank" rel="noopener" href="https://beginnersbook.com/2013/05/java-abstract-class-method/">Abstract Class in Java with example</a></p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ol>
<li>Spring source code, version: 5.0.7.RELEASE</li>
<li><a target="_blank" rel="noopener" href="https://yikun.github.io/2015/05/29/Spring-IOC%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/">Spring IOC核心源码学习</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/10/14/html-css-mindmap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Robinson">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Road To Excelsior">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/10/14/html-css-mindmap/" class="post-title-link" itemprop="url">MindMap of html & css</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-10-14 00:00:00" itemprop="dateCreated datePublished" datetime="2018-10-14T00:00:00+08:00">2018-10-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-12-18 00:42:52" itemprop="dateModified" datetime="2020-12-18T00:42:52+08:00">2020-12-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><p>除了思维导图中需要了解的知识点，其中，需要注意的是CSS的结构和层叠，这个可在CSS权威指南第三章中找到，其主要包括特殊性，继承以及层叠。</p>
<p><strong>继承(Inheritance)**是从一个元素向其后代元素传递属性值所采用的机制；确定应当向一个元素应用哪些值时，用户代理不仅需要考虑继承，还要考虑声明的特殊性，另外需要考虑声明本身的来源。这个过程就叫着</strong>层叠(cascade)**。</p>
<h3 id="特殊性"><a href="#特殊性" class="headerlink" title="特殊性"></a>特殊性</h3><p>对于每条规则，用户代理会计算出选择器的特殊性，并将这些特殊性附加到规则中的各个声明。如果一个元素有两个或者多个冲突的属性声明，那么有最高特殊性的声明就会胜出。</p>
<p>详情可见书中该章节内容；</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承是CSS中最基本的内容之一；需要注意的是，有一些属性不能继承，这往往归因于一个简单的常识，例如属性boarder就不会继承。<br>一般地，大多数框模型属性（包括外边距，内边距，背景和边框）都不能继承。</p>
<p>同时，需要注意的是，继承的值没有特殊性，甚至连0特殊性都没有。</p>
<h3 id="层叠"><a href="#层叠" class="headerlink" title="层叠"></a>层叠</h3><p>CSS2.1的层叠规则如下：</p>
<ol>
<li>找出所有相关的规则，这些规则都包含与一个给定的元素匹配的选择器；</li>
<li>按<em>显示权重</em>对应用到该元素的所有声明进行排序。规则如下面所示；</li>
<li>按<em>特殊性</em>对应用到给定元素的所有声明排序。有较高特殊性的元素权重要大于较低特殊性的元素；</li>
<li>按出现顺序对应用到给定元素的所有声明排序。一个声明在样式表或文档中越后出现，它的权重远大。如果样式表中有导入的样式表，一般认为在导入样式表中的声明在前，主样式表中的所有声明在后。</li>
</ol>
<p>在声明权重方面需要考虑5级，权重有大至小的顺序依次为：</p>
<ol>
<li>读者的重要声明</li>
<li>创作人员的重要声明</li>
<li>创作人员的正常声明</li>
<li>读者的正常声明</li>
<li>用户代理的声明</li>
</ol>
<h2 id="总结和思考"><a href="#总结和思考" class="headerlink" title="总结和思考"></a>总结和思考</h2><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ol>
<li><a href="/assets/posts/html-css/HTML+CSS.itmz">html+css思维导图</a></li>
<li>《CSS权威指南(第三版)》</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Robinson</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">32</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Robinson</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
